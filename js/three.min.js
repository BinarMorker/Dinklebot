var THREE = { REVISION: "61" }; self.console = self.console || { info: function () { }, log: function () { }, debug: function () { }, warn: function () { }, error: function () { } }; String.prototype.trim = String.prototype.trim || function () { return this.replace(/^\s+|\s+$/g, "") }; THREE.extend = function (e, t) { if (Object.keys) { var n = Object.keys(t); for (var r = 0, i = n.length; r < i; r++) { var s = n[r]; Object.defineProperty(e, s, Object.getOwnPropertyDescriptor(t, s)) } } else { var o = {}.hasOwnProperty; for (var s in t) { if (o.call(t, s)) { e[s] = t[s] } } } return e }; (function () { var e = 0; var t = ["ms", "moz", "webkit", "o"]; for (var n = 0; n < t.length && !self.requestAnimationFrame; ++n) { self.requestAnimationFrame = self[t[n] + "RequestAnimationFrame"]; self.cancelAnimationFrame = self[t[n] + "CancelAnimationFrame"] || self[t[n] + "CancelRequestAnimationFrame"] } if (self.requestAnimationFrame === undefined && self["setTimeout"] !== undefined) { self.requestAnimationFrame = function (t) { var n = Date.now(), r = Math.max(0, 16 - (n - e)); var i = self.setTimeout(function () { t(n + r) }, r); e = n + r; return i } } if (self.cancelAnimationFrame === undefined && self["clearTimeout"] !== undefined) { self.cancelAnimationFrame = function (e) { self.clearTimeout(e) } } })(); THREE.CullFaceNone = 0; THREE.CullFaceBack = 1; THREE.CullFaceFront = 2; THREE.CullFaceFrontBack = 3; THREE.FrontFaceDirectionCW = 0; THREE.FrontFaceDirectionCCW = 1; THREE.BasicShadowMap = 0; THREE.PCFShadowMap = 1; THREE.PCFSoftShadowMap = 2; THREE.FrontSide = 0; THREE.BackSide = 1; THREE.DoubleSide = 2; THREE.NoShading = 0; THREE.FlatShading = 1; THREE.SmoothShading = 2; THREE.NoColors = 0; THREE.FaceColors = 1; THREE.VertexColors = 2; THREE.NoBlending = 0; THREE.NormalBlending = 1; THREE.AdditiveBlending = 2; THREE.SubtractiveBlending = 3; THREE.MultiplyBlending = 4; THREE.CustomBlending = 5; THREE.AddEquation = 100; THREE.SubtractEquation = 101; THREE.ReverseSubtractEquation = 102; THREE.ZeroFactor = 200; THREE.OneFactor = 201; THREE.SrcColorFactor = 202; THREE.OneMinusSrcColorFactor = 203; THREE.SrcAlphaFactor = 204; THREE.OneMinusSrcAlphaFactor = 205; THREE.DstAlphaFactor = 206; THREE.OneMinusDstAlphaFactor = 207; THREE.DstColorFactor = 208; THREE.OneMinusDstColorFactor = 209; THREE.SrcAlphaSaturateFactor = 210; THREE.MultiplyOperation = 0; THREE.MixOperation = 1; THREE.AddOperation = 2; THREE.UVMapping = function () { }; THREE.CubeReflectionMapping = function () { }; THREE.CubeRefractionMapping = function () { }; THREE.SphericalReflectionMapping = function () { }; THREE.SphericalRefractionMapping = function () { }; THREE.RepeatWrapping = 1e3; THREE.ClampToEdgeWrapping = 1001; THREE.MirroredRepeatWrapping = 1002; THREE.NearestFilter = 1003; THREE.NearestMipMapNearestFilter = 1004; THREE.NearestMipMapLinearFilter = 1005; THREE.LinearFilter = 1006; THREE.LinearMipMapNearestFilter = 1007; THREE.LinearMipMapLinearFilter = 1008; THREE.UnsignedByteType = 1009; THREE.ByteType = 1010; THREE.ShortType = 1011; THREE.UnsignedShortType = 1012; THREE.IntType = 1013; THREE.UnsignedIntType = 1014; THREE.FloatType = 1015; THREE.UnsignedShort4444Type = 1016; THREE.UnsignedShort5551Type = 1017; THREE.UnsignedShort565Type = 1018; THREE.AlphaFormat = 1019; THREE.RGBFormat = 1020; THREE.RGBAFormat = 1021; THREE.LuminanceFormat = 1022; THREE.LuminanceAlphaFormat = 1023; THREE.RGB_S3TC_DXT1_Format = 2001; THREE.RGBA_S3TC_DXT1_Format = 2002; THREE.RGBA_S3TC_DXT3_Format = 2003; THREE.RGBA_S3TC_DXT5_Format = 2004; THREE.Color = function (e) { if (e !== undefined) this.set(e); return this }; THREE.Color.prototype = { constructor: THREE.Color, r: 1, g: 1, b: 1, set: function (e) { if (e instanceof THREE.Color) { this.copy(e) } else if (typeof e === "number") { this.setHex(e) } else if (typeof e === "string") { this.setStyle(e) } return this }, setHex: function (e) { e = Math.floor(e); this.r = (e >> 16 & 255) / 255; this.g = (e >> 8 & 255) / 255; this.b = (e & 255) / 255; return this }, setRGB: function (e, t, n) { this.r = e; this.g = t; this.b = n; return this }, setHSL: function (e, t, n) { if (t === 0) { this.r = this.g = this.b = n } else { var r = function (e, t, n) { if (n < 0) n += 1; if (n > 1) n -= 1; if (n < 1 / 6) return e + (t - e) * 6 * n; if (n < 1 / 2) return t; if (n < 2 / 3) return e + (t - e) * 6 * (2 / 3 - n); return e }; var i = n <= .5 ? n * (1 + t) : n + t - n * t; var s = 2 * n - i; this.r = r(s, i, e + 1 / 3); this.g = r(s, i, e); this.b = r(s, i, e - 1 / 3) } return this }, setStyle: function (e) { if (/^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(e)) { var t = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(e); this.r = Math.min(255, parseInt(t[1], 10)) / 255; this.g = Math.min(255, parseInt(t[2], 10)) / 255; this.b = Math.min(255, parseInt(t[3], 10)) / 255; return this } if (/^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(e)) { var t = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(e); this.r = Math.min(100, parseInt(t[1], 10)) / 100; this.g = Math.min(100, parseInt(t[2], 10)) / 100; this.b = Math.min(100, parseInt(t[3], 10)) / 100; return this } if (/^\#([0-9a-f]{6})$/i.test(e)) { var t = /^\#([0-9a-f]{6})$/i.exec(e); this.setHex(parseInt(t[1], 16)); return this } if (/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(e)) { var t = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(e); this.setHex(parseInt(t[1] + t[1] + t[2] + t[2] + t[3] + t[3], 16)); return this } if (/^(\w+)$/i.test(e)) { this.setHex(THREE.ColorKeywords[e]); return this } }, copy: function (e) { this.r = e.r; this.g = e.g; this.b = e.b; return this }, copyGammaToLinear: function (e) { this.r = e.r * e.r; this.g = e.g * e.g; this.b = e.b * e.b; return this }, copyLinearToGamma: function (e) { this.r = Math.sqrt(e.r); this.g = Math.sqrt(e.g); this.b = Math.sqrt(e.b); return this }, convertGammaToLinear: function () { var e = this.r, t = this.g, n = this.b; this.r = e * e; this.g = t * t; this.b = n * n; return this }, convertLinearToGamma: function () { this.r = Math.sqrt(this.r); this.g = Math.sqrt(this.g); this.b = Math.sqrt(this.b); return this }, getHex: function () { return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0 }, getHexString: function () { return ("000000" + this.getHex().toString(16)).slice(-6) }, getHSL: function () { var e = { h: 0, s: 0, l: 0 }; return function () { var t = this.r, n = this.g, r = this.b; var i = Math.max(t, n, r); var s = Math.min(t, n, r); var o, u; var a = (s + i) / 2; if (s === i) { o = 0; u = 0 } else { var f = i - s; u = a <= .5 ? f / (i + s) : f / (2 - i - s); switch (i) { case t: o = (n - r) / f + (n < r ? 6 : 0); break; case n: o = (r - t) / f + 2; break; case r: o = (t - n) / f + 4; break } o /= 6 } e.h = o; e.s = u; e.l = a; return e } }(), getStyle: function () { return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")" }, offsetHSL: function (e, t, n) { var r = this.getHSL(); r.h += e; r.s += t; r.l += n; this.setHSL(r.h, r.s, r.l); return this }, add: function (e) { this.r += e.r; this.g += e.g; this.b += e.b; return this }, addColors: function (e, t) { this.r = e.r + t.r; this.g = e.g + t.g; this.b = e.b + t.b; return this }, addScalar: function (e) { this.r += e; this.g += e; this.b += e; return this }, multiply: function (e) { this.r *= e.r; this.g *= e.g; this.b *= e.b; return this }, multiplyScalar: function (e) { this.r *= e; this.g *= e; this.b *= e; return this }, lerp: function (e, t) { this.r += (e.r - this.r) * t; this.g += (e.g - this.g) * t; this.b += (e.b - this.b) * t; return this }, equals: function (e) { return e.r === this.r && e.g === this.g && e.b === this.b }, fromArray: function (e) { this.r = e[0]; this.g = e[1]; this.b = e[2]; return this }, toArray: function () { return [this.r, this.g, this.b] }, clone: function () { return (new THREE.Color).setRGB(this.r, this.g, this.b) } }; THREE.Quaternion = function (e, t, n, r) { this._x = e || 0; this._y = t || 0; this._z = n || 0; this._w = r !== undefined ? r : 1 }; THREE.Quaternion.prototype = { constructor: THREE.Quaternion, _x: 0, _y: 0, _z: 0, _w: 0, _euler: undefined, _updateEuler: function (e) { if (this._euler !== undefined) { this._euler.setFromQuaternion(this, undefined, false) } }, get x() { return this._x }, set x(e) { this._x = e; this._updateEuler() }, get y() { return this._y }, set y(e) { this._y = e; this._updateEuler() }, get z() { return this._z }, set z(e) { this._z = e; this._updateEuler() }, get w() { return this._w }, set w(e) { this._w = e; this._updateEuler() }, set: function (e, t, n, r) { this._x = e; this._y = t; this._z = n; this._w = r; this._updateEuler(); return this }, copy: function (e) { this._x = e._x; this._y = e._y; this._z = e._z; this._w = e._w; this._updateEuler(); return this }, setFromEuler: function (e, t) { if (e instanceof THREE.Euler === false) { throw new Error("ERROR: Quaternion's .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.") } var n = Math.cos(e._x / 2); var r = Math.cos(e._y / 2); var i = Math.cos(e._z / 2); var s = Math.sin(e._x / 2); var o = Math.sin(e._y / 2); var u = Math.sin(e._z / 2); if (e.order === "XYZ") { this._x = s * r * i + n * o * u; this._y = n * o * i - s * r * u; this._z = n * r * u + s * o * i; this._w = n * r * i - s * o * u } else if (e.order === "YXZ") { this._x = s * r * i + n * o * u; this._y = n * o * i - s * r * u; this._z = n * r * u - s * o * i; this._w = n * r * i + s * o * u } else if (e.order === "ZXY") { this._x = s * r * i - n * o * u; this._y = n * o * i + s * r * u; this._z = n * r * u + s * o * i; this._w = n * r * i - s * o * u } else if (e.order === "ZYX") { this._x = s * r * i - n * o * u; this._y = n * o * i + s * r * u; this._z = n * r * u - s * o * i; this._w = n * r * i + s * o * u } else if (e.order === "YZX") { this._x = s * r * i + n * o * u; this._y = n * o * i + s * r * u; this._z = n * r * u - s * o * i; this._w = n * r * i - s * o * u } else if (e.order === "XZY") { this._x = s * r * i - n * o * u; this._y = n * o * i - s * r * u; this._z = n * r * u + s * o * i; this._w = n * r * i + s * o * u } if (t !== false) this._updateEuler(); return this }, setFromAxisAngle: function (e, t) { var n = t / 2, r = Math.sin(n); this._x = e.x * r; this._y = e.y * r; this._z = e.z * r; this._w = Math.cos(n); this._updateEuler(); return this }, setFromRotationMatrix: function (e) { var t = e.elements, n = t[0], r = t[4], i = t[8], s = t[1], o = t[5], u = t[9], a = t[2], f = t[6], l = t[10], c = n + o + l, h; if (c > 0) { h = .5 / Math.sqrt(c + 1); this._w = .25 / h; this._x = (f - u) * h; this._y = (i - a) * h; this._z = (s - r) * h } else if (n > o && n > l) { h = 2 * Math.sqrt(1 + n - o - l); this._w = (f - u) / h; this._x = .25 * h; this._y = (r + s) / h; this._z = (i + a) / h } else if (o > l) { h = 2 * Math.sqrt(1 + o - n - l); this._w = (i - a) / h; this._x = (r + s) / h; this._y = .25 * h; this._z = (u + f) / h } else { h = 2 * Math.sqrt(1 + l - n - o); this._w = (s - r) / h; this._x = (i + a) / h; this._y = (u + f) / h; this._z = .25 * h } this._updateEuler(); return this }, inverse: function () { this.conjugate().normalize(); return this }, conjugate: function () { this._x *= -1; this._y *= -1; this._z *= -1; this._updateEuler(); return this }, lengthSq: function () { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w }, length: function () { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) }, normalize: function () { var e = this.length(); if (e === 0) { this._x = 0; this._y = 0; this._z = 0; this._w = 1 } else { e = 1 / e; this._x = this._x * e; this._y = this._y * e; this._z = this._z * e; this._w = this._w * e } return this }, multiply: function (e, t) { if (t !== undefined) { console.warn("DEPRECATED: Quaternion's .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."); return this.multiplyQuaternions(e, t) } return this.multiplyQuaternions(this, e) }, multiplyQuaternions: function (e, t) { var n = e._x, r = e._y, i = e._z, s = e._w; var o = t._x, u = t._y, a = t._z, f = t._w; this._x = n * f + s * o + r * a - i * u; this._y = r * f + s * u + i * o - n * a; this._z = i * f + s * a + n * u - r * o; this._w = s * f - n * o - r * u - i * a; this._updateEuler(); return this }, multiplyVector3: function (e) { console.warn("DEPRECATED: Quaternion's .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."); return e.applyQuaternion(this) }, slerp: function (e, t) { var n = this._x, r = this._y, i = this._z, s = this._w; var o = s * e._w + n * e._x + r * e._y + i * e._z; if (o < 0) { this._w = -e._w; this._x = -e._x; this._y = -e._y; this._z = -e._z; o = -o } else { this.copy(e) } if (o >= 1) { this._w = s; this._x = n; this._y = r; this._z = i; return this } var u = Math.acos(o); var a = Math.sqrt(1 - o * o); if (Math.abs(a) < .001) { this._w = .5 * (s + this._w); this._x = .5 * (n + this._x); this._y = .5 * (r + this._y); this._z = .5 * (i + this._z); return this } var f = Math.sin((1 - t) * u) / a, l = Math.sin(t * u) / a; this._w = s * f + this._w * l; this._x = n * f + this._x * l; this._y = r * f + this._y * l; this._z = i * f + this._z * l; this._updateEuler(); return this }, equals: function (e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w }, fromArray: function (e) { this._x = e[0]; this._y = e[1]; this._z = e[2]; this._w = e[3]; this._updateEuler(); return this }, toArray: function () { return [this._x, this._y, this._z, this._w] }, clone: function () { return new THREE.Quaternion(this._x, this._y, this._z, this._w) } }; THREE.Quaternion.slerp = function (e, t, n, r) { return n.copy(e).slerp(t, r) }; THREE.Vector2 = function (e, t) { this.x = e || 0; this.y = t || 0 }; THREE.Vector2.prototype = { constructor: THREE.Vector2, set: function (e, t) { this.x = e; this.y = t; return this }, setX: function (e) { this.x = e; return this }, setY: function (e) { this.y = e; return this }, setComponent: function (e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; default: throw new Error("index is out of range: " + e) } }, getComponent: function (e) { switch (e) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + e) } }, copy: function (e) { this.x = e.x; this.y = e.y; return this }, add: function (e, t) { if (t !== undefined) { console.warn("DEPRECATED: Vector2's .add() now only accepts one argument. Use .addVectors( a, b ) instead."); return this.addVectors(e, t) } this.x += e.x; this.y += e.y; return this }, addVectors: function (e, t) { this.x = e.x + t.x; this.y = e.y + t.y; return this }, addScalar: function (e) { this.x += e; this.y += e; return this }, sub: function (e, t) { if (t !== undefined) { console.warn("DEPRECATED: Vector2's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."); return this.subVectors(e, t) } this.x -= e.x; this.y -= e.y; return this }, subVectors: function (e, t) { this.x = e.x - t.x; this.y = e.y - t.y; return this }, multiplyScalar: function (e) { this.x *= e; this.y *= e; return this }, divideScalar: function (e) { if (e !== 0) { var t = 1 / e; this.x *= t; this.y *= t } else { this.x = 0; this.y = 0 } return this }, min: function (e) { if (this.x > e.x) { this.x = e.x } if (this.y > e.y) { this.y = e.y } return this }, max: function (e) { if (this.x < e.x) { this.x = e.x } if (this.y < e.y) { this.y = e.y } return this }, clamp: function (e, t) { if (this.x < e.x) { this.x = e.x } else if (this.x > t.x) { this.x = t.x } if (this.y < e.y) { this.y = e.y } else if (this.y > t.y) { this.y = t.y } return this }, negate: function () { return this.multiplyScalar(-1) }, dot: function (e) { return this.x * e.x + this.y * e.y }, lengthSq: function () { return this.x * this.x + this.y * this.y }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y) }, normalize: function () { return this.divideScalar(this.length()) }, distanceTo: function (e) { return Math.sqrt(this.distanceToSquared(e)) }, distanceToSquared: function (e) { var t = this.x - e.x, n = this.y - e.y; return t * t + n * n }, setLength: function (e) { var t = this.length(); if (t !== 0 && e !== t) { this.multiplyScalar(e / t) } return this }, lerp: function (e, t) { this.x += (e.x - this.x) * t; this.y += (e.y - this.y) * t; return this }, equals: function (e) { return e.x === this.x && e.y === this.y }, fromArray: function (e) { this.x = e[0]; this.y = e[1]; return this }, toArray: function () { return [this.x, this.y] }, clone: function () { return new THREE.Vector2(this.x, this.y) } }; THREE.Vector3 = function (e, t, n) { this.x = e || 0; this.y = t || 0; this.z = n || 0 }; THREE.Vector3.prototype = { constructor: THREE.Vector3, set: function (e, t, n) { this.x = e; this.y = t; this.z = n; return this }, setX: function (e) { this.x = e; return this }, setY: function (e) { this.y = e; return this }, setZ: function (e) { this.z = e; return this }, setComponent: function (e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; default: throw new Error("index is out of range: " + e) } }, getComponent: function (e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + e) } }, copy: function (e) { this.x = e.x; this.y = e.y; this.z = e.z; return this }, add: function (e, t) { if (t !== undefined) { console.warn("DEPRECATED: Vector3's .add() now only accepts one argument. Use .addVectors( a, b ) instead."); return this.addVectors(e, t) } this.x += e.x; this.y += e.y; this.z += e.z; return this }, addScalar: function (e) { this.x += e; this.y += e; this.z += e; return this }, addVectors: function (e, t) { this.x = e.x + t.x; this.y = e.y + t.y; this.z = e.z + t.z; return this }, sub: function (e, t) { if (t !== undefined) { console.warn("DEPRECATED: Vector3's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."); return this.subVectors(e, t) } this.x -= e.x; this.y -= e.y; this.z -= e.z; return this }, subVectors: function (e, t) { this.x = e.x - t.x; this.y = e.y - t.y; this.z = e.z - t.z; return this }, multiply: function (e, t) { if (t !== undefined) { console.warn("DEPRECATED: Vector3's .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."); return this.multiplyVectors(e, t) } this.x *= e.x; this.y *= e.y; this.z *= e.z; return this }, multiplyScalar: function (e) { this.x *= e; this.y *= e; this.z *= e; return this }, multiplyVectors: function (e, t) { this.x = e.x * t.x; this.y = e.y * t.y; this.z = e.z * t.z; return this }, applyMatrix3: function (e) { var t = this.x; var n = this.y; var r = this.z; var i = e.elements; this.x = i[0] * t + i[3] * n + i[6] * r; this.y = i[1] * t + i[4] * n + i[7] * r; this.z = i[2] * t + i[5] * n + i[8] * r; return this }, applyMatrix4: function (e) { var t = this.x, n = this.y, r = this.z; var i = e.elements; this.x = i[0] * t + i[4] * n + i[8] * r + i[12]; this.y = i[1] * t + i[5] * n + i[9] * r + i[13]; this.z = i[2] * t + i[6] * n + i[10] * r + i[14]; return this }, applyProjection: function (e) { var t = this.x, n = this.y, r = this.z; var i = e.elements; var s = 1 / (i[3] * t + i[7] * n + i[11] * r + i[15]); this.x = (i[0] * t + i[4] * n + i[8] * r + i[12]) * s; this.y = (i[1] * t + i[5] * n + i[9] * r + i[13]) * s; this.z = (i[2] * t + i[6] * n + i[10] * r + i[14]) * s; return this }, applyQuaternion: function (e) { var t = this.x; var n = this.y; var r = this.z; var i = e.x; var s = e.y; var o = e.z; var u = e.w; var a = u * t + s * r - o * n; var f = u * n + o * t - i * r; var l = u * r + i * n - s * t; var c = -i * t - s * n - o * r; this.x = a * u + c * -i + f * -o - l * -s; this.y = f * u + c * -s + l * -i - a * -o; this.z = l * u + c * -o + a * -s - f * -i; return this }, transformDirection: function (e) { var t = this.x, n = this.y, r = this.z; var i = e.elements; this.x = i[0] * t + i[4] * n + i[8] * r; this.y = i[1] * t + i[5] * n + i[9] * r; this.z = i[2] * t + i[6] * n + i[10] * r; this.normalize(); return this }, divide: function (e) { this.x /= e.x; this.y /= e.y; this.z /= e.z; return this }, divideScalar: function (e) { if (e !== 0) { var t = 1 / e; this.x *= t; this.y *= t; this.z *= t } else { this.x = 0; this.y = 0; this.z = 0 } return this }, min: function (e) { if (this.x > e.x) { this.x = e.x } if (this.y > e.y) { this.y = e.y } if (this.z > e.z) { this.z = e.z } return this }, max: function (e) { if (this.x < e.x) { this.x = e.x } if (this.y < e.y) { this.y = e.y } if (this.z < e.z) { this.z = e.z } return this }, clamp: function (e, t) { if (this.x < e.x) { this.x = e.x } else if (this.x > t.x) { this.x = t.x } if (this.y < e.y) { this.y = e.y } else if (this.y > t.y) { this.y = t.y } if (this.z < e.z) { this.z = e.z } else if (this.z > t.z) { this.z = t.z } return this }, negate: function () { return this.multiplyScalar(-1) }, dot: function (e) { return this.x * e.x + this.y * e.y + this.z * e.z }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) }, lengthManhattan: function () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) }, normalize: function () { return this.divideScalar(this.length()) }, setLength: function (e) { var t = this.length(); if (t !== 0 && e !== t) { this.multiplyScalar(e / t) } return this }, lerp: function (e, t) { this.x += (e.x - this.x) * t; this.y += (e.y - this.y) * t; this.z += (e.z - this.z) * t; return this }, cross: function (e, t) { if (t !== undefined) { console.warn("DEPRECATED: Vector3's .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."); return this.crossVectors(e, t) } var n = this.x, r = this.y, i = this.z; this.x = r * e.z - i * e.y; this.y = i * e.x - n * e.z; this.z = n * e.y - r * e.x; return this }, crossVectors: function (e, t) { var n = e.x, r = e.y, i = e.z; var s = t.x, o = t.y, u = t.z; this.x = r * u - i * o; this.y = i * s - n * u; this.z = n * o - r * s; return this }, angleTo: function (e) { var t = this.dot(e) / (this.length() * e.length()); return Math.acos(THREE.Math.clamp(t, -1, 1)) }, distanceTo: function (e) { return Math.sqrt(this.distanceToSquared(e)) }, distanceToSquared: function (e) { var t = this.x - e.x; var n = this.y - e.y; var r = this.z - e.z; return t * t + n * n + r * r }, setEulerFromRotationMatrix: function (e, t) { console.error("REMOVED: Vector3's setEulerFromRotationMatrix has been removed in favor of Euler.setFromRotationMatrix(), please update your code.") }, setEulerFromQuaternion: function (e, t) { console.error("REMOVED: Vector3's setEulerFromQuaternion: has been removed in favor of Euler.setFromQuaternion(), please update your code.") }, getPositionFromMatrix: function (e) { this.x = e.elements[12]; this.y = e.elements[13]; this.z = e.elements[14]; return this }, getScaleFromMatrix: function (e) { var t = this.set(e.elements[0], e.elements[1], e.elements[2]).length(); var n = this.set(e.elements[4], e.elements[5], e.elements[6]).length(); var r = this.set(e.elements[8], e.elements[9], e.elements[10]).length(); this.x = t; this.y = n; this.z = r; return this }, getColumnFromMatrix: function (e, t) { var n = e * 4; var r = t.elements; this.x = r[n]; this.y = r[n + 1]; this.z = r[n + 2]; return this }, equals: function (e) { return e.x === this.x && e.y === this.y && e.z === this.z }, fromArray: function (e) { this.x = e[0]; this.y = e[1]; this.z = e[2]; return this }, toArray: function () { return [this.x, this.y, this.z] }, clone: function () { return new THREE.Vector3(this.x, this.y, this.z) } }; THREE.extend(THREE.Vector3.prototype, { applyEuler: function () { var e = new THREE.Quaternion; return function (t) { if (t instanceof THREE.Euler === false) { console.error("ERROR: Vector3's .applyEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.") } this.applyQuaternion(e.setFromEuler(t)); return this } }(), applyAxisAngle: function () { var e = new THREE.Quaternion; return function (t, n) { this.applyQuaternion(e.setFromAxisAngle(t, n)); return this } }(), projectOnVector: function () { var e = new THREE.Vector3; return function (t) { e.copy(t).normalize(); var n = this.dot(e); return this.copy(e).multiplyScalar(n) } }(), projectOnPlane: function () { var e = new THREE.Vector3; return function (t) { e.copy(this).projectOnVector(t); return this.sub(e) } }(), reflect: function () { var e = new THREE.Vector3; return function (t) { e.copy(this).projectOnVector(t).multiplyScalar(2); return this.subVectors(e, this) } }() }); THREE.Vector4 = function (e, t, n, r) { this.x = e || 0; this.y = t || 0; this.z = n || 0; this.w = r !== undefined ? r : 1 }; THREE.Vector4.prototype = { constructor: THREE.Vector4, set: function (e, t, n, r) { this.x = e; this.y = t; this.z = n; this.w = r; return this }, setX: function (e) { this.x = e; return this }, setY: function (e) { this.y = e; return this }, setZ: function (e) { this.z = e; return this }, setW: function (e) { this.w = e; return this }, setComponent: function (e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; case 3: this.w = t; break; default: throw new Error("index is out of range: " + e) } }, getComponent: function (e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + e) } }, copy: function (e) { this.x = e.x; this.y = e.y; this.z = e.z; this.w = e.w !== undefined ? e.w : 1; return this }, add: function (e, t) { if (t !== undefined) { console.warn("DEPRECATED: Vector4's .add() now only accepts one argument. Use .addVectors( a, b ) instead."); return this.addVectors(e, t) } this.x += e.x; this.y += e.y; this.z += e.z; this.w += e.w; return this }, addScalar: function (e) { this.x += e; this.y += e; this.z += e; this.w += e; return this }, addVectors: function (e, t) { this.x = e.x + t.x; this.y = e.y + t.y; this.z = e.z + t.z; this.w = e.w + t.w; return this }, sub: function (e, t) { if (t !== undefined) { console.warn("DEPRECATED: Vector4's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."); return this.subVectors(e, t) } this.x -= e.x; this.y -= e.y; this.z -= e.z; this.w -= e.w; return this }, subVectors: function (e, t) { this.x = e.x - t.x; this.y = e.y - t.y; this.z = e.z - t.z; this.w = e.w - t.w; return this }, multiplyScalar: function (e) { this.x *= e; this.y *= e; this.z *= e; this.w *= e; return this }, applyMatrix4: function (e) { var t = this.x; var n = this.y; var r = this.z; var i = this.w; var s = e.elements; this.x = s[0] * t + s[4] * n + s[8] * r + s[12] * i; this.y = s[1] * t + s[5] * n + s[9] * r + s[13] * i; this.z = s[2] * t + s[6] * n + s[10] * r + s[14] * i; this.w = s[3] * t + s[7] * n + s[11] * r + s[15] * i; return this }, divideScalar: function (e) { if (e !== 0) { var t = 1 / e; this.x *= t; this.y *= t; this.z *= t; this.w *= t } else { this.x = 0; this.y = 0; this.z = 0; this.w = 1 } return this }, setAxisAngleFromQuaternion: function (e) { this.w = 2 * Math.acos(e.w); var t = Math.sqrt(1 - e.w * e.w); if (t < 1e-4) { this.x = 1; this.y = 0; this.z = 0 } else { this.x = e.x / t; this.y = e.y / t; this.z = e.z / t } return this }, setAxisAngleFromRotationMatrix: function (e) { var t, n, r, i, s = .01, o = .1, u = e.elements, a = u[0], f = u[4], l = u[8], c = u[1], h = u[5], p = u[9], d = u[2], v = u[6], m = u[10]; if (Math.abs(f - c) < s && Math.abs(l - d) < s && Math.abs(p - v) < s) { if (Math.abs(f + c) < o && Math.abs(l + d) < o && Math.abs(p + v) < o && Math.abs(a + h + m - 3) < o) { this.set(1, 0, 0, 0); return this } t = Math.PI; var g = (a + 1) / 2; var y = (h + 1) / 2; var b = (m + 1) / 2; var w = (f + c) / 4; var E = (l + d) / 4; var S = (p + v) / 4; if (g > y && g > b) { if (g < s) { n = 0; r = .707106781; i = .707106781 } else { n = Math.sqrt(g); r = w / n; i = E / n } } else if (y > b) { if (y < s) { n = .707106781; r = 0; i = .707106781 } else { r = Math.sqrt(y); n = w / r; i = S / r } } else { if (b < s) { n = .707106781; r = .707106781; i = 0 } else { i = Math.sqrt(b); n = E / i; r = S / i } } this.set(n, r, i, t); return this } var x = Math.sqrt((v - p) * (v - p) + (l - d) * (l - d) + (c - f) * (c - f)); if (Math.abs(x) < .001) x = 1; this.x = (v - p) / x; this.y = (l - d) / x; this.z = (c - f) / x; this.w = Math.acos((a + h + m - 1) / 2); return this }, min: function (e) { if (this.x > e.x) { this.x = e.x } if (this.y > e.y) { this.y = e.y } if (this.z > e.z) { this.z = e.z } if (this.w > e.w) { this.w = e.w } return this }, max: function (e) { if (this.x < e.x) { this.x = e.x } if (this.y < e.y) { this.y = e.y } if (this.z < e.z) { this.z = e.z } if (this.w < e.w) { this.w = e.w } return this }, clamp: function (e, t) { if (this.x < e.x) { this.x = e.x } else if (this.x > t.x) { this.x = t.x } if (this.y < e.y) { this.y = e.y } else if (this.y > t.y) { this.y = t.y } if (this.z < e.z) { this.z = e.z } else if (this.z > t.z) { this.z = t.z } if (this.w < e.w) { this.w = e.w } else if (this.w > t.w) { this.w = t.w } return this }, negate: function () { return this.multiplyScalar(-1) }, dot: function (e) { return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) }, lengthManhattan: function () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) }, normalize: function () { return this.divideScalar(this.length()) }, setLength: function (e) { var t = this.length(); if (t !== 0 && e !== t) { this.multiplyScalar(e / t) } return this }, lerp: function (e, t) { this.x += (e.x - this.x) * t; this.y += (e.y - this.y) * t; this.z += (e.z - this.z) * t; this.w += (e.w - this.w) * t; return this }, equals: function (e) { return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w }, fromArray: function (e) { this.x = e[0]; this.y = e[1]; this.z = e[2]; this.w = e[3]; return this }, toArray: function () { return [this.x, this.y, this.z, this.w] }, clone: function () { return new THREE.Vector4(this.x, this.y, this.z, this.w) } }; THREE.Euler = function (e, t, n, r) { this._x = e || 0; this._y = t || 0; this._z = n || 0; this._order = r || THREE.Euler.DefaultOrder }; THREE.Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]; THREE.Euler.DefaultOrder = "XYZ"; THREE.Euler.prototype = { constructor: THREE.Euler, _x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder, _quaternion: undefined, _updateQuaternion: function () { if (this._quaternion !== undefined) { this._quaternion.setFromEuler(this, false) } }, get x() { return this._x }, set x(e) { this._x = e; this._updateQuaternion() }, get y() { return this._y }, set y(e) { this._y = e; this._updateQuaternion() }, get z() { return this._z }, set z(e) { this._z = e; this._updateQuaternion() }, get order() { return this._order }, set order(e) { this._order = e; this._updateQuaternion() }, set: function (e, t, n, r) { this._x = e; this._y = t; this._z = n; this._order = r || this._order; this._updateQuaternion(); return this }, copy: function (e) { this._x = e._x; this._y = e._y; this._z = e._z; this._order = e._order; this._updateQuaternion(); return this }, setFromRotationMatrix: function (e, t) { function n(e) { return Math.min(Math.max(e, -1), 1) } var r = e.elements; var i = r[0], s = r[4], o = r[8]; var u = r[1], a = r[5], f = r[9]; var l = r[2], c = r[6], h = r[10]; t = t || this._order; if (t === "XYZ") { this._y = Math.asin(n(o)); if (Math.abs(o) < .99999) { this._x = Math.atan2(-f, h); this._z = Math.atan2(-s, i) } else { this._x = Math.atan2(c, a); this._z = 0 } } else if (t === "YXZ") { this._x = Math.asin(-n(f)); if (Math.abs(f) < .99999) { this._y = Math.atan2(o, h); this._z = Math.atan2(u, a) } else { this._y = Math.atan2(-l, i); this._z = 0 } } else if (t === "ZXY") { this._x = Math.asin(n(c)); if (Math.abs(c) < .99999) { this._y = Math.atan2(-l, h); this._z = Math.atan2(-s, a) } else { this._y = 0; this._z = Math.atan2(u, i) } } else if (t === "ZYX") { this._y = Math.asin(-n(l)); if (Math.abs(l) < .99999) { this._x = Math.atan2(c, h); this._z = Math.atan2(u, i) } else { this._x = 0; this._z = Math.atan2(-s, a) } } else if (t === "YZX") { this._z = Math.asin(n(u)); if (Math.abs(u) < .99999) { this._x = Math.atan2(-f, a); this._y = Math.atan2(-l, i) } else { this._x = 0; this._y = Math.atan2(o, h) } } else if (t === "XZY") { this._z = Math.asin(-n(s)); if (Math.abs(s) < .99999) { this._x = Math.atan2(c, a); this._y = Math.atan2(o, i) } else { this._x = Math.atan2(-f, h); this._y = 0 } } else { console.warn("WARNING: Euler.setFromRotationMatrix() given unsupported order: " + t) } this._order = t; this._updateQuaternion(); return this }, setFromQuaternion: function (e, t, n) { function r(e) { return Math.min(Math.max(e, -1), 1) } var i = e.x * e.x; var s = e.y * e.y; var o = e.z * e.z; var u = e.w * e.w; t = t || this._order; if (t === "XYZ") { this._x = Math.atan2(2 * (e.x * e.w - e.y * e.z), u - i - s + o); this._y = Math.asin(r(2 * (e.x * e.z + e.y * e.w))); this._z = Math.atan2(2 * (e.z * e.w - e.x * e.y), u + i - s - o) } else if (t === "YXZ") { this._x = Math.asin(r(2 * (e.x * e.w - e.y * e.z))); this._y = Math.atan2(2 * (e.x * e.z + e.y * e.w), u - i - s + o); this._z = Math.atan2(2 * (e.x * e.y + e.z * e.w), u - i + s - o) } else if (t === "ZXY") { this._x = Math.asin(r(2 * (e.x * e.w + e.y * e.z))); this._y = Math.atan2(2 * (e.y * e.w - e.z * e.x), u - i - s + o); this._z = Math.atan2(2 * (e.z * e.w - e.x * e.y), u - i + s - o) } else if (t === "ZYX") { this._x = Math.atan2(2 * (e.x * e.w + e.z * e.y), u - i - s + o); this._y = Math.asin(r(2 * (e.y * e.w - e.x * e.z))); this._z = Math.atan2(2 * (e.x * e.y + e.z * e.w), u + i - s - o) } else if (t === "YZX") { this._x = Math.atan2(2 * (e.x * e.w - e.z * e.y), u - i + s - o); this._y = Math.atan2(2 * (e.y * e.w - e.x * e.z), u + i - s - o); this._z = Math.asin(r(2 * (e.x * e.y + e.z * e.w))) } else if (t === "XZY") { this._x = Math.atan2(2 * (e.x * e.w + e.y * e.z), u - i + s - o); this._y = Math.atan2(2 * (e.x * e.z + e.y * e.w), u + i - s - o); this._z = Math.asin(r(2 * (e.z * e.w - e.x * e.y))) } else { console.warn("WARNING: Euler.setFromQuaternion() given unsupported order: " + t) } this._order = t; if (n !== false) this._updateQuaternion(); return this }, reorder: function () { var e = new THREE.Quaternion; return function (t) { e.setFromEuler(this); this.setFromQuaternion(e, t) } }(), fromArray: function (e) { this._x = e[0]; this._y = e[1]; this._z = e[2]; if (e[3] !== undefined) this._order = e[3]; this._updateQuaternion(); return this }, toArray: function () { return [this._x, this._y, this._z, this._order] }, equals: function (e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order }, clone: function () { return new THREE.Euler(this._x, this._y, this._z, this._order) } }; THREE.Box3 = function (e, t) { this.min = e !== undefined ? e : new THREE.Vector3(Infinity, Infinity, Infinity); this.max = t !== undefined ? t : new THREE.Vector3(-Infinity, -Infinity, -Infinity) }; THREE.Box3.prototype = { constructor: THREE.Box3, set: function (e, t) { this.min.copy(e); this.max.copy(t); return this }, addPoint: function (e) { if (e.x < this.min.x) { this.min.x = e.x } else if (e.x > this.max.x) { this.max.x = e.x } if (e.y < this.min.y) { this.min.y = e.y } else if (e.y > this.max.y) { this.max.y = e.y } if (e.z < this.min.z) { this.min.z = e.z } else if (e.z > this.max.z) { this.max.z = e.z } }, setFromPoints: function (e) { if (e.length > 0) { var t = e[0]; this.min.copy(t); this.max.copy(t); for (var n = 1, r = e.length; n < r; n++) { this.addPoint(e[n]) } } else { this.makeEmpty() } return this }, setFromCenterAndSize: function () { var e = new THREE.Vector3; return function (t, n) { var r = e.copy(n).multiplyScalar(.5); this.min.copy(t).sub(r); this.max.copy(t).add(r); return this } }(), setFromObject: function () { var e = new THREE.Vector3; return function (t) { var n = this; t.updateMatrixWorld(true); this.makeEmpty(); t.traverse(function (t) { if (t.geometry !== undefined && t.geometry.vertices !== undefined) { var r = t.geometry.vertices; for (var i = 0, s = r.length; i < s; i++) { e.copy(r[i]); e.applyMatrix4(t.matrixWorld); n.expandByPoint(e) } } }); return this } }(), copy: function (e) { this.min.copy(e.min); this.max.copy(e.max); return this }, makeEmpty: function () { this.min.x = this.min.y = this.min.z = Infinity; this.max.x = this.max.y = this.max.z = -Infinity; return this }, empty: function () { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z }, center: function (e) { var t = e || new THREE.Vector3; return t.addVectors(this.min, this.max).multiplyScalar(.5) }, size: function (e) { var t = e || new THREE.Vector3; return t.subVectors(this.max, this.min) }, expandByPoint: function (e) { this.min.min(e); this.max.max(e); return this }, expandByVector: function (e) { this.min.sub(e); this.max.add(e); return this }, expandByScalar: function (e) { this.min.addScalar(-e); this.max.addScalar(e); return this }, containsPoint: function (e) { if (e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z) { return false } return true }, containsBox: function (e) { if (this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z) { return true } return false }, getParameter: function (e) { return new THREE.Vector3((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z)) }, isIntersectionBox: function (e) { if (e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z) { return false } return true }, clampPoint: function (e, t) { var n = t || new THREE.Vector3; return n.copy(e).clamp(this.min, this.max) }, distanceToPoint: function () { var e = new THREE.Vector3; return function (t) { var n = e.copy(t).clamp(this.min, this.max); return n.sub(t).length() } }(), getBoundingSphere: function () { var e = new THREE.Vector3; return function (t) { var n = t || new THREE.Sphere; n.center = this.center(); n.radius = this.size(e).length() * .5; return n } }(), intersect: function (e) { this.min.max(e.min); this.max.min(e.max); return this }, union: function (e) { this.min.min(e.min); this.max.max(e.max); return this }, applyMatrix4: function () { var e = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3]; return function (t) { e[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t); e[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t); e[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t); e[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t); e[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t); e[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t); e[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t); e[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t); this.makeEmpty(); this.setFromPoints(e); return this } }(), translate: function (e) { this.min.add(e); this.max.add(e); return this }, equals: function (e) { return e.min.equals(this.min) && e.max.equals(this.max) }, clone: function () { return (new THREE.Box3).copy(this) } }; THREE.Matrix3 = function (e, t, n, r, i, s, o, u, a) { this.elements = new Float32Array(9); this.set(e !== undefined ? e : 1, t || 0, n || 0, r || 0, i !== undefined ? i : 1, s || 0, o || 0, u || 0, a !== undefined ? a : 1) }; THREE.Matrix3.prototype = { constructor: THREE.Matrix3, set: function (e, t, n, r, i, s, o, u, a) { var f = this.elements; f[0] = e; f[3] = t; f[6] = n; f[1] = r; f[4] = i; f[7] = s; f[2] = o; f[5] = u; f[8] = a; return this }, identity: function () { this.set(1, 0, 0, 0, 1, 0, 0, 0, 1); return this }, copy: function (e) { var t = e.elements; this.set(t[0], t[3], t[6], t[1], t[4], t[7], t[2], t[5], t[8]); return this }, multiplyVector3: function (e) { console.warn("DEPRECATED: Matrix3's .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."); return e.applyMatrix3(this) }, multiplyVector3Array: function () { var e = new THREE.Vector3; return function (t) { for (var n = 0, r = t.length; n < r; n += 3) { e.x = t[n]; e.y = t[n + 1]; e.z = t[n + 2]; e.applyMatrix3(this); t[n] = e.x; t[n + 1] = e.y; t[n + 2] = e.z } return t } }(), multiplyScalar: function (e) { var t = this.elements; t[0] *= e; t[3] *= e; t[6] *= e; t[1] *= e; t[4] *= e; t[7] *= e; t[2] *= e; t[5] *= e; t[8] *= e; return this }, determinant: function () { var e = this.elements; var t = e[0], n = e[1], r = e[2], i = e[3], s = e[4], o = e[5], u = e[6], a = e[7], f = e[8]; return t * s * f - t * o * a - n * i * f + n * o * u + r * i * a - r * s * u }, getInverse: function (e, t) { var n = e.elements; var r = this.elements; r[0] = n[10] * n[5] - n[6] * n[9]; r[1] = -n[10] * n[1] + n[2] * n[9]; r[2] = n[6] * n[1] - n[2] * n[5]; r[3] = -n[10] * n[4] + n[6] * n[8]; r[4] = n[10] * n[0] - n[2] * n[8]; r[5] = -n[6] * n[0] + n[2] * n[4]; r[6] = n[9] * n[4] - n[5] * n[8]; r[7] = -n[9] * n[0] + n[1] * n[8]; r[8] = n[5] * n[0] - n[1] * n[4]; var i = n[0] * r[0] + n[1] * r[3] + n[2] * r[6]; if (i === 0) { var s = "Matrix3.getInverse(): can't invert matrix, determinant is 0"; if (t || false) { throw new Error(s) } else { console.warn(s) } this.identity(); return this } this.multiplyScalar(1 / i); return this }, transpose: function () { var e, t = this.elements; e = t[1]; t[1] = t[3]; t[3] = e; e = t[2]; t[2] = t[6]; t[6] = e; e = t[5]; t[5] = t[7]; t[7] = e; return this }, getNormalMatrix: function (e) { this.getInverse(e).transpose(); return this }, transposeIntoArray: function (e) { var t = this.elements; e[0] = t[0]; e[1] = t[3]; e[2] = t[6]; e[3] = t[1]; e[4] = t[4]; e[5] = t[7]; e[6] = t[2]; e[7] = t[5]; e[8] = t[8]; return this }, clone: function () { var e = this.elements; return new THREE.Matrix3(e[0], e[3], e[6], e[1], e[4], e[7], e[2], e[5], e[8]) } }; THREE.Matrix4 = function (e, t, n, r, i, s, o, u, a, f, l, c, h, p, d, v) { this.elements = new Float32Array(16); var m = this.elements; m[0] = e !== undefined ? e : 1; m[4] = t || 0; m[8] = n || 0; m[12] = r || 0; m[1] = i || 0; m[5] = s !== undefined ? s : 1; m[9] = o || 0; m[13] = u || 0; m[2] = a || 0; m[6] = f || 0; m[10] = l !== undefined ? l : 1; m[14] = c || 0; m[3] = h || 0; m[7] = p || 0; m[11] = d || 0; m[15] = v !== undefined ? v : 1 }; THREE.Matrix4.prototype = { constructor: THREE.Matrix4, set: function (e, t, n, r, i, s, o, u, a, f, l, c, h, p, d, v) { var m = this.elements; m[0] = e; m[4] = t; m[8] = n; m[12] = r; m[1] = i; m[5] = s; m[9] = o; m[13] = u; m[2] = a; m[6] = f; m[10] = l; m[14] = c; m[3] = h; m[7] = p; m[11] = d; m[15] = v; return this }, identity: function () { this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); return this }, copy: function (e) { this.elements.set(e.elements); return this }, extractPosition: function (e) { console.warn("DEPRECATED: Matrix4's .extractPosition() has been renamed to .copyPosition()."); return this.copyPosition(e) }, copyPosition: function (e) { var t = this.elements; var n = e.elements; t[12] = n[12]; t[13] = n[13]; t[14] = n[14]; return this }, extractRotation: function () { var e = new THREE.Vector3; return function (t) { var n = this.elements; var r = t.elements; var i = 1 / e.set(r[0], r[1], r[2]).length(); var s = 1 / e.set(r[4], r[5], r[6]).length(); var o = 1 / e.set(r[8], r[9], r[10]).length(); n[0] = r[0] * i; n[1] = r[1] * i; n[2] = r[2] * i; n[4] = r[4] * s; n[5] = r[5] * s; n[6] = r[6] * s; n[8] = r[8] * o; n[9] = r[9] * o; n[10] = r[10] * o; return this } }(), makeRotationFromEuler: function (e) { if (e instanceof THREE.Euler === false) { console.error("ERROR: Matrix's .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.") } var t = this.elements; var n = e.x, r = e.y, i = e.z; var s = Math.cos(n), o = Math.sin(n); var u = Math.cos(r), a = Math.sin(r); var f = Math.cos(i), l = Math.sin(i); if (e.order === "XYZ") { var c = s * f, h = s * l, p = o * f, d = o * l; t[0] = u * f; t[4] = -u * l; t[8] = a; t[1] = h + p * a; t[5] = c - d * a; t[9] = -o * u; t[2] = d - c * a; t[6] = p + h * a; t[10] = s * u } else if (e.order === "YXZ") { var v = u * f, m = u * l, g = a * f, y = a * l; t[0] = v + y * o; t[4] = g * o - m; t[8] = s * a; t[1] = s * l; t[5] = s * f; t[9] = -o; t[2] = m * o - g; t[6] = y + v * o; t[10] = s * u } else if (e.order === "ZXY") { var v = u * f, m = u * l, g = a * f, y = a * l; t[0] = v - y * o; t[4] = -s * l; t[8] = g + m * o; t[1] = m + g * o; t[5] = s * f; t[9] = y - v * o; t[2] = -s * a; t[6] = o; t[10] = s * u } else if (e.order === "ZYX") { var c = s * f, h = s * l, p = o * f, d = o * l; t[0] = u * f; t[4] = p * a - h; t[8] = c * a + d; t[1] = u * l; t[5] = d * a + c; t[9] = h * a - p; t[2] = -a; t[6] = o * u; t[10] = s * u } else if (e.order === "YZX") { var b = s * u, w = s * a, E = o * u, S = o * a; t[0] = u * f; t[4] = S - b * l; t[8] = E * l + w; t[1] = l; t[5] = s * f; t[9] = -o * f; t[2] = -a * f; t[6] = w * l + E; t[10] = b - S * l } else if (e.order === "XZY") { var b = s * u, w = s * a, E = o * u, S = o * a; t[0] = u * f; t[4] = -l; t[8] = a * f; t[1] = b * l + S; t[5] = s * f; t[9] = w * l - E; t[2] = E * l - w; t[6] = o * f; t[10] = S * l + b } t[3] = 0; t[7] = 0; t[11] = 0; t[12] = 0; t[13] = 0; t[14] = 0; t[15] = 1; return this }, setRotationFromQuaternion: function (e) { console.warn("DEPRECATED: Matrix4's .setRotationFromQuaternion() has been deprecated in favor of makeRotationFromQuaternion.  Please update your code."); return this.makeRotationFromQuaternion(e) }, makeRotationFromQuaternion: function (e) { var t = this.elements; var n = e.x, r = e.y, i = e.z, s = e.w; var o = n + n, u = r + r, a = i + i; var f = n * o, l = n * u, c = n * a; var h = r * u, p = r * a, d = i * a; var v = s * o, m = s * u, g = s * a; t[0] = 1 - (h + d); t[4] = l - g; t[8] = c + m; t[1] = l + g; t[5] = 1 - (f + d); t[9] = p - v; t[2] = c - m; t[6] = p + v; t[10] = 1 - (f + h); t[3] = 0; t[7] = 0; t[11] = 0; t[12] = 0; t[13] = 0; t[14] = 0; t[15] = 1; return this }, lookAt: function () { var e = new THREE.Vector3; var t = new THREE.Vector3; var n = new THREE.Vector3; return function (r, i, s) { var o = this.elements; n.subVectors(r, i).normalize(); if (n.length() === 0) { n.z = 1 } e.crossVectors(s, n).normalize(); if (e.length() === 0) { n.x += 1e-4; e.crossVectors(s, n).normalize() } t.crossVectors(n, e); o[0] = e.x; o[4] = t.x; o[8] = n.x; o[1] = e.y; o[5] = t.y; o[9] = n.y; o[2] = e.z; o[6] = t.z; o[10] = n.z; return this } }(), multiply: function (e, t) { if (t !== undefined) { console.warn("DEPRECATED: Matrix4's .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."); return this.multiplyMatrices(e, t) } return this.multiplyMatrices(this, e) }, multiplyMatrices: function (e, t) { var n = e.elements; var r = t.elements; var i = this.elements; var s = n[0], o = n[4], u = n[8], a = n[12]; var f = n[1], l = n[5], c = n[9], h = n[13]; var p = n[2], d = n[6], v = n[10], m = n[14]; var g = n[3], y = n[7], b = n[11], w = n[15]; var E = r[0], S = r[4], x = r[8], T = r[12]; var N = r[1], C = r[5], k = r[9], L = r[13]; var A = r[2], O = r[6], M = r[10], _ = r[14]; var D = r[3], P = r[7], H = r[11], B = r[15]; i[0] = s * E + o * N + u * A + a * D; i[4] = s * S + o * C + u * O + a * P; i[8] = s * x + o * k + u * M + a * H; i[12] = s * T + o * L + u * _ + a * B; i[1] = f * E + l * N + c * A + h * D; i[5] = f * S + l * C + c * O + h * P; i[9] = f * x + l * k + c * M + h * H; i[13] = f * T + l * L + c * _ + h * B; i[2] = p * E + d * N + v * A + m * D; i[6] = p * S + d * C + v * O + m * P; i[10] = p * x + d * k + v * M + m * H; i[14] = p * T + d * L + v * _ + m * B; i[3] = g * E + y * N + b * A + w * D; i[7] = g * S + y * C + b * O + w * P; i[11] = g * x + y * k + b * M + w * H; i[15] = g * T + y * L + b * _ + w * B; return this }, multiplyToArray: function (e, t, n) { var r = this.elements; this.multiplyMatrices(e, t); n[0] = r[0]; n[1] = r[1]; n[2] = r[2]; n[3] = r[3]; n[4] = r[4]; n[5] = r[5]; n[6] = r[6]; n[7] = r[7]; n[8] = r[8]; n[9] = r[9]; n[10] = r[10]; n[11] = r[11]; n[12] = r[12]; n[13] = r[13]; n[14] = r[14]; n[15] = r[15]; return this }, multiplyScalar: function (e) { var t = this.elements; t[0] *= e; t[4] *= e; t[8] *= e; t[12] *= e; t[1] *= e; t[5] *= e; t[9] *= e; t[13] *= e; t[2] *= e; t[6] *= e; t[10] *= e; t[14] *= e; t[3] *= e; t[7] *= e; t[11] *= e; t[15] *= e; return this }, multiplyVector3: function (e) { console.warn("DEPRECATED: Matrix4's .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead."); return e.applyProjection(this) }, multiplyVector4: function (e) { console.warn("DEPRECATED: Matrix4's .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."); return e.applyMatrix4(this) }, multiplyVector3Array: function () { var e = new THREE.Vector3; return function (t) { for (var n = 0, r = t.length; n < r; n += 3) { e.x = t[n]; e.y = t[n + 1]; e.z = t[n + 2]; e.applyProjection(this); t[n] = e.x; t[n + 1] = e.y; t[n + 2] = e.z } return t } }(), rotateAxis: function (e) { console.warn("DEPRECATED: Matrix4's .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."); e.transformDirection(this) }, crossVector: function (e) { console.warn("DEPRECATED: Matrix4's .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."); return e.applyMatrix4(this) }, determinant: function () { var e = this.elements; var t = e[0], n = e[4], r = e[8], i = e[12]; var s = e[1], o = e[5], u = e[9], a = e[13]; var f = e[2], l = e[6], c = e[10], h = e[14]; var p = e[3], d = e[7], v = e[11], m = e[15]; return p * (+i * u * l - r * a * l - i * o * c + n * a * c + r * o * h - n * u * h) + d * (+t * u * h - t * a * c + i * s * c - r * s * h + r * a * f - i * u * f) + v * (+t * a * l - t * o * h - i * s * l + n * s * h + i * o * f - n * a * f) + m * (-r * o * f - t * u * l + t * o * c + r * s * l - n * s * c + n * u * f) }, transpose: function () { var e = this.elements; var t; t = e[1]; e[1] = e[4]; e[4] = t; t = e[2]; e[2] = e[8]; e[8] = t; t = e[6]; e[6] = e[9]; e[9] = t; t = e[3]; e[3] = e[12]; e[12] = t; t = e[7]; e[7] = e[13]; e[13] = t; t = e[11]; e[11] = e[14]; e[14] = t; return this }, flattenToArray: function (e) { var t = this.elements; e[0] = t[0]; e[1] = t[1]; e[2] = t[2]; e[3] = t[3]; e[4] = t[4]; e[5] = t[5]; e[6] = t[6]; e[7] = t[7]; e[8] = t[8]; e[9] = t[9]; e[10] = t[10]; e[11] = t[11]; e[12] = t[12]; e[13] = t[13]; e[14] = t[14]; e[15] = t[15]; return e }, flattenToArrayOffset: function (e, t) { var n = this.elements; e[t] = n[0]; e[t + 1] = n[1]; e[t + 2] = n[2]; e[t + 3] = n[3]; e[t + 4] = n[4]; e[t + 5] = n[5]; e[t + 6] = n[6]; e[t + 7] = n[7]; e[t + 8] = n[8]; e[t + 9] = n[9]; e[t + 10] = n[10]; e[t + 11] = n[11]; e[t + 12] = n[12]; e[t + 13] = n[13]; e[t + 14] = n[14]; e[t + 15] = n[15]; return e }, getPosition: function () { var e = new THREE.Vector3; return function () { console.warn("DEPRECATED: Matrix4's .getPosition() has been removed. Use Vector3.getPositionFromMatrix( matrix ) instead."); var t = this.elements; return e.set(t[12], t[13], t[14]) } }(), setPosition: function (e) { var t = this.elements; t[12] = e.x; t[13] = e.y; t[14] = e.z; return this }, getInverse: function (e, t) { var n = this.elements; var r = e.elements; var i = r[0], s = r[4], o = r[8], u = r[12]; var a = r[1], f = r[5], l = r[9], c = r[13]; var h = r[2], p = r[6], d = r[10], v = r[14]; var m = r[3], g = r[7], y = r[11], b = r[15]; n[0] = l * v * g - c * d * g + c * p * y - f * v * y - l * p * b + f * d * b; n[4] = u * d * g - o * v * g - u * p * y + s * v * y + o * p * b - s * d * b; n[8] = o * c * g - u * l * g + u * f * y - s * c * y - o * f * b + s * l * b; n[12] = u * l * p - o * c * p - u * f * d + s * c * d + o * f * v - s * l * v; n[1] = c * d * m - l * v * m - c * h * y + a * v * y + l * h * b - a * d * b; n[5] = o * v * m - u * d * m + u * h * y - i * v * y - o * h * b + i * d * b; n[9] = u * l * m - o * c * m - u * a * y + i * c * y + o * a * b - i * l * b; n[13] = o * c * h - u * l * h + u * a * d - i * c * d - o * a * v + i * l * v; n[2] = f * v * m - c * p * m + c * h * g - a * v * g - f * h * b + a * p * b; n[6] = u * p * m - s * v * m - u * h * g + i * v * g + s * h * b - i * p * b; n[10] = s * c * m - u * f * m + u * a * g - i * c * g - s * a * b + i * f * b; n[14] = u * f * h - s * c * h - u * a * p + i * c * p + s * a * v - i * f * v; n[3] = l * p * m - f * d * m - l * h * g + a * d * g + f * h * y - a * p * y; n[7] = s * d * m - o * p * m + o * h * g - i * d * g - s * h * y + i * p * y; n[11] = o * f * m - s * l * m - o * a * g + i * l * g + s * a * y - i * f * y; n[15] = s * l * h - o * f * h + o * a * p - i * l * p - s * a * d + i * f * d; var w = i * n[0] + a * n[4] + h * n[8] + m * n[12]; if (w == 0) { var E = "Matrix4.getInverse(): can't invert matrix, determinant is 0"; if (t || false) { throw new Error(E) } else { console.warn(E) } this.identity(); return this } this.multiplyScalar(1 / w); return this }, translate: function (e) { console.warn("DEPRECATED: Matrix4's .translate() has been removed.") }, rotateX: function (e) { console.warn("DEPRECATED: Matrix4's .rotateX() has been removed.") }, rotateY: function (e) { console.warn("DEPRECATED: Matrix4's .rotateY() has been removed.") }, rotateZ: function (e) { console.warn("DEPRECATED: Matrix4's .rotateZ() has been removed.") }, rotateByAxis: function (e, t) { console.warn("DEPRECATED: Matrix4's .rotateByAxis() has been removed.") }, scale: function (e) { var t = this.elements; var n = e.x, r = e.y, i = e.z; t[0] *= n; t[4] *= r; t[8] *= i; t[1] *= n; t[5] *= r; t[9] *= i; t[2] *= n; t[6] *= r; t[10] *= i; t[3] *= n; t[7] *= r; t[11] *= i; return this }, getMaxScaleOnAxis: function () { var e = this.elements; var t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]; var n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]; var r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10]; return Math.sqrt(Math.max(t, Math.max(n, r))) }, makeTranslation: function (e, t, n) { this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1); return this }, makeRotationX: function (e) { var t = Math.cos(e), n = Math.sin(e); this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1); return this }, makeRotationY: function (e) { var t = Math.cos(e), n = Math.sin(e); this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1); return this }, makeRotationZ: function (e) { var t = Math.cos(e), n = Math.sin(e); this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); return this }, makeRotationAxis: function (e, t) { var n = Math.cos(t); var r = Math.sin(t); var i = 1 - n; var s = e.x, o = e.y, u = e.z; var a = i * s, f = i * o; this.set(a * s + n, a * o - r * u, a * u + r * o, 0, a * o + r * u, f * o + n, f * u - r * s, 0, a * u - r * o, f * u + r * s, i * u * u + n, 0, 0, 0, 0, 1); return this }, makeScale: function (e, t, n) { this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1); return this }, compose: function (e, t, n) { this.makeRotationFromQuaternion(t); this.scale(n); this.setPosition(e); return this }, decompose: function () { var e = new THREE.Vector3; var t = new THREE.Matrix4; return function (n, r, i) { var s = this.elements; var o = e.set(s[0], s[1], s[2]).length(); var u = e.set(s[4], s[5], s[6]).length(); var a = e.set(s[8], s[9], s[10]).length(); n.x = s[12]; n.y = s[13]; n.z = s[14]; t.elements.set(this.elements); var f = 1 / o; var l = 1 / u; var c = 1 / a; t.elements[0] *= f; t.elements[1] *= f; t.elements[2] *= f; t.elements[4] *= l; t.elements[5] *= l; t.elements[6] *= l; t.elements[8] *= c; t.elements[9] *= c; t.elements[10] *= c; r.setFromRotationMatrix(t); i.x = o; i.y = u; i.z = a; return this } }(), makeFrustum: function (e, t, n, r, i, s) { var o = this.elements; var u = 2 * i / (t - e); var a = 2 * i / (r - n); var f = (t + e) / (t - e); var l = (r + n) / (r - n); var c = -(s + i) / (s - i); var h = -2 * s * i / (s - i); o[0] = u; o[4] = 0; o[8] = f; o[12] = 0; o[1] = 0; o[5] = a; o[9] = l; o[13] = 0; o[2] = 0; o[6] = 0; o[10] = c; o[14] = h; o[3] = 0; o[7] = 0; o[11] = -1; o[15] = 0; return this }, makePerspective: function (e, t, n, r) { var i = n * Math.tan(THREE.Math.degToRad(e * .5)); var s = -i; var o = s * t; var u = i * t; return this.makeFrustum(o, u, s, i, n, r) }, makeOrthographic: function (e, t, n, r, i, s) { var o = this.elements; var u = t - e; var a = n - r; var f = s - i; var l = (t + e) / u; var c = (n + r) / a; var h = (s + i) / f; o[0] = 2 / u; o[4] = 0; o[8] = 0; o[12] = -l; o[1] = 0; o[5] = 2 / a; o[9] = 0; o[13] = -c; o[2] = 0; o[6] = 0; o[10] = -2 / f; o[14] = -h; o[3] = 0; o[7] = 0; o[11] = 0; o[15] = 1; return this }, fromArray: function (e) { this.elements.set(e); return this }, toArray: function () { var e = this.elements; return [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]] }, clone: function () { var e = this.elements; return new THREE.Matrix4(e[0], e[4], e[8], e[12], e[1], e[5], e[9], e[13], e[2], e[6], e[10], e[14], e[3], e[7], e[11], e[15]) } }; THREE.Sphere = function (e, t) { this.center = e !== undefined ? e : new THREE.Vector3; this.radius = t !== undefined ? t : 0 }; THREE.Sphere.prototype = { constructor: THREE.Sphere, set: function (e, t) { this.center.copy(e); this.radius = t; return this }, setFromPoints: function () { var e = new THREE.Box3; return function (t, n) { var r = this.center; if (n !== undefined) { r.copy(n) } else { e.setFromPoints(t).center(r) } var i = 0; for (var s = 0, o = t.length; s < o; s++) { i = Math.max(i, r.distanceToSquared(t[s])) } this.radius = Math.sqrt(i); return this } }(), copy: function (e) { this.center.copy(e.center); this.radius = e.radius; return this }, empty: function () { return this.radius <= 0 }, containsPoint: function (e) { return e.distanceToSquared(this.center) <= this.radius * this.radius }, distanceToPoint: function (e) { return e.distanceTo(this.center) - this.radius }, intersectsSphere: function (e) { var t = this.radius + e.radius; return e.center.distanceToSquared(this.center) <= t * t }, clampPoint: function (e, t) { var n = this.center.distanceToSquared(e); var r = t || new THREE.Vector3; r.copy(e); if (n > this.radius * this.radius) { r.sub(this.center).normalize(); r.multiplyScalar(this.radius).add(this.center) } return r }, getBoundingBox: function (e) { var t = e || new THREE.Box3; t.set(this.center, this.center); t.expandByScalar(this.radius); return t }, applyMatrix4: function (e) { this.center.applyMatrix4(e); this.radius = this.radius * e.getMaxScaleOnAxis(); return this }, translate: function (e) { this.center.add(e); return this }, equals: function (e) { return e.center.equals(this.center) && e.radius === this.radius }, clone: function () { return (new THREE.Sphere).copy(this) } }; THREE.Frustum = function (e, t, n, r, i, s) { this.planes = [e !== undefined ? e : new THREE.Plane, t !== undefined ? t : new THREE.Plane, n !== undefined ? n : new THREE.Plane, r !== undefined ? r : new THREE.Plane, i !== undefined ? i : new THREE.Plane, s !== undefined ? s : new THREE.Plane] }; THREE.Frustum.prototype = { constructor: THREE.Frustum, set: function (e, t, n, r, i, s) { var o = this.planes; o[0].copy(e); o[1].copy(t); o[2].copy(n); o[3].copy(r); o[4].copy(i); o[5].copy(s); return this }, copy: function (e) { var t = this.planes; for (var n = 0; n < 6; n++) { t[n].copy(e.planes[n]) } return this }, setFromMatrix: function (e) { var t = this.planes; var n = e.elements; var r = n[0], i = n[1], s = n[2], o = n[3]; var u = n[4], a = n[5], f = n[6], l = n[7]; var c = n[8], h = n[9], p = n[10], d = n[11]; var v = n[12], m = n[13], g = n[14], y = n[15]; t[0].setComponents(o - r, l - u, d - c, y - v).normalize(); t[1].setComponents(o + r, l + u, d + c, y + v).normalize(); t[2].setComponents(o + i, l + a, d + h, y + m).normalize(); t[3].setComponents(o - i, l - a, d - h, y - m).normalize(); t[4].setComponents(o - s, l - f, d - p, y - g).normalize(); t[5].setComponents(o + s, l + f, d + p, y + g).normalize(); return this }, intersectsObject: function () { var e = new THREE.Sphere; return function (t) { var n = t.geometry; if (n.boundingSphere === null) n.computeBoundingSphere(); e.copy(n.boundingSphere); e.applyMatrix4(t.matrixWorld); return this.intersectsSphere(e) } }(), intersectsSphere: function (e) { var t = this.planes; var n = e.center; var r = -e.radius; for (var i = 0; i < 6; i++) { var s = t[i].distanceToPoint(n); if (s < r) { return false } } return true }, intersectsBox: function () { var e = new THREE.Vector3, t = new THREE.Vector3; return function (n) { var r = this.planes; for (var i = 0; i < 6; i++) { var s = r[i]; e.x = s.normal.x > 0 ? n.min.x : n.max.x; t.x = s.normal.x > 0 ? n.max.x : n.min.x; e.y = s.normal.y > 0 ? n.min.y : n.max.y; t.y = s.normal.y > 0 ? n.max.y : n.min.y; e.z = s.normal.z > 0 ? n.min.z : n.max.z; t.z = s.normal.z > 0 ? n.max.z : n.min.z; var o = s.distanceToPoint(e); var u = s.distanceToPoint(t); if (o < 0 && u < 0) { return false } } return true } }(), containsPoint: function (e) { var t = this.planes; for (var n = 0; n < 6; n++) { if (t[n].distanceToPoint(e) < 0) { return false } } return true }, clone: function () { return (new THREE.Frustum).copy(this) } }; THREE.Plane = function (e, t) { this.normal = e !== undefined ? e : new THREE.Vector3(1, 0, 0); this.constant = t !== undefined ? t : 0 }; THREE.Plane.prototype = { constructor: THREE.Plane, set: function (e, t) { this.normal.copy(e); this.constant = t; return this }, setComponents: function (e, t, n, r) { this.normal.set(e, t, n); this.constant = r; return this }, setFromNormalAndCoplanarPoint: function (e, t) { this.normal.copy(e); this.constant = -t.dot(this.normal); return this }, setFromCoplanarPoints: function () { var e = new THREE.Vector3; var t = new THREE.Vector3; return function (n, r, i) { var s = e.subVectors(i, r).cross(t.subVectors(n, r)).normalize(); this.setFromNormalAndCoplanarPoint(s, n); return this } }(), copy: function (e) { this.normal.copy(e.normal); this.constant = e.constant; return this }, normalize: function () { var e = 1 / this.normal.length(); this.normal.multiplyScalar(e); this.constant *= e; return this }, negate: function () { this.constant *= -1; this.normal.negate(); return this }, distanceToPoint: function (e) { return this.normal.dot(e) + this.constant }, distanceToSphere: function (e) { return this.distanceToPoint(e.center) - e.radius }, projectPoint: function (e, t) { return this.orthoPoint(e, t).sub(e).negate() }, orthoPoint: function (e, t) { var n = this.distanceToPoint(e); var r = t || new THREE.Vector3; return r.copy(this.normal).multiplyScalar(n) }, isIntersectionLine: function (e) { var t = this.distanceToPoint(e.start); var n = this.distanceToPoint(e.end); return t < 0 && n > 0 || n < 0 && t > 0 }, intersectLine: function () { var e = new THREE.Vector3; return function (t, n) { var r = n || new THREE.Vector3; var i = t.delta(e); var s = this.normal.dot(i); if (s == 0) { if (this.distanceToPoint(t.start) == 0) { return r.copy(t.start) } return undefined } var o = -(t.start.dot(this.normal) + this.constant) / s; if (o < 0 || o > 1) { return undefined } return r.copy(i).multiplyScalar(o).add(t.start) } }(), coplanarPoint: function (e) { var t = e || new THREE.Vector3; return t.copy(this.normal).multiplyScalar(-this.constant) }, applyMatrix4: function () { var e = new THREE.Vector3; var t = new THREE.Vector3; return function (n, r) { r = r || (new THREE.Matrix3).getNormalMatrix(n); var i = e.copy(this.normal).applyMatrix3(r); var s = this.coplanarPoint(t); s.applyMatrix4(n); this.setFromNormalAndCoplanarPoint(i, s); return this } }(), translate: function (e) { this.constant = this.constant - e.dot(this.normal); return this }, equals: function (e) { return e.normal.equals(this.normal) && e.constant == this.constant }, clone: function () { return (new THREE.Plane).copy(this) } }; THREE.Math = { PI2: Math.PI * 2, generateUUID: function () { var e = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""); var t = new Array(36); var n = 0, r; return function () { for (var i = 0; i < 36; i++) { if (i == 8 || i == 13 || i == 18 || i == 23) { t[i] = "-" } else if (i == 14) { t[i] = "4" } else { if (n <= 2) n = 33554432 + Math.random() * 16777216 | 0; r = n & 15; n = n >> 4; t[i] = e[i == 19 ? r & 3 | 8 : r] } } return t.join("") } }(), clamp: function (e, t, n) { return e < t ? t : e > n ? n : e }, clampBottom: function (e, t) { return e < t ? t : e }, mapLinear: function (e, t, n, r, i) { return r + (e - t) * (i - r) / (n - t) }, smoothstep: function (e, t, n) { if (e <= t) return 0; if (e >= n) return 1; e = (e - t) / (n - t); return e * e * (3 - 2 * e) }, smootherstep: function (e, t, n) { if (e <= t) return 0; if (e >= n) return 1; e = (e - t) / (n - t); return e * e * e * (e * (e * 6 - 15) + 10) }, random16: function () { return (65280 * Math.random() + 255 * Math.random()) / 65535 }, randInt: function (e, t) { return e + Math.floor(Math.random() * (t - e + 1)) }, randFloat: function (e, t) { return e + Math.random() * (t - e) }, randFloatSpread: function (e) { return e * (.5 - Math.random()) }, sign: function (e) { return e < 0 ? -1 : e > 0 ? 1 : 0 }, degToRad: function () { var e = Math.PI / 180; return function (t) { return t * e } }(), radToDeg: function () { var e = 180 / Math.PI; return function (t) { return t * e } }() }; THREE.Spline = function (e) { function h(e, t, n, r, i, s, o) { var u = (n - e) * .5, a = (r - t) * .5; return (2 * (t - n) + u + a) * o + (-3 * (t - n) - 2 * u - a) * s + u * i + t } this.points = e; var t = [], n = { x: 0, y: 0, z: 0 }, r, i, s, o, u, a, f, l, c; this.initFromArray = function (e) { this.points = []; for (var t = 0; t < e.length; t++) { this.points[t] = { x: e[t][0], y: e[t][1], z: e[t][2] } } }; this.getPoint = function (e) { r = (this.points.length - 1) * e; i = Math.floor(r); s = r - i; t[0] = i === 0 ? i : i - 1; t[1] = i; t[2] = i > this.points.length - 2 ? this.points.length - 1 : i + 1; t[3] = i > this.points.length - 3 ? this.points.length - 1 : i + 2; a = this.points[t[0]]; f = this.points[t[1]]; l = this.points[t[2]]; c = this.points[t[3]]; o = s * s; u = s * o; n.x = h(a.x, f.x, l.x, c.x, s, o, u); n.y = h(a.y, f.y, l.y, c.y, s, o, u); n.z = h(a.z, f.z, l.z, c.z, s, o, u); return n }; this.getControlPointsArray = function () { var e, t, n = this.points.length, r = []; for (e = 0; e < n; e++) { t = this.points[e]; r[e] = [t.x, t.y, t.z] } return r }; this.getLength = function (e) { var t, n, r, i, s = 0, o = 0, u = 0, a = new THREE.Vector3, f = new THREE.Vector3, l = [], c = 0; l[0] = 0; if (!e) e = 100; r = this.points.length * e; a.copy(this.points[0]); for (t = 1; t < r; t++) { n = t / r; i = this.getPoint(n); f.copy(i); c += f.distanceTo(a); a.copy(i); s = (this.points.length - 1) * n; o = Math.floor(s); if (o != u) { l[o] = c; u = o } } l[l.length] = c; return { chunks: l, total: c } }; this.reparametrizeByArcLength = function (e) { var t, n, r, i, s, o, u, a, f, l = [], c = new THREE.Vector3, h = this.getLength(); l.push(c.copy(this.points[0]).clone()); for (t = 1; t < this.points.length; t++) { u = h.chunks[t] - h.chunks[t - 1]; a = Math.ceil(e * u / h.total); i = (t - 1) / (this.points.length - 1); s = t / (this.points.length - 1); for (n = 1; n < a - 1; n++) { r = i + n * (1 / a) * (s - i); f = this.getPoint(r); l.push(c.copy(f).clone()) } l.push(c.copy(this.points[t]).clone()) } this.points = l }; }; THREE.Triangle = function (e, t, n) { this.a = e !== undefined ? e : new THREE.Vector3; this.b = t !== undefined ? t : new THREE.Vector3; this.c = n !== undefined ? n : new THREE.Vector3 }; THREE.Triangle.normal = function () { var e = new THREE.Vector3; return function (t, n, r, i) { var s = i || new THREE.Vector3; s.subVectors(r, n); e.subVectors(t, n); s.cross(e); var o = s.lengthSq(); if (o > 0) { return s.multiplyScalar(1 / Math.sqrt(o)) } return s.set(0, 0, 0) } }(); THREE.Triangle.barycoordFromPoint = function () { var e = new THREE.Vector3; var t = new THREE.Vector3; var n = new THREE.Vector3; return function (r, i, s, o, u) { e.subVectors(o, i); t.subVectors(s, i); n.subVectors(r, i); var a = e.dot(e); var f = e.dot(t); var l = e.dot(n); var c = t.dot(t); var h = t.dot(n); var p = a * c - f * f; var d = u || new THREE.Vector3; if (p == 0) { return d.set(-2, -1, -1) } var v = 1 / p; var m = (c * l - f * h) * v; var g = (a * h - f * l) * v; return d.set(1 - m - g, g, m) } }(); THREE.Triangle.containsPoint = function () { var e = new THREE.Vector3; return function (t, n, r, i) { var s = THREE.Triangle.barycoordFromPoint(t, n, r, i, e); return s.x >= 0 && s.y >= 0 && s.x + s.y <= 1 } }(); THREE.Triangle.prototype = { constructor: THREE.Triangle, set: function (e, t, n) { this.a.copy(e); this.b.copy(t); this.c.copy(n); return this }, setFromPointsAndIndices: function (e, t, n, r) { this.a.copy(e[t]); this.b.copy(e[n]); this.c.copy(e[r]); return this }, copy: function (e) { this.a.copy(e.a); this.b.copy(e.b); this.c.copy(e.c); return this }, area: function () { var e = new THREE.Vector3; var t = new THREE.Vector3; return function () { e.subVectors(this.c, this.b); t.subVectors(this.a, this.b); return e.cross(t).length() * .5 } }(), midpoint: function (e) { var t = e || new THREE.Vector3; return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) }, normal: function (e) { return THREE.Triangle.normal(this.a, this.b, this.c, e) }, plane: function (e) { var t = e || new THREE.Plane; return t.setFromCoplanarPoints(this.a, this.b, this.c) }, barycoordFromPoint: function (e, t) { return THREE.Triangle.barycoordFromPoint(e, this.a, this.b, this.c, t) }, containsPoint: function (e) { return THREE.Triangle.containsPoint(e, this.a, this.b, this.c) }, equals: function (e) { return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c) }, clone: function () { return (new THREE.Triangle).copy(this) } }; THREE.Vertex = function (e) { console.warn("THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead."); return e }; THREE.UV = function (e, t) { console.warn("THREE.UV has been DEPRECATED. Use THREE.Vector2 instead."); return new THREE.Vector2(e, t) }; THREE.EventDispatcher = function () { }; THREE.EventDispatcher.prototype = { constructor: THREE.EventDispatcher, apply: function (e) { e.addEventListener = THREE.EventDispatcher.prototype.addEventListener; e.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener; e.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener; e.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent }, addEventListener: function (e, t) { if (this._listeners === undefined) this._listeners = {}; var n = this._listeners; if (n[e] === undefined) { n[e] = [] } if (n[e].indexOf(t) === -1) { n[e].push(t) } }, hasEventListener: function (e, t) { if (this._listeners === undefined) return false; var n = this._listeners; if (n[e] !== undefined && n[e].indexOf(t) !== -1) { return true } return false }, removeEventListener: function (e, t) { if (this._listeners === undefined) return; var n = this._listeners; var r = n[e].indexOf(t); if (r !== -1) { n[e].splice(r, 1) } }, dispatchEvent: function (e) { if (this._listeners === undefined) return; var t = this._listeners; var n = t[e.type]; if (n !== undefined) { e.target = this; for (var r = 0, i = n.length; r < i; r++) { n[r].call(this, e) } } } }; THREE.Object3D = function () { this.id = THREE.Object3DIdCount++; this.uuid = THREE.Math.generateUUID(); this.name = ""; this.parent = undefined; this.children = []; this.up = new THREE.Vector3(0, 1, 0); this.position = new THREE.Vector3; this.rotation = new THREE.Euler; this.quaternion = new THREE.Quaternion; this.scale = new THREE.Vector3(1, 1, 1); this.rotation._quaternion = this.quaternion; this.quaternion._euler = this.rotation; this.renderDepth = null; this.rotationAutoUpdate = true; this.matrix = new THREE.Matrix4; this.matrixWorld = new THREE.Matrix4; this.matrixAutoUpdate = true; this.matrixWorldNeedsUpdate = true; this.visible = true; this.castShadow = false; this.receiveShadow = false; this.frustumCulled = true; this.userData = {} }; THREE.Object3D.prototype = { constructor: THREE.Object3D, get eulerOrder() { console.warn("DEPRECATED: Object3D's .eulerOrder has been moved to Object3D's .rotation.order."); return this.rotation.order }, set eulerOrder(e) { console.warn("DEPRECATED: Object3D's .eulerOrder has been moved to Object3D's .rotation.order."); this.rotation.order = e }, applyMatrix: function () { var e = new THREE.Matrix4; return function (t) { this.matrix.multiplyMatrices(t, this.matrix); this.position.getPositionFromMatrix(this.matrix); this.scale.getScaleFromMatrix(this.matrix); e.extractRotation(this.matrix); this.quaternion.setFromRotationMatrix(e) } }(), setRotationFromAxisAngle: function (e, t) { this.quaternion.setFromAxisAngle(e, t) }, setRotationFromEuler: function (e) { this.quaternion.setFromEuler(e, true) }, setRotationFromMatrix: function (e) { this.quaternion.setFromRotationMatrix(e) }, setRotationFromQuaternion: function (e) { this.quaternion.copy(e) }, rotateOnAxis: function () { var e = new THREE.Quaternion; return function (t, n) { e.setFromAxisAngle(t, n); this.quaternion.multiply(e); return this } }(), rotateX: function () { var e = new THREE.Vector3(1, 0, 0); return function (t) { return this.rotateOnAxis(e, t) } }(), rotateY: function () { var e = new THREE.Vector3(0, 1, 0); return function (t) { return this.rotateOnAxis(e, t) } }(), rotateZ: function () { var e = new THREE.Vector3(0, 0, 1); return function (t) { return this.rotateOnAxis(e, t) } }(), translateOnAxis: function () { var e = new THREE.Vector3; return function (t, n) { e.copy(t); e.applyQuaternion(this.quaternion); this.position.add(e.multiplyScalar(n)); return this } }(), translate: function (e, t) { console.warn("DEPRECATED: Object3D's .translate() has been removed. Use .translateOnAxis( axis, distance ) instead. Note args have been changed."); return this.translateOnAxis(t, e) }, translateX: function () { var e = new THREE.Vector3(1, 0, 0); return function (t) { return this.translateOnAxis(e, t) } }(), translateY: function () { var e = new THREE.Vector3(0, 1, 0); return function (t) { return this.translateOnAxis(e, t) } }(), translateZ: function () { var e = new THREE.Vector3(0, 0, 1); return function (t) { return this.translateOnAxis(e, t) } }(), localToWorld: function (e) { return e.applyMatrix4(this.matrixWorld) }, worldToLocal: function () { var e = new THREE.Matrix4; return function (t) { return t.applyMatrix4(e.getInverse(this.matrixWorld)) } }(), lookAt: function () { var e = new THREE.Matrix4; return function (t) { e.lookAt(t, this.position, this.up); this.quaternion.setFromRotationMatrix(e) } }(), add: function (e) { if (e === this) { console.warn("THREE.Object3D.add: An object can't be added as a child of itself."); return } if (e instanceof THREE.Object3D) { if (e.parent !== undefined) { e.parent.remove(e) } e.parent = this; e.dispatchEvent({ type: "added" }); this.children.push(e); var t = this; while (t.parent !== undefined) { t = t.parent } if (t !== undefined && t instanceof THREE.Scene) { t.__addObject(e) } } }, remove: function (e) { var t = this.children.indexOf(e); if (t !== -1) { e.parent = undefined; e.dispatchEvent({ type: "removed" }); this.children.splice(t, 1); var n = this; while (n.parent !== undefined) { n = n.parent } if (n !== undefined && n instanceof THREE.Scene) { n.__removeObject(e) } } }, traverse: function (e) { e(this); for (var t = 0, n = this.children.length; t < n; t++) { this.children[t].traverse(e) } }, getObjectById: function (e, t) { for (var n = 0, r = this.children.length; n < r; n++) { var i = this.children[n]; if (i.id === e) { return i } if (t === true) { i = i.getObjectById(e, t); if (i !== undefined) { return i } } } return undefined }, getObjectByName: function (e, t) { for (var n = 0, r = this.children.length; n < r; n++) { var i = this.children[n]; if (i.name === e) { return i } if (t === true) { i = i.getObjectByName(e, t); if (i !== undefined) { return i } } } return undefined }, getChildByName: function (e, t) { console.warn("DEPRECATED: Object3D's .getChildByName() has been renamed to .getObjectByName()."); return this.getObjectByName(e, t) }, getDescendants: function (e) { if (e === undefined) e = []; Array.prototype.push.apply(e, this.children); for (var t = 0, n = this.children.length; t < n; t++) { this.children[t].getDescendants(e) } return e }, updateMatrix: function () { this.matrix.compose(this.position, this.quaternion, this.scale); this.matrixWorldNeedsUpdate = true }, updateMatrixWorld: function (e) { if (this.matrixAutoUpdate === true) this.updateMatrix(); if (this.matrixWorldNeedsUpdate === true || e === true) { if (this.parent === undefined) { this.matrixWorld.copy(this.matrix) } else { this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix) } this.matrixWorldNeedsUpdate = false; e = true } for (var t = 0, n = this.children.length; t < n; t++) { this.children[t].updateMatrixWorld(e) } }, clone: function (e, t) { if (e === undefined) e = new THREE.Object3D; if (t === undefined) t = true; e.name = this.name; e.up.copy(this.up); e.position.copy(this.position); e.quaternion.copy(this.quaternion); e.scale.copy(this.scale); e.renderDepth = this.renderDepth; e.rotationAutoUpdate = this.rotationAutoUpdate; e.matrix.copy(this.matrix); e.matrixWorld.copy(this.matrixWorld); e.matrixAutoUpdate = this.matrixAutoUpdate; e.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate; e.visible = this.visible; e.castShadow = this.castShadow; e.receiveShadow = this.receiveShadow; e.frustumCulled = this.frustumCulled; e.userData = JSON.parse(JSON.stringify(this.userData)); if (t === true) { for (var n = 0; n < this.children.length; n++) { var r = this.children[n]; e.add(r.clone()) } } return e } }; THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype); THREE.Object3DIdCount = 0; THREE.Projector = function () { function q() { if (t === r) { var e = new THREE.RenderableObject; n.push(e); r++; t++; return e } return n[t++] } function R() { if (s === u) { var e = new THREE.RenderableVertex; o.push(e); u++; s++; return e } return o[s++] } function U() { if (f === c) { var e = new THREE.RenderableFace3; l.push(e); c++; f++; return e } return l[f++] } function z() { if (p === v) { var e = new THREE.RenderableLine; d.push(e); v++; p++; return e } return d[p++] } function W() { if (g === b) { var e = new THREE.RenderableParticle; y.push(e); b++; g++; return e } return y[g++] } function X(e, t) { if (e.z !== t.z) { return t.z - e.z } else if (e.id !== t.id) { return e.id - t.id } else { return 0 } } function V(e, t) { var n = 0, r = 1, i = e.z + e.w, s = t.z + t.w, o = -e.z + e.w, u = -t.z + t.w; if (i >= 0 && s >= 0 && o >= 0 && u >= 0) { return true } else if (i < 0 && s < 0 || o < 0 && u < 0) { return false } else { if (i < 0) { n = Math.max(n, i / (i - s)) } else if (s < 0) { r = Math.min(r, i / (i - s)) } if (o < 0) { n = Math.max(n, o / (o - u)) } else if (u < 0) { r = Math.min(r, o / (o - u)) } if (r < n) { return false } else { e.lerp(t, n); t.lerp(e, 1 - r); return true } } } var e, t, n = [], r = 0, i, s, o = [], u = 0, a, f, l = [], c = 0, h, p, d = [], v = 0, m, g, y = [], b = 0, w = { objects: [], sprites: [], lights: [], elements: [] }, E = new THREE.Vector3, S = new THREE.Vector4, x = new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1)), T = new THREE.Box3, N = new Array(3), C = new Array(4), k = new THREE.Matrix4, L = new THREE.Matrix4, A, O = new THREE.Matrix4, M = new THREE.Matrix3, _ = new THREE.Matrix3, D = new THREE.Vector3, P = new THREE.Frustum, H = new THREE.Vector4, B = new THREE.Vector4; this.projectVector = function (e, t) { t.matrixWorldInverse.getInverse(t.matrixWorld); L.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse); return e.applyProjection(L) }; this.unprojectVector = function (e, t) { t.projectionMatrixInverse.getInverse(t.projectionMatrix); L.multiplyMatrices(t.matrixWorld, t.projectionMatrixInverse); return e.applyProjection(L) }; this.pickingRay = function (e, t) { e.z = -1; var n = new THREE.Vector3(e.x, e.y, 1); this.unprojectVector(e, t); this.unprojectVector(n, t); n.sub(e).normalize(); return new THREE.Raycaster(e, n) }; var j = function (t) { e = q(); e.id = t.id; e.object = t; if (t.renderDepth !== null) { e.z = t.renderDepth } else { E.getPositionFromMatrix(t.matrixWorld); E.applyProjection(L); e.z = E.z } return e }; var F = function (e) { if (e.visible === false) return; if (e instanceof THREE.Light) { w.lights.push(e) } else if (e instanceof THREE.Mesh || e instanceof THREE.Line) { if (e.frustumCulled === false || P.intersectsObject(e) === true) { w.objects.push(j(e)) } } else if (e instanceof THREE.Sprite || e instanceof THREE.Particle) { w.sprites.push(j(e)) } for (var t = 0, n = e.children.length; t < n; t++) { F(e.children[t]) } }; var I = function (e, n) { t = 0; w.objects.length = 0; w.sprites.length = 0; w.lights.length = 0; F(e); if (n === true) { w.objects.sort(X) } }; this.projectScene = function (e, t, n, r) { var u = false, l, c, d, v, y, b, E, C, j, F, q, $, J, K, Q, G, Y, Z, et, tt, nt, rt, it, st, ot, ut; f = 0; p = 0; g = 0; w.elements.length = 0; if (e.autoUpdate === true) e.updateMatrixWorld(); if (t.parent === undefined) t.updateMatrixWorld(); k.copy(t.matrixWorldInverse.getInverse(t.matrixWorld)); L.multiplyMatrices(t.projectionMatrix, k); _.getNormalMatrix(k); P.setFromMatrix(L); I(e, n); for (l = 0, c = w.objects.length; l < c; l++) { J = w.objects[l].object; A = J.matrixWorld; s = 0; if (J instanceof THREE.Mesh) { K = J.geometry; Q = K.vertices; G = K.faces; et = K.faceVertexUvs; M.getNormalMatrix(A); ot = J.material instanceof THREE.MeshFaceMaterial; ut = ot === true ? J.material : null; for (d = 0, v = Q.length; d < v; d++) { i = R(); i.positionWorld.copy(Q[d]).applyMatrix4(A); i.positionScreen.copy(i.positionWorld).applyMatrix4(L); var at = 1 / i.positionScreen.w; i.positionScreen.x *= at; i.positionScreen.y *= at; i.positionScreen.z *= at; i.visible = !(i.positionScreen.x < -1 || i.positionScreen.x > 1 || i.positionScreen.y < -1 || i.positionScreen.y > 1 || i.positionScreen.z < -1 || i.positionScreen.z > 1) } for (y = 0, b = G.length; y < b; y++) { Y = G[y]; var ft = ot === true ? ut.materials[Y.materialIndex] : J.material; if (ft === undefined) continue; var lt = ft.side; nt = o[Y.a]; rt = o[Y.b]; it = o[Y.c]; N[0] = nt.positionScreen; N[1] = rt.positionScreen; N[2] = it.positionScreen; if (nt.visible === true || rt.visible === true || it.visible === true || x.isIntersectionBox(T.setFromPoints(N))) { u = (it.positionScreen.x - nt.positionScreen.x) * (rt.positionScreen.y - nt.positionScreen.y) - (it.positionScreen.y - nt.positionScreen.y) * (rt.positionScreen.x - nt.positionScreen.x) < 0; if (lt === THREE.DoubleSide || u === (lt === THREE.FrontSide)) { a = U(); a.id = J.id; a.v1.copy(nt); a.v2.copy(rt); a.v3.copy(it) } else { continue } } else { continue } a.normalModel.copy(Y.normal); if (u === false && (lt === THREE.BackSide || lt === THREE.DoubleSide)) { a.normalModel.negate() } a.normalModel.applyMatrix3(M).normalize(); a.normalModelView.copy(a.normalModel).applyMatrix3(_); a.centroidModel.copy(Y.centroid).applyMatrix4(A); Z = Y.vertexNormals; for (E = 0, C = Math.min(Z.length, 3) ; E < C; E++) { var ct = a.vertexNormalsModel[E]; ct.copy(Z[E]); if (u === false && (lt === THREE.BackSide || lt === THREE.DoubleSide)) { ct.negate() } ct.applyMatrix3(M).normalize(); var ht = a.vertexNormalsModelView[E]; ht.copy(ct).applyMatrix3(_) } a.vertexNormalsLength = Z.length; for (j = 0, F = Math.min(et.length, 3) ; j < F; j++) { tt = et[j][y]; if (tt === undefined) continue; for (q = 0, $ = tt.length; q < $; q++) { a.uvs[j][q] = tt[q] } } a.color = Y.color; a.material = ft; D.copy(a.centroidModel).applyProjection(L); a.z = D.z; w.elements.push(a) } } else if (J instanceof THREE.Line) { O.multiplyMatrices(L, A); Q = J.geometry.vertices; nt = R(); nt.positionScreen.copy(Q[0]).applyMatrix4(O); var pt = J.type === THREE.LinePieces ? 2 : 1; for (d = 1, v = Q.length; d < v; d++) { nt = R(); nt.positionScreen.copy(Q[d]).applyMatrix4(O); if ((d + 1) % pt > 0) continue; rt = o[s - 2]; H.copy(nt.positionScreen); B.copy(rt.positionScreen); if (V(H, B) === true) { H.multiplyScalar(1 / H.w); B.multiplyScalar(1 / B.w); h = z(); h.id = J.id; h.v1.positionScreen.copy(H); h.v2.positionScreen.copy(B); h.z = Math.max(H.z, B.z); h.material = J.material; if (J.material.vertexColors === THREE.VertexColors) { h.vertexColors[0].copy(J.geometry.colors[d]); h.vertexColors[1].copy(J.geometry.colors[d - 1]) } w.elements.push(h) } } } } for (l = 0, c = w.sprites.length; l < c; l++) { J = w.sprites[l].object; A = J.matrixWorld; if (J instanceof THREE.Particle) { S.set(A.elements[12], A.elements[13], A.elements[14], 1); S.applyMatrix4(L); var at = 1 / S.w; S.z *= at; if (S.z > 0 && S.z < 1) { m = W(); m.id = J.id; m.x = S.x * at; m.y = S.y * at; m.z = S.z; m.object = J; m.rotation = J.rotation.z; m.scale.x = J.scale.x * Math.abs(m.x - (S.x + t.projectionMatrix.elements[0]) / (S.w + t.projectionMatrix.elements[12])); m.scale.y = J.scale.y * Math.abs(m.y - (S.y + t.projectionMatrix.elements[5]) / (S.w + t.projectionMatrix.elements[13])); m.material = J.material; w.elements.push(m) } } } if (r === true) w.elements.sort(X); return w } }; THREE.Face3 = function (e, t, n, r, i, s) { this.a = e; this.b = t; this.c = n; this.normal = r instanceof THREE.Vector3 ? r : new THREE.Vector3; this.vertexNormals = r instanceof Array ? r : []; this.color = i instanceof THREE.Color ? i : new THREE.Color; this.vertexColors = i instanceof Array ? i : []; this.vertexTangents = []; this.materialIndex = s !== undefined ? s : 0; this.centroid = new THREE.Vector3 }; THREE.Face3.prototype = { constructor: THREE.Face3, clone: function () { var e = new THREE.Face3(this.a, this.b, this.c); e.normal.copy(this.normal); e.color.copy(this.color); e.centroid.copy(this.centroid); e.materialIndex = this.materialIndex; var t, n; for (t = 0, n = this.vertexNormals.length; t < n; t++) e.vertexNormals[t] = this.vertexNormals[t].clone(); for (t = 0, n = this.vertexColors.length; t < n; t++) e.vertexColors[t] = this.vertexColors[t].clone(); for (t = 0, n = this.vertexTangents.length; t < n; t++) e.vertexTangents[t] = this.vertexTangents[t].clone(); return e } }; THREE.Face4 = function (e, t, n, r, i, s, o) { console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."); return new THREE.Face3(e, t, n, i, s, o) }; THREE.Geometry = function () { this.id = THREE.GeometryIdCount++; this.uuid = THREE.Math.generateUUID(); this.name = ""; this.vertices = []; this.colors = []; this.faces = []; this.faceVertexUvs = [[]]; this.morphTargets = []; this.morphColors = []; this.morphNormals = []; this.skinWeights = []; this.skinIndices = []; this.lineDistances = []; this.boundingBox = null; this.boundingSphere = null; this.hasTangents = false; this.dynamic = true; this.verticesNeedUpdate = false; this.elementsNeedUpdate = false; this.uvsNeedUpdate = false; this.normalsNeedUpdate = false; this.tangentsNeedUpdate = false; this.colorsNeedUpdate = false; this.lineDistancesNeedUpdate = false; this.buffersNeedUpdate = false }; THREE.Geometry.prototype = { constructor: THREE.Geometry, applyMatrix: function (e) { var t = (new THREE.Matrix3).getNormalMatrix(e); for (var n = 0, r = this.vertices.length; n < r; n++) { var i = this.vertices[n]; i.applyMatrix4(e) } for (var n = 0, r = this.faces.length; n < r; n++) { var s = this.faces[n]; s.normal.applyMatrix3(t).normalize(); for (var o = 0, u = s.vertexNormals.length; o < u; o++) { s.vertexNormals[o].applyMatrix3(t).normalize() } s.centroid.applyMatrix4(e) } if (this.boundingBox instanceof THREE.Box3) { this.computeBoundingBox() } if (this.boundingSphere instanceof THREE.Sphere) { this.computeBoundingSphere() } }, computeCentroids: function () { var e, t, n; for (e = 0, t = this.faces.length; e < t; e++) { n = this.faces[e]; n.centroid.set(0, 0, 0); n.centroid.add(this.vertices[n.a]); n.centroid.add(this.vertices[n.b]); n.centroid.add(this.vertices[n.c]); n.centroid.divideScalar(3) } }, computeFaceNormals: function () { var e = new THREE.Vector3, t = new THREE.Vector3; for (var n = 0, r = this.faces.length; n < r; n++) { var i = this.faces[n]; var s = this.vertices[i.a]; var o = this.vertices[i.b]; var u = this.vertices[i.c]; e.subVectors(u, o); t.subVectors(s, o); e.cross(t); e.normalize(); i.normal.copy(e) } }, computeVertexNormals: function (e) { var t, n, r, i, s, o; if (this.__tmpVertices === undefined) { this.__tmpVertices = new Array(this.vertices.length); o = this.__tmpVertices; for (t = 0, n = this.vertices.length; t < n; t++) { o[t] = new THREE.Vector3 } for (r = 0, i = this.faces.length; r < i; r++) { s = this.faces[r]; s.vertexNormals = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3] } } else { o = this.__tmpVertices; for (t = 0, n = this.vertices.length; t < n; t++) { o[t].set(0, 0, 0) } } if (e) { var u, a, f, l; var c = new THREE.Vector3, h = new THREE.Vector3, p = new THREE.Vector3, d = new THREE.Vector3, v = new THREE.Vector3; for (r = 0, i = this.faces.length; r < i; r++) { s = this.faces[r]; u = this.vertices[s.a]; a = this.vertices[s.b]; f = this.vertices[s.c]; c.subVectors(f, a); h.subVectors(u, a); c.cross(h); o[s.a].add(c); o[s.b].add(c); o[s.c].add(c) } } else { for (r = 0, i = this.faces.length; r < i; r++) { s = this.faces[r]; o[s.a].add(s.normal); o[s.b].add(s.normal); o[s.c].add(s.normal) } } for (t = 0, n = this.vertices.length; t < n; t++) { o[t].normalize() } for (r = 0, i = this.faces.length; r < i; r++) { s = this.faces[r]; s.vertexNormals[0].copy(o[s.a]); s.vertexNormals[1].copy(o[s.b]); s.vertexNormals[2].copy(o[s.c]) } }, computeMorphNormals: function () { var e, t, n, r, i; for (n = 0, r = this.faces.length; n < r; n++) { i = this.faces[n]; if (!i.__originalFaceNormal) { i.__originalFaceNormal = i.normal.clone() } else { i.__originalFaceNormal.copy(i.normal) } if (!i.__originalVertexNormals) i.__originalVertexNormals = []; for (e = 0, t = i.vertexNormals.length; e < t; e++) { if (!i.__originalVertexNormals[e]) { i.__originalVertexNormals[e] = i.vertexNormals[e].clone() } else { i.__originalVertexNormals[e].copy(i.vertexNormals[e]) } } } var s = new THREE.Geometry; s.faces = this.faces; for (e = 0, t = this.morphTargets.length; e < t; e++) { if (!this.morphNormals[e]) { this.morphNormals[e] = {}; this.morphNormals[e].faceNormals = []; this.morphNormals[e].vertexNormals = []; var o = this.morphNormals[e].faceNormals; var u = this.morphNormals[e].vertexNormals; var a, f; for (n = 0, r = this.faces.length; n < r; n++) { i = this.faces[n]; a = new THREE.Vector3; f = { a: new THREE.Vector3, b: new THREE.Vector3, c: new THREE.Vector3 }; o.push(a); u.push(f) } } var l = this.morphNormals[e]; s.vertices = this.morphTargets[e].vertices; s.computeFaceNormals(); s.computeVertexNormals(); var a, f; for (n = 0, r = this.faces.length; n < r; n++) { i = this.faces[n]; a = l.faceNormals[n]; f = l.vertexNormals[n]; a.copy(i.normal); f.a.copy(i.vertexNormals[0]); f.b.copy(i.vertexNormals[1]); f.c.copy(i.vertexNormals[2]) } } for (n = 0, r = this.faces.length; n < r; n++) { i = this.faces[n]; i.normal = i.__originalFaceNormal; i.vertexNormals = i.__originalVertexNormals } }, computeTangents: function () { function B(e, t, n, r, i, s, o) { f = e.vertices[t]; l = e.vertices[n]; c = e.vertices[r]; h = a[i]; p = a[s]; d = a[o]; v = l.x - f.x; m = c.x - f.x; g = l.y - f.y; y = c.y - f.y; b = l.z - f.z; w = c.z - f.z; E = p.x - h.x; S = d.x - h.x; x = p.y - h.y; T = d.y - h.y; N = 1 / (E * T - S * x); O.set((T * v - x * m) * N, (T * g - x * y) * N, (T * b - x * w) * N); M.set((E * m - S * v) * N, (E * y - S * g) * N, (E * w - S * b) * N); L[t].add(O); L[n].add(O); L[r].add(O); A[t].add(M); A[n].add(M); A[r].add(M) } var e, t, n, r, i, s, o, u, a, f, l, c, h, p, d, v, m, g, y, b, w, E, S, x, T, N, C, k, L = [], A = [], O = new THREE.Vector3, M = new THREE.Vector3, _ = new THREE.Vector3, D = new THREE.Vector3, P = new THREE.Vector3, H; for (n = 0, r = this.vertices.length; n < r; n++) { L[n] = new THREE.Vector3; A[n] = new THREE.Vector3 } for (e = 0, t = this.faces.length; e < t; e++) { u = this.faces[e]; a = this.faceVertexUvs[0][e]; B(this, u.a, u.b, u.c, 0, 1, 2) } var j = ["a", "b", "c", "d"]; for (e = 0, t = this.faces.length; e < t; e++) { u = this.faces[e]; for (i = 0; i < Math.min(u.vertexNormals.length, 3) ; i++) { P.copy(u.vertexNormals[i]); o = u[j[i]]; C = L[o]; _.copy(C); _.sub(P.multiplyScalar(P.dot(C))).normalize(); D.crossVectors(u.vertexNormals[i], C); k = D.dot(A[o]); H = k < 0 ? -1 : 1; u.vertexTangents[i] = new THREE.Vector4(_.x, _.y, _.z, H) } } this.hasTangents = true }, computeLineDistances: function () { var e = 0; var t = this.vertices; for (var n = 0, r = t.length; n < r; n++) { if (n > 0) { e += t[n].distanceTo(t[n - 1]) } this.lineDistances[n] = e } }, computeBoundingBox: function () { if (this.boundingBox === null) { this.boundingBox = new THREE.Box3 } this.boundingBox.setFromPoints(this.vertices) }, computeBoundingSphere: function () { if (this.boundingSphere === null) { this.boundingSphere = new THREE.Sphere } this.boundingSphere.setFromPoints(this.vertices) }, mergeVertices: function () { var e = {}; var t = [], n = []; var r, i; var s = 4; var o = Math.pow(10, s); var u, a, f; var l, c, h, p, d; this.__tmpVertices = undefined; for (u = 0, a = this.vertices.length; u < a; u++) { r = this.vertices[u]; i = Math.round(r.x * o) + "_" + Math.round(r.y * o) + "_" + Math.round(r.z * o); if (e[i] === undefined) { e[i] = u; t.push(this.vertices[u]); n[u] = t.length - 1 } else { n[u] = n[e[i]] } } var v = []; for (u = 0, a = this.faces.length; u < a; u++) { f = this.faces[u]; f.a = n[f.a]; f.b = n[f.b]; f.c = n[f.c]; l = [f.a, f.b, f.c]; var m = -1; for (var g = 0; g < 3; g++) { if (l[g] == l[(g + 1) % 3]) { m = g; v.push(u); break } } } for (u = v.length - 1; u >= 0; u--) { var y = v[u]; this.faces.splice(y, 1); for (h = 0, p = this.faceVertexUvs.length; h < p; h++) { this.faceVertexUvs[h].splice(y, 1) } } var b = this.vertices.length - t.length; this.vertices = t; return b }, clone: function () { var e = new THREE.Geometry; var t = this.vertices; for (var n = 0, r = t.length; n < r; n++) { e.vertices.push(t[n].clone()) } var i = this.faces; for (var n = 0, r = i.length; n < r; n++) { e.faces.push(i[n].clone()) } var s = this.faceVertexUvs[0]; for (var n = 0, r = s.length; n < r; n++) { var o = s[n], u = []; for (var a = 0, f = o.length; a < f; a++) { u.push(new THREE.Vector2(o[a].x, o[a].y)) } e.faceVertexUvs[0].push(u) } return e }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }; THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype); THREE.GeometryIdCount = 0; THREE.BufferGeometry = function () { this.id = THREE.GeometryIdCount++; this.uuid = THREE.Math.generateUUID(); this.name = ""; this.attributes = {}; this.dynamic = true; this.offsets = []; this.boundingBox = null; this.boundingSphere = null; this.hasTangents = false; this.morphTargets = [] }; THREE.BufferGeometry.prototype = { constructor: THREE.BufferGeometry, applyMatrix: function (e) { var t; var n; if (this.attributes["position"]) t = this.attributes["position"].array; if (this.attributes["normal"]) n = this.attributes["normal"].array; if (t !== undefined) { e.multiplyVector3Array(t); this.verticesNeedUpdate = true } if (n !== undefined) { var r = (new THREE.Matrix3).getNormalMatrix(e); r.multiplyVector3Array(n); this.normalizeNormals(); this.normalsNeedUpdate = true } }, computeBoundingBox: function () { if (this.boundingBox === null) { this.boundingBox = new THREE.Box3 } var e = this.attributes["position"].array; if (e) { var t = this.boundingBox; var n, r, i; if (e.length >= 3) { t.min.x = t.max.x = e[0]; t.min.y = t.max.y = e[1]; t.min.z = t.max.z = e[2] } for (var s = 3, o = e.length; s < o; s += 3) { n = e[s]; r = e[s + 1]; i = e[s + 2]; if (n < t.min.x) { t.min.x = n } else if (n > t.max.x) { t.max.x = n } if (r < t.min.y) { t.min.y = r } else if (r > t.max.y) { t.max.y = r } if (i < t.min.z) { t.min.z = i } else if (i > t.max.z) { t.max.z = i } } } if (e === undefined || e.length === 0) { this.boundingBox.min.set(0, 0, 0); this.boundingBox.max.set(0, 0, 0) } }, computeBoundingSphere: function () { var e = new THREE.Box3; var t = new THREE.Vector3; return function () { if (this.boundingSphere === null) { this.boundingSphere = new THREE.Sphere } var n = this.attributes["position"].array; if (n) { var r = this.boundingSphere.center; for (var i = 0, s = n.length; i < s; i += 3) { t.set(n[i], n[i + 1], n[i + 2]); e.addPoint(t) } e.center(r); var o = 0; for (var i = 0, s = n.length; i < s; i += 3) { t.set(n[i], n[i + 1], n[i + 2]); o = Math.max(o, r.distanceToSquared(t)) } this.boundingSphere.radius = Math.sqrt(o) } } }(), computeVertexNormals: function () { if (this.attributes["position"]) { var e, t; var n, r; var i = this.attributes["position"].array.length; if (this.attributes["normal"] === undefined) { this.attributes["normal"] = { itemSize: 3, array: new Float32Array(i) } } else { for (e = 0, t = this.attributes["normal"].array.length; e < t; e++) { this.attributes["normal"].array[e] = 0 } } var s = this.attributes["position"].array; var o = this.attributes["normal"].array; var u, a, f, l, c, h, p = new THREE.Vector3, d = new THREE.Vector3, v = new THREE.Vector3, m = new THREE.Vector3, g = new THREE.Vector3; if (this.attributes["index"]) { var y = this.attributes["index"].array; var b = this.offsets; for (n = 0, r = b.length; n < r; ++n) { var w = b[n].start; var E = b[n].count; var S = b[n].index; for (e = w, t = w + E; e < t; e += 3) { u = S + y[e]; a = S + y[e + 1]; f = S + y[e + 2]; l = s[u * 3]; c = s[u * 3 + 1]; h = s[u * 3 + 2]; p.set(l, c, h); l = s[a * 3]; c = s[a * 3 + 1]; h = s[a * 3 + 2]; d.set(l, c, h); l = s[f * 3]; c = s[f * 3 + 1]; h = s[f * 3 + 2]; v.set(l, c, h); m.subVectors(v, d); g.subVectors(p, d); m.cross(g); o[u * 3] += m.x; o[u * 3 + 1] += m.y; o[u * 3 + 2] += m.z; o[a * 3] += m.x; o[a * 3 + 1] += m.y; o[a * 3 + 2] += m.z; o[f * 3] += m.x; o[f * 3 + 1] += m.y; o[f * 3 + 2] += m.z } } } else { for (e = 0, t = s.length; e < t; e += 9) { l = s[e]; c = s[e + 1]; h = s[e + 2]; p.set(l, c, h); l = s[e + 3]; c = s[e + 4]; h = s[e + 5]; d.set(l, c, h); l = s[e + 6]; c = s[e + 7]; h = s[e + 8]; v.set(l, c, h); m.subVectors(v, d); g.subVectors(p, d); m.cross(g); o[e] = m.x; o[e + 1] = m.y; o[e + 2] = m.z; o[e + 3] = m.x; o[e + 4] = m.y; o[e + 5] = m.z; o[e + 6] = m.x; o[e + 7] = m.y; o[e + 8] = m.z } } this.normalizeNormals(); this.normalsNeedUpdate = true } }, normalizeNormals: function () { var e = this.attributes["normal"].array; var t, n, r, i; for (var s = 0, o = e.length; s < o; s += 3) { t = e[s]; n = e[s + 1]; r = e[s + 2]; i = 1 / Math.sqrt(t * t + n * n + r * r); e[s] *= i; e[s + 1] *= i; e[s + 2] *= i } }, computeTangents: function () { function F(e, n, i) { l = t[e * 3]; c = t[e * 3 + 1]; h = t[e * 3 + 2]; p = t[n * 3]; d = t[n * 3 + 1]; v = t[n * 3 + 2]; m = t[i * 3]; g = t[i * 3 + 1]; y = t[i * 3 + 2]; b = r[e * 2]; w = r[e * 2 + 1]; E = r[n * 2]; S = r[n * 2 + 1]; x = r[i * 2]; T = r[i * 2 + 1]; N = p - l; C = m - l; k = d - c; L = g - c; A = v - h; O = y - h; M = E - b; _ = x - b; D = S - w; P = T - w; H = 1 / (M * P - _ * D); B.set((P * N - D * C) * H, (P * k - D * L) * H, (P * A - D * O) * H); j.set((M * C - _ * N) * H, (M * L - _ * k) * H, (M * O - _ * A) * H); u[e].add(B); u[n].add(B); u[i].add(B); a[e].add(j); a[n].add(j); a[i].add(j) } function rt(e) { Y.x = n[e * 3]; Y.y = n[e * 3 + 1]; Y.z = n[e * 3 + 2]; Z.copy(Y); tt = u[e]; Q.copy(tt); Q.sub(Y.multiplyScalar(Y.dot(tt))).normalize(); G.crossVectors(Z, tt); nt = G.dot(a[e]); et = nt < 0 ? -1 : 1; o[e * 4] = Q.x; o[e * 4 + 1] = Q.y; o[e * 4 + 2] = Q.z; o[e * 4 + 3] = et } if (this.attributes["index"] === undefined || this.attributes["position"] === undefined || this.attributes["normal"] === undefined || this.attributes["uv"] === undefined) { console.warn("Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()"); return } var e = this.attributes["index"].array; var t = this.attributes["position"].array; var n = this.attributes["normal"].array; var r = this.attributes["uv"].array; var i = t.length / 3; if (this.attributes["tangent"] === undefined) { var s = 4 * i; this.attributes["tangent"] = { itemSize: 4, array: new Float32Array(s) } } var o = this.attributes["tangent"].array; var u = [], a = []; for (var f = 0; f < i; f++) { u[f] = new THREE.Vector3; a[f] = new THREE.Vector3 } var l, c, h, p, d, v, m, g, y, b, w, E, S, x, T, N, C, k, L, A, O, M, _, D, P, H; var B = new THREE.Vector3, j = new THREE.Vector3; var I, q; var R, U; var z, W, X; var V = this.offsets; for (R = 0, U = V.length; R < U; ++R) { var $ = V[R].start; var J = V[R].count; var K = V[R].index; for (I = $, q = $ + J; I < q; I += 3) { z = K + e[I]; W = K + e[I + 1]; X = K + e[I + 2]; F(z, W, X) } } var Q = new THREE.Vector3, G = new THREE.Vector3; var Y = new THREE.Vector3, Z = new THREE.Vector3; var et, tt, nt; for (R = 0, U = V.length; R < U; ++R) { var $ = V[R].start; var J = V[R].count; var K = V[R].index; for (I = $, q = $ + J; I < q; I += 3) { z = K + e[I]; W = K + e[I + 1]; X = K + e[I + 2]; rt(z); rt(W); rt(X) } } this.hasTangents = true; this.tangentsNeedUpdate = true }, clone: function () { var e = new THREE.BufferGeometry; var t = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array]; for (var n in this.attributes) { var r = this.attributes[n]; var i = r.array; var s = { itemSize: r.itemSize, numItems: r.numItems, array: null }; for (var o = 0, u = t.length; o < u; o++) { var a = t[o]; if (i instanceof a) { s.array = new a(i); break } } e.attributes[n] = s } for (var o = 0, u = this.offsets.length; o < u; o++) { var f = this.offsets[o]; e.offsets.push({ start: f.start, index: f.index, count: f.count }) } return e }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }; THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype); THREE.Camera = function () { THREE.Object3D.call(this); this.matrixWorldInverse = new THREE.Matrix4; this.projectionMatrix = new THREE.Matrix4; this.projectionMatrixInverse = new THREE.Matrix4 }; THREE.Camera.prototype = Object.create(THREE.Object3D.prototype); THREE.Camera.prototype.lookAt = function () { var e = new THREE.Matrix4; return function (t) { e.lookAt(this.position, t, this.up); this.quaternion.setFromRotationMatrix(e) } }(); THREE.Camera.prototype.clone = function (e) { if (e === undefined) e = new THREE.Camera; THREE.Object3D.prototype.clone.call(this, e); e.matrixWorldInverse.copy(this.matrixWorldInverse); e.projectionMatrix.copy(this.projectionMatrix); e.projectionMatrixInverse.copy(this.projectionMatrixInverse); return e }; THREE.OrthographicCamera = function (e, t, n, r, i, s) { THREE.Camera.call(this); this.left = e; this.right = t; this.top = n; this.bottom = r; this.near = i !== undefined ? i : .1; this.far = s !== undefined ? s : 2e3; this.updateProjectionMatrix() }; THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype); THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () { this.projectionMatrix.makeOrthographic(this.left, this.right, this.top, this.bottom, this.near, this.far) }; THREE.OrthographicCamera.prototype.clone = function () { var e = new THREE.OrthographicCamera; THREE.Camera.prototype.clone.call(this, e); e.left = this.left; e.right = this.right; e.top = this.top; e.bottom = this.bottom; e.near = this.near; e.far = this.far; return e }; THREE.PerspectiveCamera = function (e, t, n, r) { THREE.Camera.call(this); this.fov = e !== undefined ? e : 50; this.aspect = t !== undefined ? t : 1; this.near = n !== undefined ? n : .1; this.far = r !== undefined ? r : 2e3; this.updateProjectionMatrix() }; THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype); THREE.PerspectiveCamera.prototype.setLens = function (e, t) { if (t === undefined) t = 24; this.fov = 2 * THREE.Math.radToDeg(Math.atan(t / (e * 2))); this.updateProjectionMatrix() }; THREE.PerspectiveCamera.prototype.setViewOffset = function (e, t, n, r, i, s) { this.fullWidth = e; this.fullHeight = t; this.x = n; this.y = r; this.width = i; this.height = s; this.updateProjectionMatrix() }; THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () { if (this.fullWidth) { var e = this.fullWidth / this.fullHeight; var t = Math.tan(THREE.Math.degToRad(this.fov * .5)) * this.near; var n = -t; var r = e * n; var i = e * t; var s = Math.abs(i - r); var o = Math.abs(t - n); this.projectionMatrix.makeFrustum(r + this.x * s / this.fullWidth, r + (this.x + this.width) * s / this.fullWidth, t - (this.y + this.height) * o / this.fullHeight, t - this.y * o / this.fullHeight, this.near, this.far) } else { this.projectionMatrix.makePerspective(this.fov, this.aspect, this.near, this.far) } }; THREE.PerspectiveCamera.prototype.clone = function () { var e = new THREE.PerspectiveCamera; THREE.Camera.prototype.clone.call(this, e); e.fov = this.fov; e.aspect = this.aspect; e.near = this.near; e.far = this.far; return e }; THREE.Light = function (e) { THREE.Object3D.call(this); this.color = new THREE.Color(e) }; THREE.Light.prototype = Object.create(THREE.Object3D.prototype); THREE.Light.prototype.clone = function (e) { if (e === undefined) e = new THREE.Light; THREE.Object3D.prototype.clone.call(this, e); e.color.copy(this.color); return e }; THREE.AmbientLight = function (e) { THREE.Light.call(this, e) }; THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype); THREE.AmbientLight.prototype.clone = function () { var e = new THREE.AmbientLight; THREE.Light.prototype.clone.call(this, e); return e }; THREE.AreaLight = function (e, t) { THREE.Light.call(this, e); this.normal = new THREE.Vector3(0, -1, 0); this.right = new THREE.Vector3(1, 0, 0); this.intensity = t !== undefined ? t : 1; this.width = 1; this.height = 1; this.constantAttenuation = 1.5; this.linearAttenuation = .5; this.quadraticAttenuation = .1 }; THREE.AreaLight.prototype = Object.create(THREE.Light.prototype); THREE.DirectionalLight = function (e, t) { THREE.Light.call(this, e); this.position.set(0, 1, 0); this.target = new THREE.Object3D; this.intensity = t !== undefined ? t : 1; this.castShadow = false; this.onlyShadow = false; this.shadowCameraNear = 50; this.shadowCameraFar = 5e3; this.shadowCameraLeft = -500; this.shadowCameraRight = 500; this.shadowCameraTop = 500; this.shadowCameraBottom = -500; this.shadowCameraVisible = false; this.shadowBias = 0; this.shadowDarkness = .5; this.shadowMapWidth = 512; this.shadowMapHeight = 512; this.shadowCascade = false; this.shadowCascadeOffset = new THREE.Vector3(0, 0, -1e3); this.shadowCascadeCount = 2; this.shadowCascadeBias = [0, 0, 0]; this.shadowCascadeWidth = [512, 512, 512]; this.shadowCascadeHeight = [512, 512, 512]; this.shadowCascadeNearZ = [-1, .99, .998]; this.shadowCascadeFarZ = [.99, .998, 1]; this.shadowCascadeArray = []; this.shadowMap = null; this.shadowMapSize = null; this.shadowCamera = null; this.shadowMatrix = null }; THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype); THREE.DirectionalLight.prototype.clone = function () { var e = new THREE.DirectionalLight; THREE.Light.prototype.clone.call(this, e); e.target = this.target.clone(); e.intensity = this.intensity; e.castShadow = this.castShadow; e.onlyShadow = this.onlyShadow; return e }; THREE.PointLight = function (e, t, n) { THREE.Light.call(this, e); this.intensity = t !== undefined ? t : 1; this.distance = n !== undefined ? n : 0 }; THREE.PointLight.prototype = Object.create(THREE.Light.prototype); THREE.PointLight.prototype.clone = function () { var e = new THREE.PointLight; THREE.Light.prototype.clone.call(this, e); e.intensity = this.intensity; e.distance = this.distance; return e }; THREE.Loader = function (e) { this.showStatus = e; this.statusDomElement = e ? THREE.Loader.prototype.addStatusElement() : null; this.onLoadStart = function () { }; this.onLoadProgress = function () { }; this.onLoadComplete = function () { } }; THREE.Loader.prototype = { constructor: THREE.Loader, crossOrigin: "anonymous", addStatusElement: function () { var e = document.createElement("div"); e.style.position = "absolute"; e.style.right = "0px"; e.style.top = "0px"; e.style.fontSize = "0.8em"; e.style.textAlign = "left"; e.style.background = "rgba(0,0,0,0.25)"; e.style.color = "#fff"; e.style.width = "120px"; e.style.padding = "0.5em 0.5em 0.5em 0.5em"; e.style.zIndex = 1e3; e.innerHTML = "Loading ..."; return e }, updateProgress: function (e) { var t = "Loaded "; if (e.total) { t += (100 * e.loaded / e.total).toFixed(0) + "%" } else { t += (e.loaded / 1e3).toFixed(2) + " KB" } this.statusDomElement.innerHTML = t }, extractUrlBase: function (e) { var t = e.split("/"); t.pop(); return (t.length < 1 ? "." : t.join("/")) + "/" }, initMaterials: function (e, t) { var n = []; for (var r = 0; r < e.length; ++r) { n[r] = THREE.Loader.prototype.createMaterial(e[r], t) } return n }, needsTangents: function (e) { for (var t = 0, n = e.length; t < n; t++) { var r = e[t]; if (r instanceof THREE.ShaderMaterial) return true } return false }, createMaterial: function (e, t) { function r(e) { var t = Math.log(e) / Math.LN2; return Math.floor(t) == t } function i(e) { var t = Math.log(e) / Math.LN2; return Math.pow(2, Math.round(t)) } function s(e, t) { var s = new Image; s.onload = function () { if (!r(this.width) || !r(this.height)) { var t = i(this.width); var n = i(this.height); e.image.width = t; e.image.height = n; e.image.getContext("2d").drawImage(this, 0, 0, t, n) } else { e.image = this } e.needsUpdate = true }; s.crossOrigin = n.crossOrigin; s.src = t } function o(e, n, r, i, o, u, a) { var f = /\.dds$/i.test(r); var l = t + "/" + r; if (f) { var c = THREE.ImageUtils.loadCompressedTexture(l); e[n] = c } else { var c = document.createElement("canvas"); e[n] = new THREE.Texture(c) } e[n].sourceFile = r; if (i) { e[n].repeat.set(i[0], i[1]); if (i[0] !== 1) e[n].wrapS = THREE.RepeatWrapping; if (i[1] !== 1) e[n].wrapT = THREE.RepeatWrapping } if (o) { e[n].offset.set(o[0], o[1]) } if (u) { var h = { repeat: THREE.RepeatWrapping, mirror: THREE.MirroredRepeatWrapping }; if (h[u[0]] !== undefined) e[n].wrapS = h[u[0]]; if (h[u[1]] !== undefined) e[n].wrapT = h[u[1]] } if (a) { e[n].anisotropy = a } if (!f) { s(e[n], l) } } function u(e) { return (e[0] * 255 << 16) + (e[1] * 255 << 8) + e[2] * 255 } var n = this; var a = "MeshLambertMaterial"; var f = { color: 15658734, opacity: 1, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false }; if (e.shading) { var l = e.shading.toLowerCase(); if (l === "phong") a = "MeshPhongMaterial"; else if (l === "basic") a = "MeshBasicMaterial" } if (e.blending !== undefined && THREE[e.blending] !== undefined) { f.blending = THREE[e.blending] } if (e.transparent !== undefined || e.opacity < 1) { f.transparent = e.transparent } if (e.depthTest !== undefined) { f.depthTest = e.depthTest } if (e.depthWrite !== undefined) { f.depthWrite = e.depthWrite } if (e.visible !== undefined) { f.visible = e.visible } if (e.flipSided !== undefined) { f.side = THREE.BackSide } if (e.doubleSided !== undefined) { f.side = THREE.DoubleSide } if (e.wireframe !== undefined) { f.wireframe = e.wireframe } if (e.vertexColors !== undefined) { if (e.vertexColors === "face") { f.vertexColors = THREE.FaceColors } else if (e.vertexColors) { f.vertexColors = THREE.VertexColors } } if (e.colorDiffuse) { f.color = u(e.colorDiffuse) } else if (e.DbgColor) { f.color = e.DbgColor } if (e.colorSpecular) { f.specular = u(e.colorSpecular) } if (e.colorAmbient) { f.ambient = u(e.colorAmbient) } if (e.transparency) { f.opacity = e.transparency } if (e.specularCoef) { f.shininess = e.specularCoef } if (e.mapDiffuse && t) { o(f, "map", e.mapDiffuse, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy) } if (e.mapLight && t) { o(f, "lightMap", e.mapLight, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy) } if (e.mapBump && t) { o(f, "bumpMap", e.mapBump, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy) } if (e.mapNormal && t) { o(f, "normalMap", e.mapNormal, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy) } if (e.mapSpecular && t) { o(f, "specularMap", e.mapSpecular, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy) } if (e.mapBumpScale) { f.bumpScale = e.mapBumpScale } if (e.mapNormal) { var c = THREE.ShaderLib["normalmap"]; var h = THREE.UniformsUtils.clone(c.uniforms); h["tNormal"].value = f.normalMap; if (e.mapNormalFactor) { h["uNormalScale"].value.set(e.mapNormalFactor, e.mapNormalFactor) } if (f.map) { h["tDiffuse"].value = f.map; h["enableDiffuse"].value = true } if (f.specularMap) { h["tSpecular"].value = f.specularMap; h["enableSpecular"].value = true } if (f.lightMap) { h["tAO"].value = f.lightMap; h["enableAO"].value = true } h["uDiffuseColor"].value.setHex(f.color); h["uSpecularColor"].value.setHex(f.specular); h["uAmbientColor"].value.setHex(f.ambient); h["uShininess"].value = f.shininess; if (f.opacity !== undefined) { h["uOpacity"].value = f.opacity } var p = { fragmentShader: c.fragmentShader, vertexShader: c.vertexShader, uniforms: h, lights: true, fog: true }; var d = new THREE.ShaderMaterial(p); if (f.transparent) { d.transparent = true } } else { var d = new THREE[a](f) } if (e.DbgName !== undefined) d.name = e.DbgName; return d } }; THREE.XHRLoader = function (e) { this.manager = e !== undefined ? e : THREE.DefaultLoadingManager }; THREE.XHRLoader.prototype = { constructor: THREE.XHRLoader, load: function (e, t, n, r) { var i = this; var s = new XMLHttpRequest; if (t !== undefined) { s.addEventListener("load", function (n) { t(n.target.responseText); i.manager.itemEnd(e) }, false) } if (n !== undefined) { s.addEventListener("progress", function (e) { n(e) }, false) } if (r !== undefined) { s.addEventListener("error", function (e) { r(e) }, false) } if (this.crossOrigin !== undefined) s.crossOrigin = this.crossOrigin; s.open("GET", e, true); s.send(null); i.manager.itemStart(e) }, setCrossOrigin: function (e) { this.crossOrigin = e } }; THREE.ImageLoader = function (e) { this.manager = e !== undefined ? e : THREE.DefaultLoadingManager }; THREE.ImageLoader.prototype = { constructor: THREE.ImageLoader, load: function (e, t, n, r) { var i = this; var s = document.createElement("img"); if (t !== undefined) { s.addEventListener("load", function (n) { i.manager.itemEnd(e); t(this) }, false) } if (n !== undefined) { s.addEventListener("progress", function (e) { n(e) }, false) } if (r !== undefined) { s.addEventListener("error", function (e) { r(e) }, false) } if (this.crossOrigin !== undefined) s.crossOrigin = this.crossOrigin; s.src = e; i.manager.itemStart(e); return s }, setCrossOrigin: function (e) { this.crossOrigin = e } }; THREE.LoadingManager = function (e, t, n) { var r = this; var i = 0, s = 0; this.onLoad = e; this.onProgress = t; this.onError = n; this.itemStart = function (e) { s++ }; this.itemEnd = function (e) { i++; if (r.onProgress !== undefined) { r.onProgress(e, i, s) } if (i === s && r.onLoad !== undefined) { r.onLoad() } } }; THREE.DefaultLoadingManager = new THREE.LoadingManager; THREE.BufferGeometryLoader = function (e) { this.manager = e !== undefined ? e : THREE.DefaultLoadingManager }; THREE.BufferGeometryLoader.prototype = { constructor: THREE.BufferGeometryLoader, load: function (e, t, n, r) { var i = this; var s = new THREE.XHRLoader; s.setCrossOrigin(this.crossOrigin); s.load(e, function (e) { t(i.parse(JSON.parse(e))) }) }, setCrossOrigin: function (e) { this.crossOrigin = e }, parse: function (e) { var t = new THREE.BufferGeometry; var n = e.attributes; var r = e.offsets; var i = e.boundingSphere; for (var s in n) { var o = n[s]; t.attributes[s] = { itemSize: o.itemSize, array: new self[o.type](o.array) } } if (r !== undefined) { t.offsets = JSON.parse(JSON.stringify(r)) } if (i !== undefined) { t.boundingSphere = new THREE.Sphere((new THREE.Vector3).fromArray(i.center !== undefined ? i.center : [0, 0, 0]), i.radius) } return t } }; THREE.GeometryLoader = function (e) { this.manager = e !== undefined ? e : THREE.DefaultLoadingManager }; THREE.GeometryLoader.prototype = { constructor: THREE.GeometryLoader, load: function (e, t, n, r) { var i = this; var s = new THREE.XHRLoader; s.setCrossOrigin(this.crossOrigin); s.load(e, function (e) { t(i.parse(JSON.parse(e))) }) }, setCrossOrigin: function (e) { this.crossOrigin = e }, parse: function (e) { } }; THREE.MaterialLoader = function (e) { this.manager = e !== undefined ? e : THREE.DefaultLoadingManager }; THREE.MaterialLoader.prototype = { constructor: THREE.MaterialLoader, load: function (e, t, n, r) { var i = this; var s = new THREE.XHRLoader; s.setCrossOrigin(this.crossOrigin); s.load(e, function (e) { t(i.parse(JSON.parse(e))) }) }, setCrossOrigin: function (e) { this.crossOrigin = e }, parse: function (e) { var t = new THREE[e.type]; if (e.color !== undefined) t.color.setHex(e.color); if (e.ambient !== undefined) t.ambient.setHex(e.ambient); if (e.emissive !== undefined) t.emissive.setHex(e.emissive); if (e.specular !== undefined) t.specular.setHex(e.specular); if (e.shininess !== undefined) t.shininess = e.shininess; if (e.vertexColors !== undefined) t.vertexColors = e.vertexColors; if (e.blending !== undefined) t.blending = e.blending; if (e.opacity !== undefined) t.opacity = e.opacity; if (e.transparent !== undefined) t.transparent = e.transparent; if (e.wireframe !== undefined) t.wireframe = e.wireframe; if (e.materials !== undefined) { for (var n = 0, r = e.materials.length; n < r; n++) { t.materials.push(this.parse(e.materials[n])) } } return t } }; THREE.ObjectLoader = function (e) { this.manager = e !== undefined ? e : THREE.DefaultLoadingManager }; THREE.ObjectLoader.prototype = { constructor: THREE.ObjectLoader, load: function (e, t, n, r) { var i = this; var s = new THREE.XHRLoader(i.manager); s.setCrossOrigin(this.crossOrigin); s.load(e, function (e) { t(i.parse(JSON.parse(e))) }) }, setCrossOrigin: function (e) { this.crossOrigin = e }, parse: function (e) { var t = this.parseGeometries(e.geometries); var n = this.parseMaterials(e.materials); var r = this.parseObject(e.object, t, n); return r }, parseGeometries: function (e) { var t = {}; if (e !== undefined) { var n = new THREE.JSONLoader; var r = new THREE.BufferGeometryLoader; for (var i = 0, s = e.length; i < s; i++) { var o; var u = e[i]; switch (u.type) { case "PlaneGeometry": o = new THREE.PlaneGeometry(u.width, u.height, u.widthSegments, u.heightSegments); break; case "CircleGeometry": o = new THREE.CircleGeometry(u.radius, u.segments); break; case "CubeGeometry": o = new THREE.CubeGeometry(u.width, u.height, u.depth, u.widthSegments, u.heightSegments, u.depthSegments); break; case "CylinderGeometry": o = new THREE.CylinderGeometry(u.radiusTop, u.radiusBottom, u.height, u.radiusSegments, u.heightSegments, u.openEnded); break; case "SphereGeometry": o = new THREE.SphereGeometry(u.radius, u.widthSegments, u.heightSegments, u.phiStart, u.phiLength, u.thetaStart, u.thetaLength); break; case "IcosahedronGeometry": o = new THREE.IcosahedronGeometry(u.radius, u.detail); break; case "TorusGeometry": o = new THREE.TorusGeometry(u.radius, u.tube, u.radialSegments, u.tubularSegments, u.arc); break; case "TorusKnotGeometry": o = new THREE.TorusKnotGeometry(u.radius, u.tube, u.radialSegments, u.tubularSegments, u.p, u.q, u.heightScale); break; case "BufferGeometry": o = r.parse(u.data); break; case "Geometry": o = n.parse(u.data).geometry; break } o.uuid = u.uuid; if (u.name !== undefined) o.name = u.name; t[u.uuid] = o } } return t }, parseMaterials: function (e) { var t = {}; if (e !== undefined) { var n = new THREE.MaterialLoader; for (var r = 0, i = e.length; r < i; r++) { var s = e[r]; var o = n.parse(s); o.uuid = s.uuid; if (s.name !== undefined) o.name = s.name; t[s.uuid] = o } } return t }, parseObject: function () { var e = new THREE.Matrix4; return function (t, n, r) { var i; switch (t.type) { case "Scene": i = new THREE.Scene; break; case "PerspectiveCamera": i = new THREE.PerspectiveCamera(t.fov, t.aspect, t.near, t.far); break; case "OrthographicCamera": i = new THREE.OrthographicCamera(t.left, t.right, t.top, t.bottom, t.near, t.far); break; case "AmbientLight": i = new THREE.AmbientLight(t.color); break; case "DirectionalLight": i = new THREE.DirectionalLight(t.color, t.intensity); break; case "PointLight": i = new THREE.PointLight(t.color, t.intensity, t.distance); break; case "Mesh": var s = n[t.geometry]; var o = r[t.material]; if (s === undefined) { console.error("THREE.ObjectLoader: Undefined geometry " + t.geometry) } if (o === undefined) { console.error("THREE.ObjectLoader: Undefined material " + t.material) } i = new THREE.Mesh(s, o); break; default: i = new THREE.Object3D } i.uuid = t.uuid; if (t.name !== undefined) i.name = t.name; if (t.matrix !== undefined) { e.fromArray(t.matrix); e.decompose(i.position, i.quaternion, i.scale) } else { if (t.position !== undefined) i.position.fromArray(t.position); if (t.rotation !== undefined) i.rotation.fromArray(t.rotation); if (t.scale !== undefined) i.scale.fromArray(t.scale) } if (t.visible !== undefined) i.visible = t.visible; if (t.userData !== undefined) i.userData = t.userData; if (t.children !== undefined) { for (var u in t.children) { i.add(this.parseObject(t.children[u], n, r)) } } return i } }() }; THREE.SceneLoader = function () { this.onLoadStart = function () { }; this.onLoadProgress = function () { }; this.onLoadComplete = function () { }; this.callbackSync = function () { }; this.callbackProgress = function () { }; this.geometryHandlers = {}; this.hierarchyHandlers = {}; this.addGeometryHandler("ascii", THREE.JSONLoader) }; THREE.SceneLoader.prototype = { constructor: THREE.SceneLoader, load: function (e, t, n, r) { var i = this; var s = new THREE.XHRLoader(i.manager); s.setCrossOrigin(this.crossOrigin); s.load(e, function (n) { i.parse(JSON.parse(n), t, e) }) }, setCrossOrigin: function (e) { this.crossOrigin = e }, addGeometryHandler: function (e, t) { this.geometryHandlers[e] = { loaderClass: t } }, addHierarchyHandler: function (e, t) { this.hierarchyHandlers[e] = { loaderClass: t } }, parse: function (e, t, n) { function k(e, t) { if (t == "relativeToHTML") { return e } else { return i + "/" + e } } function L() { A(b.scene, E.objects) } function A(e, t) { var n, i, a, f, l, c; for (var v in t) { var m = b.objects[v]; var g = t[v]; if (m === undefined) { if (g.type && g.type in r.hierarchyHandlers) { if (g.loading === undefined) { var y = { type: 1, url: 1, material: 1, position: 1, rotation: 1, scale: 1, visible: 1, children: 1, userData: 1, skin: 1, morph: 1, mirroredLoop: 1, duration: 1 }; var S = {}; for (var x in g) { if (!(x in y)) { S[x] = g[x] } } o = b.materials[g.material]; g.loading = true; var T = r.hierarchyHandlers[g.type]["loaderObject"]; if (T.options) { T.load(k(g.url, E.urlBaseType), D(v, e, o, g)) } else { T.load(k(g.url, E.urlBaseType), D(v, e, o, g), S) } } } else if (g.geometry !== undefined) { s = b.geometries[g.geometry]; if (s) { var N = false; o = b.materials[g.material]; N = o instanceof THREE.ShaderMaterial; a = g.position; f = g.rotation; l = g.scale; n = g.matrix; c = g.quaternion; if (!g.material) { o = new THREE.MeshFaceMaterial(b.face_materials[g.geometry]) } if (o instanceof THREE.MeshFaceMaterial && o.materials.length === 0) { o = new THREE.MeshFaceMaterial(b.face_materials[g.geometry]) } if (o instanceof THREE.MeshFaceMaterial) { for (var C = 0; C < o.materials.length; C++) { N = N || o.materials[C] instanceof THREE.ShaderMaterial } } if (N) { s.computeTangents() } if (g.skin) { m = new THREE.SkinnedMesh(s, o) } else if (g.morph) { m = new THREE.MorphAnimMesh(s, o); if (g.duration !== undefined) { m.duration = g.duration } if (g.time !== undefined) { m.time = g.time } if (g.mirroredLoop !== undefined) { m.mirroredLoop = g.mirroredLoop } if (o.morphNormals) { s.computeMorphNormals() } } else { m = new THREE.Mesh(s, o) } m.name = v; if (n) { m.matrixAutoUpdate = false; m.matrix.set(n[0], n[1], n[2], n[3], n[4], n[5], n[6], n[7], n[8], n[9], n[10], n[11], n[12], n[13], n[14], n[15]) } else { m.position.fromArray(a); if (c) { m.quaternion.fromArray(c) } else { m.rotation.fromArray(f) } m.scale.fromArray(l) } m.visible = g.visible; m.castShadow = g.castShadow; m.receiveShadow = g.receiveShadow; e.add(m); b.objects[v] = m } } else if (g.type === "DirectionalLight" || g.type === "PointLight" || g.type === "AmbientLight") { p = g.color !== undefined ? g.color : 16777215; d = g.intensity !== undefined ? g.intensity : 1; if (g.type === "DirectionalLight") { a = g.direction; h = new THREE.DirectionalLight(p, d); h.position.fromArray(a); if (g.target) { w.push({ object: h, targetName: g.target }); h.target = null } } else if (g.type === "PointLight") { a = g.position; i = g.distance; h = new THREE.PointLight(p, d, i); h.position.fromArray(a) } else if (g.type === "AmbientLight") { h = new THREE.AmbientLight(p) } e.add(h); h.name = v; b.lights[v] = h; b.objects[v] = h } else if (g.type === "PerspectiveCamera" || g.type === "OrthographicCamera") { a = g.position; f = g.rotation; c = g.quaternion; if (g.type === "PerspectiveCamera") { u = new THREE.PerspectiveCamera(g.fov, g.aspect, g.near, g.far) } else if (g.type === "OrthographicCamera") { u = new THREE.OrthographicCamera(g.left, g.right, g.top, g.bottom, g.near, g.far) } u.name = v; u.position.fromArray(a); if (c !== undefined) { u.quaternion.fromArray(c) } else if (f !== undefined) { u.rotation.fromArray(f) } e.add(u); b.cameras[v] = u; b.objects[v] = u } else { a = g.position; f = g.rotation; l = g.scale; c = g.quaternion; m = new THREE.Object3D; m.name = v; m.position.fromArray(a); if (c) { m.quaternion.fromArray(c) } else { m.rotation.fromArray(f) } m.scale.fromArray(l); m.visible = g.visible !== undefined ? g.visible : false; e.add(m); b.objects[v] = m; b.empties[v] = m } if (m) { if (g.userData !== undefined) { for (var L in g.userData) { var O = g.userData[L]; m.userData[L] = O } } if (g.groups !== undefined) { for (var C = 0; C < g.groups.length; C++) { var M = g.groups[C]; if (b.groups[M] === undefined) { b.groups[M] = [] } b.groups[M].push(v) } } } } if (m !== undefined && g.children !== undefined) { A(m, g.children) } } } function O(e, t, n) { b.geometries[n] = e; b.face_materials[n] = t; L() } function M(e, t, n, r, i) { var s = i.position; var o = i.rotation; var u = i.quaternion; var a = i.scale; e.position.fromArray(s); if (u) { e.quaternion.fromArray(u) } else { e.rotation.fromArray(o) } e.scale.fromArray(a); if (r) { e.traverse(function (e) { e.material = r }) } var f = i.visible !== undefined ? i.visible : true; e.traverse(function (e) { e.visible = f }); n.add(e); e.name = t; b.objects[t] = e; L() } function _(e) { return function (t, n) { t.name = e; O(t, n, e); v -= 1; r.onLoadComplete(); H() } } function D(e, t, n, i) { return function (s) { var o; if (s.content) { o = s.content } else if (s.dae) { o = s.scene } else { o = s } M(o, e, t, n, i); v -= 1; r.onLoadComplete(); H() } } function P(e) { return function (t, n) { t.name = e; b.geometries[e] = t; b.face_materials[e] = n } } function H() { var e = { totalModels: g, totalTextures: y, loadedModels: g - v, loadedTextures: y - m }; r.callbackProgress(e, b); r.onLoadProgress(); if (v === 0 && m === 0) { B(); t(b) } } function B() { for (var e = 0; e < w.length; e++) { var t = w[e]; var n = b.objects[t.targetName]; if (n) { t.object.target = n } else { t.object.target = new THREE.Object3D; b.scene.add(t.object.target) } t.object.target.userData.targetInverse = t.object } } function I(e, t) { t(e); if (e.children !== undefined) { for (var n in e.children) { I(e.children[n], t) } } } var r = this; var i = THREE.Loader.prototype.extractUrlBase(n); var s, o, u, a, f, l, c, h, p, d, v, m, g, y, b; var w = []; var E = e; for (var S in this.geometryHandlers) { var x = this.geometryHandlers[S]["loaderClass"]; this.geometryHandlers[S]["loaderObject"] = new x } for (var S in this.hierarchyHandlers) { var x = this.hierarchyHandlers[S]["loaderClass"]; this.hierarchyHandlers[S]["loaderObject"] = new x } v = 0; m = 0; b = { scene: new THREE.Scene, geometries: {}, face_materials: {}, materials: {}, textures: {}, objects: {}, cameras: {}, lights: {}, fogs: {}, empties: {}, groups: {} }; if (E.transform) { var T = E.transform.position, N = E.transform.rotation, C = E.transform.scale; if (T) { b.scene.position.fromArray(T) } if (N) { b.scene.rotation.fromArray(N) } if (C) { b.scene.scale.fromArray(C) } if (T || N || C) { b.scene.updateMatrix(); b.scene.updateMatrixWorld() } } var j = function (e) { m -= e; H(); r.onLoadComplete() }; var F = function (e) { return function () { j(e) } }; var q, R; for (q in E.fogs) { R = E.fogs[q]; if (R.type === "linear") { a = new THREE.Fog(0, R.near, R.far) } else if (R.type === "exp2") { a = new THREE.FogExp2(0, R.density) } c = R.color; a.color.setRGB(c[0], c[1], c[2]); b.fogs[q] = a } var U, z; for (U in E.geometries) { z = E.geometries[U]; if (z.type in this.geometryHandlers) { v += 1; r.onLoadStart() } } for (var W in E.objects) { I(E.objects[W], function (e) { if (e.type && e.type in r.hierarchyHandlers) { v += 1; r.onLoadStart() } }) } g = v; for (U in E.geometries) { z = E.geometries[U]; if (z.type === "cube") { s = new THREE.CubeGeometry(z.width, z.height, z.depth, z.widthSegments, z.heightSegments, z.depthSegments); s.name = U; b.geometries[U] = s } else if (z.type === "plane") { s = new THREE.PlaneGeometry(z.width, z.height, z.widthSegments, z.heightSegments); s.name = U; b.geometries[U] = s } else if (z.type === "sphere") { s = new THREE.SphereGeometry(z.radius, z.widthSegments, z.heightSegments); s.name = U; b.geometries[U] = s } else if (z.type === "cylinder") { s = new THREE.CylinderGeometry(z.topRad, z.botRad, z.height, z.radSegs, z.heightSegs); s.name = U; b.geometries[U] = s } else if (z.type === "torus") { s = new THREE.TorusGeometry(z.radius, z.tube, z.segmentsR, z.segmentsT); s.name = U; b.geometries[U] = s } else if (z.type === "icosahedron") { s = new THREE.IcosahedronGeometry(z.radius, z.subdivisions); s.name = U; b.geometries[U] = s } else if (z.type in this.geometryHandlers) { var X = {}; for (var V in z) { if (V !== "type" && V !== "url") { X[V] = z[V] } } var $ = this.geometryHandlers[z.type]["loaderObject"]; $.load(k(z.url, E.urlBaseType), _(U), X) } else if (z.type === "embedded") { var J = E.embeds[z.id], K = ""; J.metadata = E.metadata; if (J) { var Q = this.geometryHandlers["ascii"]["loaderObject"]; var G = Q.parse(J, K); P(U)(G.geometry, G.materials) } } } var Y, Z; for (Y in E.textures) { Z = E.textures[Y]; if (Z.url instanceof Array) { m += Z.url.length; for (var et = 0; et < Z.url.length; et++) { r.onLoadStart() } } else { m += 1; r.onLoadStart() } } y = m; for (Y in E.textures) { Z = E.textures[Y]; if (Z.mapping !== undefined && THREE[Z.mapping] !== undefined) { Z.mapping = new THREE[Z.mapping] } if (Z.url instanceof Array) { var tt = Z.url.length; var nt = []; for (var rt = 0; rt < tt; rt++) { nt[rt] = k(Z.url[rt], E.urlBaseType) } var it = /\.dds$/i.test(nt[0]); if (it) { f = THREE.ImageUtils.loadCompressedTextureCube(nt, Z.mapping, F(tt)) } else { f = THREE.ImageUtils.loadTextureCube(nt, Z.mapping, F(tt)) } } else { var it = /\.dds$/i.test(Z.url); var st = k(Z.url, E.urlBaseType); var ot = F(1); if (it) { f = THREE.ImageUtils.loadCompressedTexture(st, Z.mapping, ot) } else { f = THREE.ImageUtils.loadTexture(st, Z.mapping, ot) } if (THREE[Z.minFilter] !== undefined) f.minFilter = THREE[Z.minFilter]; if (THREE[Z.magFilter] !== undefined) f.magFilter = THREE[Z.magFilter]; if (Z.anisotropy) f.anisotropy = Z.anisotropy; if (Z.repeat) { f.repeat.set(Z.repeat[0], Z.repeat[1]); if (Z.repeat[0] !== 1) f.wrapS = THREE.RepeatWrapping; if (Z.repeat[1] !== 1) f.wrapT = THREE.RepeatWrapping } if (Z.offset) { f.offset.set(Z.offset[0], Z.offset[1]) } if (Z.wrap) { var ut = { repeat: THREE.RepeatWrapping, mirror: THREE.MirroredRepeatWrapping }; if (ut[Z.wrap[0]] !== undefined) f.wrapS = ut[Z.wrap[0]]; if (ut[Z.wrap[1]] !== undefined) f.wrapT = ut[Z.wrap[1]] } } b.textures[Y] = f } var at, ft; var lt; for (at in E.materials) { ft = E.materials[at]; for (lt in ft.parameters) { if (lt === "envMap" || lt === "map" || lt === "lightMap" || lt === "bumpMap") { ft.parameters[lt] = b.textures[ft.parameters[lt]] } else if (lt === "shading") { ft.parameters[lt] = ft.parameters[lt] === "flat" ? THREE.FlatShading : THREE.SmoothShading } else if (lt === "side") { if (ft.parameters[lt] == "double") { ft.parameters[lt] = THREE.DoubleSide } else if (ft.parameters[lt] == "back") { ft.parameters[lt] = THREE.BackSide } else { ft.parameters[lt] = THREE.FrontSide } } else if (lt === "blending") { ft.parameters[lt] = ft.parameters[lt] in THREE ? THREE[ft.parameters[lt]] : THREE.NormalBlending } else if (lt === "combine") { ft.parameters[lt] = ft.parameters[lt] in THREE ? THREE[ft.parameters[lt]] : THREE.MultiplyOperation } else if (lt === "vertexColors") { if (ft.parameters[lt] == "face") { ft.parameters[lt] = THREE.FaceColors } else if (ft.parameters[lt]) { ft.parameters[lt] = THREE.VertexColors } } else if (lt === "wrapRGB") { var ct = ft.parameters[lt]; ft.parameters[lt] = new THREE.Vector3(ct[0], ct[1], ct[2]) } } if (ft.parameters.opacity !== undefined && ft.parameters.opacity < 1) { ft.parameters.transparent = true } if (ft.parameters.normalMap) { var ht = THREE.ShaderLib["normalmap"]; var pt = THREE.UniformsUtils.clone(ht.uniforms); var dt = ft.parameters.color; var vt = ft.parameters.specular; var mt = ft.parameters.ambient; var gt = ft.parameters.shininess; pt["tNormal"].value = b.textures[ft.parameters.normalMap]; if (ft.parameters.normalScale) { pt["uNormalScale"].value.set(ft.parameters.normalScale[0], ft.parameters.normalScale[1]) } if (ft.parameters.map) { pt["tDiffuse"].value = ft.parameters.map; pt["enableDiffuse"].value = true } if (ft.parameters.envMap) { pt["tCube"].value = ft.parameters.envMap; pt["enableReflection"].value = true; pt["uReflectivity"].value = ft.parameters.reflectivity } if (ft.parameters.lightMap) { pt["tAO"].value = ft.parameters.lightMap; pt["enableAO"].value = true } if (ft.parameters.specularMap) { pt["tSpecular"].value = b.textures[ft.parameters.specularMap]; pt["enableSpecular"].value = true } if (ft.parameters.displacementMap) { pt["tDisplacement"].value = b.textures[ft.parameters.displacementMap]; pt["enableDisplacement"].value = true; pt["uDisplacementBias"].value = ft.parameters.displacementBias; pt["uDisplacementScale"].value = ft.parameters.displacementScale } pt["uDiffuseColor"].value.setHex(dt); pt["uSpecularColor"].value.setHex(vt); pt["uAmbientColor"].value.setHex(mt); pt["uShininess"].value = gt; if (ft.parameters.opacity) { pt["uOpacity"].value = ft.parameters.opacity } var yt = { fragmentShader: ht.fragmentShader, vertexShader: ht.vertexShader, uniforms: pt, lights: true, fog: true }; o = new THREE.ShaderMaterial(yt) } else { o = new THREE[ft.type](ft.parameters) } o.name = at; b.materials[at] = o } for (at in E.materials) { ft = E.materials[at]; if (ft.parameters.materials) { var bt = []; for (var rt = 0; rt < ft.parameters.materials.length; rt++) { var wt = ft.parameters.materials[rt]; bt.push(b.materials[wt]) } b.materials[at].materials = bt } } L(); if (b.cameras && E.defaults.camera) { b.currentCamera = b.cameras[E.defaults.camera] } if (b.fogs && E.defaults.fog) { b.scene.fog = b.fogs[E.defaults.fog] } r.callbackSync(b); H() } }; THREE.TextureLoader = function (e) { this.manager = e !== undefined ? e : THREE.DefaultLoadingManager }; THREE.TextureLoader.prototype = { constructor: THREE.TextureLoader, load: function (e, t, n, r) { var i = this; var s = new THREE.ImageLoader(i.manager); s.setCrossOrigin(this.crossOrigin); s.load(e, function (e) { var n = new THREE.Texture(e); n.needsUpdate = true; if (t !== undefined) { t(n) } }) }, setCrossOrigin: function (e) { this.crossOrigin = e } }; THREE.Material = function () { this.id = THREE.MaterialIdCount++; this.uuid = THREE.Math.generateUUID(); this.name = ""; this.side = THREE.FrontSide; this.opacity = 1; this.transparent = false; this.blending = THREE.NormalBlending; this.blendSrc = THREE.SrcAlphaFactor; this.blendDst = THREE.OneMinusSrcAlphaFactor; this.blendEquation = THREE.AddEquation; this.depthTest = true; this.depthWrite = true; this.polygonOffset = false; this.polygonOffsetFactor = 0; this.polygonOffsetUnits = 0; this.alphaTest = 0; this.overdraw = 0; this.visible = true; this.needsUpdate = true }; THREE.Material.prototype = { constructor: THREE.Material, setValues: function (e) { if (e === undefined) return; for (var t in e) { var n = e[t]; if (n === undefined) { console.warn("THREE.Material: '" + t + "' parameter is undefined."); continue } if (t in this) { var r = this[t]; if (r instanceof THREE.Color) { r.set(n) } else if (r instanceof THREE.Vector3 && n instanceof THREE.Vector3) { r.copy(n) } else if (t == "overdraw") { this[t] = Number(n) } else { this[t] = n } } } }, clone: function (e) { if (e === undefined) e = new THREE.Material; e.name = this.name; e.side = this.side; e.opacity = this.opacity; e.transparent = this.transparent; e.blending = this.blending; e.blendSrc = this.blendSrc; e.blendDst = this.blendDst; e.blendEquation = this.blendEquation; e.depthTest = this.depthTest; e.depthWrite = this.depthWrite; e.polygonOffset = this.polygonOffset; e.polygonOffsetFactor = this.polygonOffsetFactor; e.polygonOffsetUnits = this.polygonOffsetUnits; e.alphaTest = this.alphaTest; e.overdraw = this.overdraw; e.visible = this.visible; return e }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }; THREE.EventDispatcher.prototype.apply(THREE.Material.prototype); THREE.MaterialIdCount = 0; THREE.LineBasicMaterial = function (e) { THREE.Material.call(this); this.color = new THREE.Color(16777215); this.linewidth = 1; this.linecap = "round"; this.linejoin = "round"; this.vertexColors = false; this.fog = true; this.setValues(e) }; THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype); THREE.LineBasicMaterial.prototype.clone = function () { var e = new THREE.LineBasicMaterial; THREE.Material.prototype.clone.call(this, e); e.color.copy(this.color); e.linewidth = this.linewidth; e.linecap = this.linecap; e.linejoin = this.linejoin; e.vertexColors = this.vertexColors; e.fog = this.fog; return e }; THREE.LineDashedMaterial = function (e) { THREE.Material.call(this); this.color = new THREE.Color(16777215); this.linewidth = 1; this.scale = 1; this.dashSize = 3; this.gapSize = 1; this.vertexColors = false; this.fog = true; this.setValues(e) }; THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype); THREE.LineDashedMaterial.prototype.clone = function () { var e = new THREE.LineDashedMaterial; THREE.Material.prototype.clone.call(this, e); e.color.copy(this.color); e.linewidth = this.linewidth; e.scale = this.scale; e.dashSize = this.dashSize; e.gapSize = this.gapSize; e.vertexColors = this.vertexColors; e.fog = this.fog; return e }; THREE.MeshBasicMaterial = function (e) { THREE.Material.call(this); this.color = new THREE.Color(16777215); this.map = null; this.lightMap = null; this.specularMap = null; this.envMap = null; this.combine = THREE.MultiplyOperation; this.reflectivity = 1; this.refractionRatio = .98; this.fog = true; this.shading = THREE.SmoothShading; this.wireframe = false; this.wireframeLinewidth = 1; this.wireframeLinecap = "round"; this.wireframeLinejoin = "round"; this.vertexColors = THREE.NoColors; this.skinning = false; this.morphTargets = false; this.setValues(e) }; THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype); THREE.MeshBasicMaterial.prototype.clone = function () { var e = new THREE.MeshBasicMaterial; THREE.Material.prototype.clone.call(this, e); e.color.copy(this.color); e.map = this.map; e.lightMap = this.lightMap; e.specularMap = this.specularMap; e.envMap = this.envMap; e.combine = this.combine; e.reflectivity = this.reflectivity; e.refractionRatio = this.refractionRatio; e.fog = this.fog; e.shading = this.shading; e.wireframe = this.wireframe; e.wireframeLinewidth = this.wireframeLinewidth; e.wireframeLinecap = this.wireframeLinecap; e.wireframeLinejoin = this.wireframeLinejoin; e.vertexColors = this.vertexColors; e.skinning = this.skinning; e.morphTargets = this.morphTargets; return e }; THREE.MeshPhongMaterial = function (e) { THREE.Material.call(this); this.color = new THREE.Color(16777215); this.ambient = new THREE.Color(16777215); this.emissive = new THREE.Color(0); this.specular = new THREE.Color(1118481); this.shininess = 30; this.metal = false; this.perPixel = true; this.wrapAround = false; this.wrapRGB = new THREE.Vector3(1, 1, 1); this.map = null; this.lightMap = null; this.bumpMap = null; this.bumpScale = 1; this.normalMap = null; this.normalScale = new THREE.Vector2(1, 1); this.specularMap = null; this.envMap = null; this.combine = THREE.MultiplyOperation; this.reflectivity = 1; this.refractionRatio = .98; this.fog = true; this.shading = THREE.SmoothShading; this.wireframe = false; this.wireframeLinewidth = 1; this.wireframeLinecap = "round"; this.wireframeLinejoin = "round"; this.vertexColors = THREE.NoColors; this.skinning = false; this.morphTargets = false; this.morphNormals = false; this.setValues(e) }; THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype); THREE.MeshPhongMaterial.prototype.clone = function () { var e = new THREE.MeshPhongMaterial; THREE.Material.prototype.clone.call(this, e); e.color.copy(this.color); e.ambient.copy(this.ambient); e.emissive.copy(this.emissive); e.specular.copy(this.specular); e.shininess = this.shininess; e.metal = this.metal; e.perPixel = this.perPixel; e.wrapAround = this.wrapAround; e.wrapRGB.copy(this.wrapRGB); e.map = this.map; e.lightMap = this.lightMap; e.bumpMap = this.bumpMap; e.bumpScale = this.bumpScale; e.normalMap = this.normalMap; e.normalScale.copy(this.normalScale); e.specularMap = this.specularMap; e.envMap = this.envMap; e.combine = this.combine; e.reflectivity = this.reflectivity; e.refractionRatio = this.refractionRatio; e.fog = this.fog; e.shading = this.shading; e.wireframe = this.wireframe; e.wireframeLinewidth = this.wireframeLinewidth; e.wireframeLinecap = this.wireframeLinecap; e.wireframeLinejoin = this.wireframeLinejoin; e.vertexColors = this.vertexColors; e.skinning = this.skinning; e.morphTargets = this.morphTargets; e.morphNormals = this.morphNormals; return e }; THREE.MeshDepthMaterial = function (e) { THREE.Material.call(this); this.wireframe = false; this.wireframeLinewidth = 1; this.setValues(e) }; THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype); THREE.MeshDepthMaterial.prototype.clone = function () { var e = new THREE.MeshDepthMaterial; THREE.Material.prototype.clone.call(this, e); e.wireframe = this.wireframe; e.wireframeLinewidth = this.wireframeLinewidth; return e }; THREE.MeshNormalMaterial = function (e) { THREE.Material.call(this, e); this.shading = THREE.FlatShading; this.wireframe = false; this.wireframeLinewidth = 1; this.morphTargets = false; this.setValues(e) }; THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype); THREE.MeshNormalMaterial.prototype.clone = function () { var e = new THREE.MeshNormalMaterial; THREE.Material.prototype.clone.call(this, e); e.shading = this.shading; e.wireframe = this.wireframe; e.wireframeLinewidth = this.wireframeLinewidth; return e }; THREE.MeshFaceMaterial = function (e) { this.materials = e instanceof Array ? e : [] }; THREE.MeshFaceMaterial.prototype.clone = function () { var e = new THREE.MeshFaceMaterial; for (var t = 0; t < this.materials.length; t++) { e.materials.push(this.materials[t].clone()) } return e }; THREE.ShaderMaterial = function (e) { THREE.Material.call(this); this.fragmentShader = "void main() {}"; this.vertexShader = "void main() {}"; this.uniforms = {}; this.defines = {}; this.attributes = null; this.shading = THREE.SmoothShading; this.linewidth = 1; this.wireframe = false; this.wireframeLinewidth = 1; this.fog = false; this.lights = false; this.vertexColors = THREE.NoColors; this.skinning = false; this.morphTargets = false; this.morphNormals = false; this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }; this.index0AttributeName = "position"; this.setValues(e) }; THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype); THREE.ShaderMaterial.prototype.clone = function () { var e = new THREE.ShaderMaterial; THREE.Material.prototype.clone.call(this, e); e.fragmentShader = this.fragmentShader; e.vertexShader = this.vertexShader; e.uniforms = THREE.UniformsUtils.clone(this.uniforms); e.attributes = this.attributes; e.defines = this.defines; e.shading = this.shading; e.wireframe = this.wireframe; e.wireframeLinewidth = this.wireframeLinewidth; e.fog = this.fog; e.lights = this.lights; e.vertexColors = this.vertexColors; e.skinning = this.skinning; e.morphTargets = this.morphTargets; e.morphNormals = this.morphNormals; return e }; THREE.Texture = function (e, t, n, r, i, s, o, u, a) { this.id = THREE.TextureIdCount++; this.uuid = THREE.Math.generateUUID(); this.name = ""; this.image = e; this.mipmaps = []; this.mapping = t !== undefined ? t : new THREE.UVMapping; this.wrapS = n !== undefined ? n : THREE.ClampToEdgeWrapping; this.wrapT = r !== undefined ? r : THREE.ClampToEdgeWrapping; this.magFilter = i !== undefined ? i : THREE.LinearFilter; this.minFilter = s !== undefined ? s : THREE.LinearMipMapLinearFilter; this.anisotropy = a !== undefined ? a : 1; this.format = o !== undefined ? o : THREE.RGBAFormat; this.type = u !== undefined ? u : THREE.UnsignedByteType; this.offset = new THREE.Vector2(0, 0); this.repeat = new THREE.Vector2(1, 1); this.generateMipmaps = true; this.premultiplyAlpha = false; this.flipY = true; this.unpackAlignment = 4; this.needsUpdate = false; this.onUpdate = null }; THREE.Texture.prototype = { constructor: THREE.Texture, clone: function (e) { if (e === undefined) e = new THREE.Texture; e.image = this.image; e.mipmaps = this.mipmaps.slice(0); e.mapping = this.mapping; e.wrapS = this.wrapS; e.wrapT = this.wrapT; e.magFilter = this.magFilter; e.minFilter = this.minFilter; e.anisotropy = this.anisotropy; e.format = this.format; e.type = this.type; e.offset.copy(this.offset); e.repeat.copy(this.repeat); e.generateMipmaps = this.generateMipmaps; e.premultiplyAlpha = this.premultiplyAlpha; e.flipY = this.flipY; e.unpackAlignment = this.unpackAlignment; return e }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }; THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype); THREE.TextureIdCount = 0; THREE.CompressedTexture = function (e, t, n, r, i, s, o, u, a, f, l) { THREE.Texture.call(this, null, s, o, u, a, f, r, i, l); this.image = { width: t, height: n }; this.mipmaps = e; this.generateMipmaps = false }; THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype); THREE.CompressedTexture.prototype.clone = function () { var e = new THREE.CompressedTexture; THREE.Texture.prototype.clone.call(this, e); return e }; THREE.DataTexture = function (e, t, n, r, i, s, o, u, a, f, l) { THREE.Texture.call(this, null, s, o, u, a, f, r, i, l); this.image = { data: e, width: t, height: n } }; THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype); THREE.DataTexture.prototype.clone = function () { var e = new THREE.DataTexture; THREE.Texture.prototype.clone.call(this, e); return e }; THREE.Particle = function (e) { THREE.Object3D.call(this); this.material = e }; THREE.Particle.prototype = Object.create(THREE.Object3D.prototype); THREE.Particle.prototype.clone = function (e) { if (e === undefined) e = new THREE.Particle(this.material); THREE.Object3D.prototype.clone.call(this, e); return e }; THREE.ParticleSystem = function (e, t) { THREE.Object3D.call(this); this.geometry = e !== undefined ? e : new THREE.Geometry; this.material = t !== undefined ? t : new THREE.ParticleBasicMaterial({ color: Math.random() * 16777215 }); this.sortParticles = false; this.frustumCulled = false }; THREE.ParticleSystem.prototype = Object.create(THREE.Object3D.prototype); THREE.ParticleSystem.prototype.clone = function (e) { if (e === undefined) e = new THREE.ParticleSystem(this.geometry, this.material); e.sortParticles = this.sortParticles; THREE.Object3D.prototype.clone.call(this, e); return e }; THREE.Line = function (e, t, n) { THREE.Object3D.call(this); this.geometry = e !== undefined ? e : new THREE.Geometry; this.material = t !== undefined ? t : new THREE.LineBasicMaterial({ color: Math.random() * 16777215 }); this.type = n !== undefined ? n : THREE.LineStrip }; THREE.LineStrip = 0; THREE.LinePieces = 1; THREE.Line.prototype = Object.create(THREE.Object3D.prototype); THREE.Line.prototype.clone = function (e) { if (e === undefined) e = new THREE.Line(this.geometry, this.material, this.type); THREE.Object3D.prototype.clone.call(this, e); return e }; THREE.Mesh = function (e, t) { THREE.Object3D.call(this); this.geometry = e !== undefined ? e : new THREE.Geometry; this.material = t !== undefined ? t : new THREE.MeshBasicMaterial({ color: Math.random() * 16777215 }); this.updateMorphTargets() }; THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype); THREE.Mesh.prototype.updateMorphTargets = function () { if (this.geometry.morphTargets.length > 0) { this.morphTargetBase = -1; this.morphTargetForcedOrder = []; this.morphTargetInfluences = []; this.morphTargetDictionary = {}; for (var e = 0, t = this.geometry.morphTargets.length; e < t; e++) { this.morphTargetInfluences.push(0); this.morphTargetDictionary[this.geometry.morphTargets[e].name] = e } } }; THREE.Mesh.prototype.getMorphTargetIndexByName = function (e) { if (this.morphTargetDictionary[e] !== undefined) { return this.morphTargetDictionary[e] } console.log("THREE.Mesh.getMorphTargetIndexByName: morph target " + e + " does not exist. Returning 0."); return 0 }; THREE.Mesh.prototype.clone = function (e) { if (e === undefined) e = new THREE.Mesh(this.geometry, this.material); THREE.Object3D.prototype.clone.call(this, e); return e }; THREE.Scene = function () { THREE.Object3D.call(this); this.fog = null; this.overrideMaterial = null; this.autoUpdate = true; this.matrixAutoUpdate = false; this.__lights = []; this.__objectsAdded = []; this.__objectsRemoved = [] }; THREE.Scene.prototype = Object.create(THREE.Object3D.prototype); THREE.Scene.prototype.__addObject = function (e) { if (e instanceof THREE.Light) { if (this.__lights.indexOf(e) === -1) { this.__lights.push(e) } if (e.target && e.target.parent === undefined) { this.add(e.target) } } else if (!(e instanceof THREE.Camera)) { this.__objectsAdded.push(e); var t = this.__objectsRemoved.indexOf(e); if (t !== -1) { this.__objectsRemoved.splice(t, 1) } } for (var n = 0; n < e.children.length; n++) { this.__addObject(e.children[n]) } }; THREE.Scene.prototype.__removeObject = function (e) { if (e instanceof THREE.Light) { var t = this.__lights.indexOf(e); if (t !== -1) { this.__lights.splice(t, 1) } if (e.shadowCascadeArray) { for (var n = 0; n < e.shadowCascadeArray.length; n++) { this.__removeObject(e.shadowCascadeArray[n]) } } } else if (!(e instanceof THREE.Camera)) { this.__objectsRemoved.push(e); var t = this.__objectsAdded.indexOf(e); if (t !== -1) { this.__objectsAdded.splice(t, 1) } } for (var r = 0; r < e.children.length; r++) { this.__removeObject(e.children[r]) } }; THREE.ShaderChunk = { fog_pars_fragment: ["#ifdef USE_FOG", "uniform vec3 fogColor;", "#ifdef FOG_EXP2", "uniform float fogDensity;", "#else", "uniform float fogNear;", "uniform float fogFar;", "#endif", "#endif"].join("\n"), fog_fragment: ["#ifdef USE_FOG", "float depth = gl_FragCoord.z / gl_FragCoord.w;", "#ifdef FOG_EXP2", "const float LOG2 = 1.442695;", "float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );", "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "#else", "float fogFactor = smoothstep( fogNear, fogFar, depth );", "#endif", "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );", "#endif"].join("\n"), envmap_pars_fragment: ["#ifdef USE_ENVMAP", "uniform float reflectivity;", "uniform samplerCube envMap;", "uniform float flipEnvMap;", "uniform int combine;", "#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )", "uniform bool useRefract;", "uniform float refractionRatio;", "#else", "varying vec3 vReflect;", "#endif", "#endif"].join("\n"), envmap_fragment: ["#ifdef USE_ENVMAP", "vec3 reflectVec;", "#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )", "vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );", "if ( useRefract ) {", "reflectVec = refract( cameraToVertex, normal, refractionRatio );", "} else { ", "reflectVec = reflect( cameraToVertex, normal );", "}", "#else", "reflectVec = vReflect;", "#endif", "#ifdef DOUBLE_SIDED", "float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );", "vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );", "#else", "vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );", "#endif", "#ifdef GAMMA_INPUT", "cubeColor.xyz *= cubeColor.xyz;", "#endif", "if ( combine == 1 ) {", "gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );", "} else if ( combine == 2 ) {", "gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;", "} else {", "gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );", "}", "#endif"].join("\n"), envmap_pars_vertex: ["#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )", "varying vec3 vReflect;", "uniform float refractionRatio;", "uniform bool useRefract;", "#endif"].join("\n"), worldpos_vertex: ["#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )", "#ifdef USE_SKINNING", "vec4 worldPosition = modelMatrix * skinned;", "#endif", "#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )", "vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );", "#endif", "#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )", "vec4 worldPosition = modelMatrix * vec4( position, 1.0 );", "#endif", "#endif"].join("\n"), envmap_vertex: ["#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )", "vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;", "worldNormal = normalize( worldNormal );", "vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );", "if ( useRefract ) {", "vReflect = refract( cameraToVertex, worldNormal, refractionRatio );", "} else {", "vReflect = reflect( cameraToVertex, worldNormal );", "}", "#endif"].join("\n"), map_particle_pars_fragment: ["#ifdef USE_MAP", "uniform sampler2D map;", "#endif"].join("\n"), map_particle_fragment: ["#ifdef USE_MAP", "gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );", "#endif"].join("\n"), map_pars_vertex: ["#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )", "varying vec2 vUv;", "uniform vec4 offsetRepeat;", "#endif"].join("\n"), map_pars_fragment: ["#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )", "varying vec2 vUv;", "#endif", "#ifdef USE_MAP", "uniform sampler2D map;", "#endif"].join("\n"), map_vertex: ["#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )", "vUv = uv * offsetRepeat.zw + offsetRepeat.xy;", "#endif"].join("\n"), map_fragment: ["#ifdef USE_MAP", "vec4 texelColor = texture2D( map, vUv );", "#ifdef GAMMA_INPUT", "texelColor.xyz *= texelColor.xyz;", "#endif", "gl_FragColor = gl_FragColor * texelColor;", "#endif"].join("\n"), lightmap_pars_fragment: ["#ifdef USE_LIGHTMAP", "varying vec2 vUv2;", "uniform sampler2D lightMap;", "#endif"].join("\n"), lightmap_pars_vertex: ["#ifdef USE_LIGHTMAP", "varying vec2 vUv2;", "#endif"].join("\n"), lightmap_fragment: ["#ifdef USE_LIGHTMAP", "gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );", "#endif"].join("\n"), lightmap_vertex: ["#ifdef USE_LIGHTMAP", "vUv2 = uv2;", "#endif"].join("\n"), bumpmap_pars_fragment: ["#ifdef USE_BUMPMAP", "uniform sampler2D bumpMap;", "uniform float bumpScale;", "vec2 dHdxy_fwd() {", "vec2 dSTdx = dFdx( vUv );", "vec2 dSTdy = dFdy( vUv );", "float Hll = bumpScale * texture2D( bumpMap, vUv ).x;", "float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;", "float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;", "return vec2( dBx, dBy );", "}", "vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {", "vec3 vSigmaX = dFdx( surf_pos );", "vec3 vSigmaY = dFdy( surf_pos );", "vec3 vN = surf_norm;", "vec3 R1 = cross( vSigmaY, vN );", "vec3 R2 = cross( vN, vSigmaX );", "float fDet = dot( vSigmaX, R1 );", "vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );", "return normalize( abs( fDet ) * surf_norm - vGrad );", "}", "#endif"].join("\n"), normalmap_pars_fragment: ["#ifdef USE_NORMALMAP", "uniform sampler2D normalMap;", "uniform vec2 normalScale;", "vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {", "vec3 q0 = dFdx( eye_pos.xyz );", "vec3 q1 = dFdy( eye_pos.xyz );", "vec2 st0 = dFdx( vUv.st );", "vec2 st1 = dFdy( vUv.st );", "vec3 S = normalize(  q0 * st1.t - q1 * st0.t );", "vec3 T = normalize( -q0 * st1.s + q1 * st0.s );", "vec3 N = normalize( surf_norm );", "vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;", "mapN.xy = normalScale * mapN.xy;", "mat3 tsn = mat3( S, T, N );", "return normalize( tsn * mapN );", "}", "#endif"].join("\n"), specularmap_pars_fragment: ["#ifdef USE_SPECULARMAP", "uniform sampler2D specularMap;", "#endif"].join("\n"), specularmap_fragment: ["float specularStrength;", "#ifdef USE_SPECULARMAP", "vec4 texelSpecular = texture2D( specularMap, vUv );", "specularStrength = texelSpecular.r;", "#else", "specularStrength = 1.0;", "#endif"].join("\n"), lights_lambert_pars_vertex: ["uniform vec3 ambient;", "uniform vec3 diffuse;", "uniform vec3 emissive;", "uniform vec3 ambientLightColor;", "#if MAX_DIR_LIGHTS > 0", "uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];", "uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];", "#endif", "#if MAX_HEMI_LIGHTS > 0", "uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];", "uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];", "uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];", "#endif", "#if MAX_POINT_LIGHTS > 0", "uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];", "uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];", "uniform float pointLightDistance[ MAX_POINT_LIGHTS ];", "#endif", "#if MAX_SPOT_LIGHTS > 0", "uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];", "uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];", "uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];", "uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];", "uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];", "uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];", "#endif", "#ifdef WRAP_AROUND", "uniform vec3 wrapRGB;", "#endif"].join("\n"), lights_lambert_vertex: ["vLightFront = vec3( 0.0 );", "#ifdef DOUBLE_SIDED", "vLightBack = vec3( 0.0 );", "#endif", "transformedNormal = normalize( transformedNormal );", "#if MAX_DIR_LIGHTS > 0", "for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {", "vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );", "vec3 dirVector = normalize( lDirection.xyz );", "float dotProduct = dot( transformedNormal, dirVector );", "vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );", "#ifdef DOUBLE_SIDED", "vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );", "#ifdef WRAP_AROUND", "vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );", "#endif", "#endif", "#ifdef WRAP_AROUND", "vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );", "directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );", "#ifdef DOUBLE_SIDED", "directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );", "#endif", "#endif", "vLightFront += directionalLightColor[ i ] * directionalLightWeighting;", "#ifdef DOUBLE_SIDED", "vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;", "#endif", "}", "#endif", "#if MAX_POINT_LIGHTS > 0", "for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {", "vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );", "vec3 lVector = lPosition.xyz - mvPosition.xyz;", "float lDistance = 1.0;", "if ( pointLightDistance[ i ] > 0.0 )", "lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );", "lVector = normalize( lVector );", "float dotProduct = dot( transformedNormal, lVector );", "vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );", "#ifdef DOUBLE_SIDED", "vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );", "#ifdef WRAP_AROUND", "vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );", "#endif", "#endif", "#ifdef WRAP_AROUND", "vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );", "pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );", "#ifdef DOUBLE_SIDED", "pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );", "#endif", "#endif", "vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;", "#ifdef DOUBLE_SIDED", "vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;", "#endif", "}", "#endif", "#if MAX_SPOT_LIGHTS > 0", "for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {", "vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );", "vec3 lVector = lPosition.xyz - mvPosition.xyz;", "float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );", "if ( spotEffect > spotLightAngleCos[ i ] ) {", "spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );", "float lDistance = 1.0;", "if ( spotLightDistance[ i ] > 0.0 )", "lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );", "lVector = normalize( lVector );", "float dotProduct = dot( transformedNormal, lVector );", "vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );", "#ifdef DOUBLE_SIDED", "vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );", "#ifdef WRAP_AROUND", "vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );", "#endif", "#endif", "#ifdef WRAP_AROUND", "vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );", "spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );", "#ifdef DOUBLE_SIDED", "spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );", "#endif", "#endif", "vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;", "#ifdef DOUBLE_SIDED", "vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;", "#endif", "}", "}", "#endif", "#if MAX_HEMI_LIGHTS > 0", "for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {", "vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );", "vec3 lVector = normalize( lDirection.xyz );", "float dotProduct = dot( transformedNormal, lVector );", "float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;", "float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;", "vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );", "#ifdef DOUBLE_SIDED", "vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );", "#endif", "}", "#endif", "vLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;", "#ifdef DOUBLE_SIDED", "vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;", "#endif"].join("\n"), lights_phong_pars_vertex: ["#ifndef PHONG_PER_PIXEL", "#if MAX_POINT_LIGHTS > 0", "uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];", "uniform float pointLightDistance[ MAX_POINT_LIGHTS ];", "varying vec4 vPointLight[ MAX_POINT_LIGHTS ];", "#endif", "#if MAX_SPOT_LIGHTS > 0", "uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];", "uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];", "varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];", "#endif", "#endif", "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )", "varying vec3 vWorldPosition;", "#endif"].join("\n"), lights_phong_vertex: ["#ifndef PHONG_PER_PIXEL", "#if MAX_POINT_LIGHTS > 0", "for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {", "vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );", "vec3 lVector = lPosition.xyz - mvPosition.xyz;", "float lDistance = 1.0;", "if ( pointLightDistance[ i ] > 0.0 )", "lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );", "vPointLight[ i ] = vec4( lVector, lDistance );", "}", "#endif", "#if MAX_SPOT_LIGHTS > 0", "for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {", "vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );", "vec3 lVector = lPosition.xyz - mvPosition.xyz;", "float lDistance = 1.0;", "if ( spotLightDistance[ i ] > 0.0 )", "lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );", "vSpotLight[ i ] = vec4( lVector, lDistance );", "}", "#endif", "#endif", "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )", "vWorldPosition = worldPosition.xyz;", "#endif"].join("\n"), lights_phong_pars_fragment: ["uniform vec3 ambientLightColor;", "#if MAX_DIR_LIGHTS > 0", "uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];", "uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];", "#endif", "#if MAX_HEMI_LIGHTS > 0", "uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];", "uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];", "uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];", "#endif", "#if MAX_POINT_LIGHTS > 0", "uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];", "#ifdef PHONG_PER_PIXEL", "uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];", "uniform float pointLightDistance[ MAX_POINT_LIGHTS ];", "#else", "varying vec4 vPointLight[ MAX_POINT_LIGHTS ];", "#endif", "#endif", "#if MAX_SPOT_LIGHTS > 0", "uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];", "uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];", "uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];", "uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];", "uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];", "#ifdef PHONG_PER_PIXEL", "uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];", "#else", "varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];", "#endif", "#endif", "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )", "varying vec3 vWorldPosition;", "#endif", "#ifdef WRAP_AROUND", "uniform vec3 wrapRGB;", "#endif", "varying vec3 vViewPosition;", "varying vec3 vNormal;"].join("\n"), lights_phong_fragment: ["vec3 normal = normalize( vNormal );", "vec3 viewPosition = normalize( vViewPosition );", "#ifdef DOUBLE_SIDED", "normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );", "#endif", "#ifdef USE_NORMALMAP", "normal = perturbNormal2Arb( -vViewPosition, normal );", "#elif defined( USE_BUMPMAP )", "normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );", "#endif", "#if MAX_POINT_LIGHTS > 0", "vec3 pointDiffuse  = vec3( 0.0 );", "vec3 pointSpecular = vec3( 0.0 );", "for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {", "#ifdef PHONG_PER_PIXEL", "vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );", "vec3 lVector = lPosition.xyz + vViewPosition.xyz;", "float lDistance = 1.0;", "if ( pointLightDistance[ i ] > 0.0 )", "lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );", "lVector = normalize( lVector );", "#else", "vec3 lVector = normalize( vPointLight[ i ].xyz );", "float lDistance = vPointLight[ i ].w;", "#endif", "float dotProduct = dot( normal, lVector );", "#ifdef WRAP_AROUND", "float pointDiffuseWeightFull = max( dotProduct, 0.0 );", "float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );", "vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );", "#else", "float pointDiffuseWeight = max( dotProduct, 0.0 );", "#endif", "pointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;", "vec3 pointHalfVector = normalize( lVector + viewPosition );", "float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );", "float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );", "#ifdef PHYSICALLY_BASED_SHADING", "float specularNormalization = ( shininess + 2.0001 ) / 8.0;", "vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, pointHalfVector ), 5.0 );", "pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;", "#else", "pointSpecular += specular * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance;", "#endif", "}", "#endif", "#if MAX_SPOT_LIGHTS > 0", "vec3 spotDiffuse  = vec3( 0.0 );", "vec3 spotSpecular = vec3( 0.0 );", "for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {", "#ifdef PHONG_PER_PIXEL", "vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );", "vec3 lVector = lPosition.xyz + vViewPosition.xyz;", "float lDistance = 1.0;", "if ( spotLightDistance[ i ] > 0.0 )", "lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );", "lVector = normalize( lVector );", "#else", "vec3 lVector = normalize( vSpotLight[ i ].xyz );", "float lDistance = vSpotLight[ i ].w;", "#endif", "float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );", "if ( spotEffect > spotLightAngleCos[ i ] ) {", "spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );", "float dotProduct = dot( normal, lVector );", "#ifdef WRAP_AROUND", "float spotDiffuseWeightFull = max( dotProduct, 0.0 );", "float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );", "vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );", "#else", "float spotDiffuseWeight = max( dotProduct, 0.0 );", "#endif", "spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;", "vec3 spotHalfVector = normalize( lVector + viewPosition );", "float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );", "float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );", "#ifdef PHYSICALLY_BASED_SHADING", "float specularNormalization = ( shininess + 2.0001 ) / 8.0;", "vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, spotHalfVector ), 5.0 );", "spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;", "#else", "spotSpecular += specular * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * spotEffect;", "#endif", "}", "}", "#endif", "#if MAX_DIR_LIGHTS > 0", "vec3 dirDiffuse  = vec3( 0.0 );", "vec3 dirSpecular = vec3( 0.0 );", "for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {", "vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );", "vec3 dirVector = normalize( lDirection.xyz );", "float dotProduct = dot( normal, dirVector );", "#ifdef WRAP_AROUND", "float dirDiffuseWeightFull = max( dotProduct, 0.0 );", "float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );", "vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );", "#else", "float dirDiffuseWeight = max( dotProduct, 0.0 );", "#endif", "dirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;", "vec3 dirHalfVector = normalize( dirVector + viewPosition );", "float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );", "float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );", "#ifdef PHYSICALLY_BASED_SHADING", "float specularNormalization = ( shininess + 2.0001 ) / 8.0;", "vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );", "dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;", "#else", "dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight;", "#endif", "}", "#endif", "#if MAX_HEMI_LIGHTS > 0", "vec3 hemiDiffuse  = vec3( 0.0 );", "vec3 hemiSpecular = vec3( 0.0 );", "for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {", "vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );", "vec3 lVector = normalize( lDirection.xyz );", "float dotProduct = dot( normal, lVector );", "float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;", "vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );", "hemiDiffuse += diffuse * hemiColor;", "vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );", "float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;", "float hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );", "vec3 lVectorGround = -lVector;", "vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );", "float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;", "float hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );", "#ifdef PHYSICALLY_BASED_SHADING", "float dotProductGround = dot( normal, lVectorGround );", "float specularNormalization = ( shininess + 2.0001 ) / 8.0;", "vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );", "vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );", "hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );", "#else", "hemiSpecular += specular * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;", "#endif", "}", "#endif", "vec3 totalDiffuse = vec3( 0.0 );", "vec3 totalSpecular = vec3( 0.0 );", "#if MAX_DIR_LIGHTS > 0", "totalDiffuse += dirDiffuse;", "totalSpecular += dirSpecular;", "#endif", "#if MAX_HEMI_LIGHTS > 0", "totalDiffuse += hemiDiffuse;", "totalSpecular += hemiSpecular;", "#endif", "#if MAX_POINT_LIGHTS > 0", "totalDiffuse += pointDiffuse;", "totalSpecular += pointSpecular;", "#endif", "#if MAX_SPOT_LIGHTS > 0", "totalDiffuse += spotDiffuse;", "totalSpecular += spotSpecular;", "#endif", "#ifdef METAL", "gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );", "#else", "gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;", "#endif"].join("\n"), color_pars_fragment: ["#ifdef USE_COLOR", "varying vec3 vColor;", "#endif"].join("\n"), color_fragment: ["#ifdef USE_COLOR", "gl_FragColor = gl_FragColor * vec4( vColor, opacity );", "#endif"].join("\n"), color_pars_vertex: ["#ifdef USE_COLOR", "varying vec3 vColor;", "#endif"].join("\n"), color_vertex: ["#ifdef USE_COLOR", "#ifdef GAMMA_INPUT", "vColor = color * color;", "#else", "vColor = color;", "#endif", "#endif"].join("\n"), skinning_pars_vertex: ["#ifdef USE_SKINNING", "#ifdef BONE_TEXTURE", "uniform sampler2D boneTexture;", "uniform int boneTextureWidth;", "uniform int boneTextureHeight;", "mat4 getBoneMatrix( const in float i ) {", "float j = i * 4.0;", "float x = mod( j, float( boneTextureWidth ) );", "float y = floor( j / float( boneTextureWidth ) );", "float dx = 1.0 / float( boneTextureWidth );", "float dy = 1.0 / float( boneTextureHeight );", "y = dy * ( y + 0.5 );", "vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );", "vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );", "vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );", "vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );", "mat4 bone = mat4( v1, v2, v3, v4 );", "return bone;", "}", "#else", "uniform mat4 boneGlobalMatrices[ MAX_BONES ];", "mat4 getBoneMatrix( const in float i ) {", "mat4 bone = boneGlobalMatrices[ int(i) ];", "return bone;", "}", "#endif", "#endif"].join("\n"), skinbase_vertex: ["#ifdef USE_SKINNING", "mat4 boneMatX = getBoneMatrix( skinIndex.x );", "mat4 boneMatY = getBoneMatrix( skinIndex.y );", "#endif"].join("\n"), skinning_vertex: ["#ifdef USE_SKINNING", "#ifdef USE_MORPHTARGETS", "vec4 skinVertex = vec4( morphed, 1.0 );", "#else", "vec4 skinVertex = vec4( position, 1.0 );", "#endif", "vec4 skinned  = boneMatX * skinVertex * skinWeight.x;", "skinned 	  += boneMatY * skinVertex * skinWeight.y;", "#endif"].join("\n"), morphtarget_pars_vertex: ["#ifdef USE_MORPHTARGETS", "#ifndef USE_MORPHNORMALS", "uniform float morphTargetInfluences[ 8 ];", "#else", "uniform float morphTargetInfluences[ 4 ];", "#endif", "#endif"].join("\n"), morphtarget_vertex: ["#ifdef USE_MORPHTARGETS", "vec3 morphed = vec3( 0.0 );", "morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];", "morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];", "morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];", "morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];", "#ifndef USE_MORPHNORMALS", "morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];", "morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];", "morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];", "morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];", "#endif", "morphed += position;", "#endif"].join("\n"), default_vertex: ["vec4 mvPosition;", "#ifdef USE_SKINNING", "mvPosition = modelViewMatrix * skinned;", "#endif", "#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )", "mvPosition = modelViewMatrix * vec4( morphed, 1.0 );", "#endif", "#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )", "mvPosition = modelViewMatrix * vec4( position, 1.0 );", "#endif", "gl_Position = projectionMatrix * mvPosition;"].join("\n"), morphnormal_vertex: ["#ifdef USE_MORPHNORMALS", "vec3 morphedNormal = vec3( 0.0 );", "morphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];", "morphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];", "morphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];", "morphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];", "morphedNormal += normal;", "#endif"].join("\n"), skinnormal_vertex: ["#ifdef USE_SKINNING", "mat4 skinMatrix = skinWeight.x * boneMatX;", "skinMatrix 	+= skinWeight.y * boneMatY;", "#ifdef USE_MORPHNORMALS", "vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );", "#else", "vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );", "#endif", "#endif"].join("\n"), defaultnormal_vertex: ["vec3 objectNormal;", "#ifdef USE_SKINNING", "objectNormal = skinnedNormal.xyz;", "#endif", "#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )", "objectNormal = morphedNormal;", "#endif", "#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )", "objectNormal = normal;", "#endif", "#ifdef FLIP_SIDED", "objectNormal = -objectNormal;", "#endif", "vec3 transformedNormal = normalMatrix * objectNormal;"].join("\n"), shadowmap_pars_fragment: ["#ifdef USE_SHADOWMAP", "uniform sampler2D shadowMap[ MAX_SHADOWS ];", "uniform vec2 shadowMapSize[ MAX_SHADOWS ];", "uniform float shadowDarkness[ MAX_SHADOWS ];", "uniform float shadowBias[ MAX_SHADOWS ];", "varying vec4 vShadowCoord[ MAX_SHADOWS ];", "float unpackDepth( const in vec4 rgba_depth ) {", "const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );", "float depth = dot( rgba_depth, bit_shift );", "return depth;", "}", "#endif"].join("\n"), shadowmap_fragment: ["#ifdef USE_SHADOWMAP", "#ifdef SHADOWMAP_DEBUG", "vec3 frustumColors[3];", "frustumColors[0] = vec3( 1.0, 0.5, 0.0 );", "frustumColors[1] = vec3( 0.0, 1.0, 0.8 );", "frustumColors[2] = vec3( 0.0, 0.5, 1.0 );", "#endif", "#ifdef SHADOWMAP_CASCADE", "int inFrustumCount = 0;", "#endif", "float fDepth;", "vec3 shadowColor = vec3( 1.0 );", "for( int i = 0; i < MAX_SHADOWS; i ++ ) {", "vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;", "bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );", "bool inFrustum = all( inFrustumVec );", "#ifdef SHADOWMAP_CASCADE", "inFrustumCount += int( inFrustum );", "bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );", "#else", "bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );", "#endif", "bool frustumTest = all( frustumTestVec );", "if ( frustumTest ) {", "shadowCoord.z += shadowBias[ i ];", "#if defined( SHADOWMAP_TYPE_PCF )", "float shadow = 0.0;", "const float shadowDelta = 1.0 / 9.0;", "float xPixelOffset = 1.0 / shadowMapSize[ i ].x;", "float yPixelOffset = 1.0 / shadowMapSize[ i ].y;", "float dx0 = -1.25 * xPixelOffset;", "float dy0 = -1.25 * yPixelOffset;", "float dx1 = 1.25 * xPixelOffset;", "float dy1 = 1.25 * yPixelOffset;", "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );", "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;", "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );", "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;", "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );", "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;", "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );", "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;", "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );", "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;", "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );", "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;", "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );", "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;", "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );", "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;", "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );", "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;", "shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );", "#elif defined( SHADOWMAP_TYPE_PCF_SOFT )", "float shadow = 0.0;", "float xPixelOffset = 1.0 / shadowMapSize[ i ].x;", "float yPixelOffset = 1.0 / shadowMapSize[ i ].y;", "float dx0 = -1.0 * xPixelOffset;", "float dy0 = -1.0 * yPixelOffset;", "float dx1 = 1.0 * xPixelOffset;", "float dy1 = 1.0 * yPixelOffset;", "mat3 shadowKernel;", "mat3 depthKernel;", "depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );", "depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );", "depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );", "depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );", "depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );", "depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );", "depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );", "depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );", "depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );", "vec3 shadowZ = vec3( shadowCoord.z );", "shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));", "shadowKernel[0] *= vec3(0.25);", "shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));", "shadowKernel[1] *= vec3(0.25);", "shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));", "shadowKernel[2] *= vec3(0.25);", "vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );", "shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );", "shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );", "vec4 shadowValues;", "shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );", "shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );", "shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );", "shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );", "shadow = dot( shadowValues, vec4( 1.0 ) );", "shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );", "#else", "vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );", "float fDepth = unpackDepth( rgbaDepth );", "if ( fDepth < shadowCoord.z )", "shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );", "#endif", "}", "#ifdef SHADOWMAP_DEBUG", "#ifdef SHADOWMAP_CASCADE", "if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];", "#else", "if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];", "#endif", "#endif", "}", "#ifdef GAMMA_OUTPUT", "shadowColor *= shadowColor;", "#endif", "gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;", "#endif"].join("\n"), shadowmap_pars_vertex: ["#ifdef USE_SHADOWMAP", "varying vec4 vShadowCoord[ MAX_SHADOWS ];", "uniform mat4 shadowMatrix[ MAX_SHADOWS ];", "#endif"].join("\n"), shadowmap_vertex: ["#ifdef USE_SHADOWMAP", "for( int i = 0; i < MAX_SHADOWS; i ++ ) {", "vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;", "}", "#endif"].join("\n"), alphatest_fragment: ["#ifdef ALPHATEST", "if ( gl_FragColor.a < ALPHATEST ) discard;", "#endif"].join("\n"), linear_to_gamma_fragment: ["#ifdef GAMMA_OUTPUT", "gl_FragColor.xyz = sqrt( gl_FragColor.xyz );", "#endif"].join("\n") }; THREE.UniformsUtils = { merge: function (e) { var t, n, r, i = {}; for (t = 0; t < e.length; t++) { r = this.clone(e[t]); for (n in r) { i[n] = r[n] } } return i }, clone: function (e) { var t, n, r, i, s = {}; for (t in e) { s[t] = {}; for (n in e[t]) { i = e[t][n]; if (i instanceof THREE.Color || i instanceof THREE.Vector2 || i instanceof THREE.Vector3 || i instanceof THREE.Vector4 || i instanceof THREE.Matrix4 || i instanceof THREE.Texture) { s[t][n] = i.clone() } else if (i instanceof Array) { s[t][n] = i.slice() } else { s[t][n] = i } } } return s } }; THREE.UniformsLib = { common: { diffuse: { type: "c", value: new THREE.Color(15658734) }, opacity: { type: "f", value: 1 }, map: { type: "t", value: null }, offsetRepeat: { type: "v4", value: new THREE.Vector4(0, 0, 1, 1) }, lightMap: { type: "t", value: null }, specularMap: { type: "t", value: null }, envMap: { type: "t", value: null }, flipEnvMap: { type: "f", value: -1 }, useRefract: { type: "i", value: 0 }, reflectivity: { type: "f", value: 1 }, refractionRatio: { type: "f", value: .98 }, combine: { type: "i", value: 0 }, morphTargetInfluences: { type: "f", value: 0 } }, bump: { bumpMap: { type: "t", value: null }, bumpScale: { type: "f", value: 1 } }, normalmap: { normalMap: { type: "t", value: null }, normalScale: { type: "v2", value: new THREE.Vector2(1, 1) } }, fog: { fogDensity: { type: "f", value: 25e-5 }, fogNear: { type: "f", value: 1 }, fogFar: { type: "f", value: 2e3 }, fogColor: { type: "c", value: new THREE.Color(16777215) } }, lights: { ambientLightColor: { type: "fv", value: [] }, directionalLightDirection: { type: "fv", value: [] }, directionalLightColor: { type: "fv", value: [] }, hemisphereLightDirection: { type: "fv", value: [] }, hemisphereLightSkyColor: { type: "fv", value: [] }, hemisphereLightGroundColor: { type: "fv", value: [] }, pointLightColor: { type: "fv", value: [] }, pointLightPosition: { type: "fv", value: [] }, pointLightDistance: { type: "fv1", value: [] }, spotLightColor: { type: "fv", value: [] }, spotLightPosition: { type: "fv", value: [] }, spotLightDirection: { type: "fv", value: [] }, spotLightDistance: { type: "fv1", value: [] }, spotLightAngleCos: { type: "fv1", value: [] }, spotLightExponent: { type: "fv1", value: [] } }, particle: { psColor: { type: "c", value: new THREE.Color(15658734) }, opacity: { type: "f", value: 1 }, size: { type: "f", value: 1 }, scale: { type: "f", value: 1 }, map: { type: "t", value: null }, fogDensity: { type: "f", value: 25e-5 }, fogNear: { type: "f", value: 1 }, fogFar: { type: "f", value: 2e3 }, fogColor: { type: "c", value: new THREE.Color(16777215) } }, shadowmap: { shadowMap: { type: "tv", value: [] }, shadowMapSize: { type: "v2v", value: [] }, shadowBias: { type: "fv1", value: [] }, shadowDarkness: { type: "fv1", value: [] }, shadowMatrix: { type: "m4v", value: [] } } }; THREE.ShaderLib = { basic: { uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib["common"], THREE.UniformsLib["fog"], THREE.UniformsLib["shadowmap"]]), vertexShader: [THREE.ShaderChunk["map_pars_vertex"], THREE.ShaderChunk["lightmap_pars_vertex"], THREE.ShaderChunk["envmap_pars_vertex"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], THREE.ShaderChunk["shadowmap_pars_vertex"], "void main() {", THREE.ShaderChunk["map_vertex"], THREE.ShaderChunk["lightmap_vertex"], THREE.ShaderChunk["color_vertex"], THREE.ShaderChunk["skinbase_vertex"], "#ifdef USE_ENVMAP", THREE.ShaderChunk["morphnormal_vertex"], THREE.ShaderChunk["skinnormal_vertex"], THREE.ShaderChunk["defaultnormal_vertex"], "#endif", THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["default_vertex"], THREE.ShaderChunk["worldpos_vertex"], THREE.ShaderChunk["envmap_vertex"], THREE.ShaderChunk["shadowmap_vertex"], "}"].join("\n"), fragmentShader: ["uniform vec3 diffuse;", "uniform float opacity;", THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["map_pars_fragment"], THREE.ShaderChunk["lightmap_pars_fragment"], THREE.ShaderChunk["envmap_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["shadowmap_pars_fragment"], THREE.ShaderChunk["specularmap_pars_fragment"], "void main() {", "gl_FragColor = vec4( diffuse, opacity );", THREE.ShaderChunk["map_fragment"], THREE.ShaderChunk["alphatest_fragment"], THREE.ShaderChunk["specularmap_fragment"], THREE.ShaderChunk["lightmap_fragment"], THREE.ShaderChunk["color_fragment"], THREE.ShaderChunk["envmap_fragment"], THREE.ShaderChunk["shadowmap_fragment"], THREE.ShaderChunk["linear_to_gamma_fragment"], THREE.ShaderChunk["fog_fragment"], "}"].join("\n") }, phong: { uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib["common"], THREE.UniformsLib["bump"], THREE.UniformsLib["normalmap"], THREE.UniformsLib["fog"], THREE.UniformsLib["lights"], THREE.UniformsLib["shadowmap"], { ambient: { type: "c", value: new THREE.Color(16777215) }, emissive: { type: "c", value: new THREE.Color(0) }, specular: { type: "c", value: new THREE.Color(1118481) }, shininess: { type: "f", value: 30 }, wrapRGB: { type: "v3", value: new THREE.Vector3(1, 1, 1) } }]), vertexShader: ["#define PHONG", "varying vec3 vViewPosition;", "varying vec3 vNormal;", THREE.ShaderChunk["map_pars_vertex"], THREE.ShaderChunk["lightmap_pars_vertex"], THREE.ShaderChunk["envmap_pars_vertex"], THREE.ShaderChunk["lights_phong_pars_vertex"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], THREE.ShaderChunk["shadowmap_pars_vertex"], "void main() {", THREE.ShaderChunk["map_vertex"], THREE.ShaderChunk["lightmap_vertex"], THREE.ShaderChunk["color_vertex"], THREE.ShaderChunk["morphnormal_vertex"], THREE.ShaderChunk["skinbase_vertex"], THREE.ShaderChunk["skinnormal_vertex"], THREE.ShaderChunk["defaultnormal_vertex"], "vNormal = normalize( transformedNormal );", THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["default_vertex"], "vViewPosition = -mvPosition.xyz;", THREE.ShaderChunk["worldpos_vertex"], THREE.ShaderChunk["envmap_vertex"], THREE.ShaderChunk["lights_phong_vertex"], THREE.ShaderChunk["shadowmap_vertex"], "}"].join("\n"), fragmentShader: ["uniform vec3 diffuse;", "uniform float opacity;", "uniform vec3 ambient;", "uniform vec3 emissive;", "uniform vec3 specular;", "uniform float shininess;", THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["map_pars_fragment"], THREE.ShaderChunk["lightmap_pars_fragment"], THREE.ShaderChunk["envmap_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["lights_phong_pars_fragment"], THREE.ShaderChunk["shadowmap_pars_fragment"], THREE.ShaderChunk["bumpmap_pars_fragment"], THREE.ShaderChunk["normalmap_pars_fragment"], THREE.ShaderChunk["specularmap_pars_fragment"], "void main() {", "gl_FragColor = vec4( vec3 ( 1.0 ), opacity );", THREE.ShaderChunk["map_fragment"], THREE.ShaderChunk["alphatest_fragment"], THREE.ShaderChunk["specularmap_fragment"], THREE.ShaderChunk["lights_phong_fragment"], THREE.ShaderChunk["lightmap_fragment"], THREE.ShaderChunk["color_fragment"], THREE.ShaderChunk["envmap_fragment"], THREE.ShaderChunk["shadowmap_fragment"], THREE.ShaderChunk["linear_to_gamma_fragment"], THREE.ShaderChunk["fog_fragment"], "}"].join("\n") }, depth: { uniforms: { mNear: { type: "f", value: 1 }, mFar: { type: "f", value: 2e3 }, opacity: { type: "f", value: 1 } }, vertexShader: ["void main() {", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"), fragmentShader: ["uniform float mNear;", "uniform float mFar;", "uniform float opacity;", "void main() {", "float depth = gl_FragCoord.z / gl_FragCoord.w;", "float color = 1.0 - smoothstep( mNear, mFar, depth );", "gl_FragColor = vec4( vec3( color ), opacity );", "}"].join("\n") }, normal: { uniforms: { opacity: { type: "f", value: 1 } }, vertexShader: ["varying vec3 vNormal;", THREE.ShaderChunk["morphtarget_pars_vertex"], "void main() {", "vNormal = normalize( normalMatrix * normal );", THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["default_vertex"], "}"].join("\n"), fragmentShader: ["uniform float opacity;", "varying vec3 vNormal;", "void main() {", "gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );", "}"].join("\n") }, normalmap: { uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib["fog"], THREE.UniformsLib["lights"], THREE.UniformsLib["shadowmap"], { enableAO: { type: "i", value: 0 }, enableDiffuse: { type: "i", value: 0 }, enableSpecular: { type: "i", value: 0 }, enableReflection: { type: "i", value: 0 }, enableDisplacement: { type: "i", value: 0 }, tDisplacement: { type: "t", value: null }, tDiffuse: { type: "t", value: null }, tCube: { type: "t", value: null }, tNormal: { type: "t", value: null }, tSpecular: { type: "t", value: null }, tAO: { type: "t", value: null }, uNormalScale: { type: "v2", value: new THREE.Vector2(1, 1) }, uDisplacementBias: { type: "f", value: 0 }, uDisplacementScale: { type: "f", value: 1 }, uDiffuseColor: { type: "c", value: new THREE.Color(16777215) }, uSpecularColor: { type: "c", value: new THREE.Color(1118481) }, uAmbientColor: { type: "c", value: new THREE.Color(16777215) }, uShininess: { type: "f", value: 30 }, uOpacity: { type: "f", value: 1 }, useRefract: { type: "i", value: 0 }, uRefractionRatio: { type: "f", value: .98 }, uReflectivity: { type: "f", value: .5 }, uOffset: { type: "v2", value: new THREE.Vector2(0, 0) }, uRepeat: { type: "v2", value: new THREE.Vector2(1, 1) }, wrapRGB: { type: "v3", value: new THREE.Vector3(1, 1, 1) } }]), fragmentShader: ["uniform vec3 uAmbientColor;", "uniform vec3 uDiffuseColor;", "uniform vec3 uSpecularColor;", "uniform float uShininess;", "uniform float uOpacity;", "uniform bool enableDiffuse;", "uniform bool enableSpecular;", "uniform bool enableAO;", "uniform bool enableReflection;", "uniform sampler2D tDiffuse;", "uniform sampler2D tNormal;", "uniform sampler2D tSpecular;", "uniform sampler2D tAO;", "uniform samplerCube tCube;", "uniform vec2 uNormalScale;", "uniform bool useRefract;", "uniform float uRefractionRatio;", "uniform float uReflectivity;", "varying vec3 vTangent;", "varying vec3 vBinormal;", "varying vec3 vNormal;", "varying vec2 vUv;", "uniform vec3 ambientLightColor;", "#if MAX_DIR_LIGHTS > 0", "uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];", "uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];", "#endif", "#if MAX_HEMI_LIGHTS > 0", "uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];", "uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];", "uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];", "#endif", "#if MAX_POINT_LIGHTS > 0", "uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];", "uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];", "uniform float pointLightDistance[ MAX_POINT_LIGHTS ];", "#endif", "#if MAX_SPOT_LIGHTS > 0", "uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];", "uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];", "uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];", "uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];", "uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];", "uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];", "#endif", "#ifdef WRAP_AROUND", "uniform vec3 wrapRGB;", "#endif", "varying vec3 vWorldPosition;", "varying vec3 vViewPosition;", THREE.ShaderChunk["shadowmap_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], "void main() {", "gl_FragColor = vec4( vec3( 1.0 ), uOpacity );", "vec3 specularTex = vec3( 1.0 );", "vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;", "normalTex.xy *= uNormalScale;", "normalTex = normalize( normalTex );", "if( enableDiffuse ) {", "#ifdef GAMMA_INPUT", "vec4 texelColor = texture2D( tDiffuse, vUv );", "texelColor.xyz *= texelColor.xyz;", "gl_FragColor = gl_FragColor * texelColor;", "#else", "gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );", "#endif", "}", "if( enableAO ) {", "#ifdef GAMMA_INPUT", "vec4 aoColor = texture2D( tAO, vUv );", "aoColor.xyz *= aoColor.xyz;", "gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;", "#else", "gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;", "#endif", "}", "if( enableSpecular )", "specularTex = texture2D( tSpecular, vUv ).xyz;", "mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );", "vec3 finalNormal = tsb * normalTex;", "#ifdef FLIP_SIDED", "finalNormal = -finalNormal;", "#endif", "vec3 normal = normalize( finalNormal );", "vec3 viewPosition = normalize( vViewPosition );", "#if MAX_POINT_LIGHTS > 0", "vec3 pointDiffuse = vec3( 0.0 );", "vec3 pointSpecular = vec3( 0.0 );", "for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {", "vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );", "vec3 pointVector = lPosition.xyz + vViewPosition.xyz;", "float pointDistance = 1.0;", "if ( pointLightDistance[ i ] > 0.0 )", "pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );", "pointVector = normalize( pointVector );", "#ifdef WRAP_AROUND", "float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );", "float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );", "vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );", "#else", "float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );", "#endif", "pointDiffuse += pointDistance * pointLightColor[ i ] * uDiffuseColor * pointDiffuseWeight;", "vec3 pointHalfVector = normalize( pointVector + viewPosition );", "float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );", "float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, uShininess ), 0.0 );", "#ifdef PHYSICALLY_BASED_SHADING", "float specularNormalization = ( uShininess + 2.0001 ) / 8.0;", "vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );", "pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;", "#else", "pointSpecular += pointDistance * pointLightColor[ i ] * uSpecularColor * pointSpecularWeight * pointDiffuseWeight;", "#endif", "}", "#endif", "#if MAX_SPOT_LIGHTS > 0", "vec3 spotDiffuse = vec3( 0.0 );", "vec3 spotSpecular = vec3( 0.0 );", "for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {", "vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );", "vec3 spotVector = lPosition.xyz + vViewPosition.xyz;", "float spotDistance = 1.0;", "if ( spotLightDistance[ i ] > 0.0 )", "spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );", "spotVector = normalize( spotVector );", "float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );", "if ( spotEffect > spotLightAngleCos[ i ] ) {", "spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );", "#ifdef WRAP_AROUND", "float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );", "float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );", "vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );", "#else", "float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );", "#endif", "spotDiffuse += spotDistance * spotLightColor[ i ] * uDiffuseColor * spotDiffuseWeight * spotEffect;", "vec3 spotHalfVector = normalize( spotVector + viewPosition );", "float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );", "float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, uShininess ), 0.0 );", "#ifdef PHYSICALLY_BASED_SHADING", "float specularNormalization = ( uShininess + 2.0001 ) / 8.0;", "vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );", "spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;", "#else", "spotSpecular += spotDistance * spotLightColor[ i ] * uSpecularColor * spotSpecularWeight * spotDiffuseWeight * spotEffect;", "#endif", "}", "}", "#endif", "#if MAX_DIR_LIGHTS > 0", "vec3 dirDiffuse = vec3( 0.0 );", "vec3 dirSpecular = vec3( 0.0 );", "for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {", "vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );", "vec3 dirVector = normalize( lDirection.xyz );", "#ifdef WRAP_AROUND", "float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );", "float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );", "vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );", "#else", "float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );", "#endif", "dirDiffuse += directionalLightColor[ i ] * uDiffuseColor * dirDiffuseWeight;", "vec3 dirHalfVector = normalize( dirVector + viewPosition );", "float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );", "float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, uShininess ), 0.0 );", "#ifdef PHYSICALLY_BASED_SHADING", "float specularNormalization = ( uShininess + 2.0001 ) / 8.0;", "vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );", "dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;", "#else", "dirSpecular += directionalLightColor[ i ] * uSpecularColor * dirSpecularWeight * dirDiffuseWeight;", "#endif", "}", "#endif", "#if MAX_HEMI_LIGHTS > 0", "vec3 hemiDiffuse  = vec3( 0.0 );", "vec3 hemiSpecular = vec3( 0.0 );", "for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {", "vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );", "vec3 lVector = normalize( lDirection.xyz );", "float dotProduct = dot( normal, lVector );", "float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;", "vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );", "hemiDiffuse += uDiffuseColor * hemiColor;", "vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );", "float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;", "float hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, uShininess ), 0.0 );", "vec3 lVectorGround = -lVector;", "vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );", "float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;", "float hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, uShininess ), 0.0 );", "#ifdef PHYSICALLY_BASED_SHADING", "float dotProductGround = dot( normal, lVectorGround );", "float specularNormalization = ( uShininess + 2.0001 ) / 8.0;", "vec3 schlickSky = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );", "vec3 schlickGround = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );", "hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );", "#else", "hemiSpecular += uSpecularColor * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;", "#endif", "}", "#endif", "vec3 totalDiffuse = vec3( 0.0 );", "vec3 totalSpecular = vec3( 0.0 );", "#if MAX_DIR_LIGHTS > 0", "totalDiffuse += dirDiffuse;", "totalSpecular += dirSpecular;", "#endif", "#if MAX_HEMI_LIGHTS > 0", "totalDiffuse += hemiDiffuse;", "totalSpecular += hemiSpecular;", "#endif", "#if MAX_POINT_LIGHTS > 0", "totalDiffuse += pointDiffuse;", "totalSpecular += pointSpecular;", "#endif", "#if MAX_SPOT_LIGHTS > 0", "totalDiffuse += spotDiffuse;", "totalSpecular += spotSpecular;", "#endif", "#ifdef METAL", "gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor + totalSpecular );", "#else", "gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor ) + totalSpecular;", "#endif", "if ( enableReflection ) {", "vec3 vReflect;", "vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );", "if ( useRefract ) {", "vReflect = refract( cameraToVertex, normal, uRefractionRatio );", "} else {", "vReflect = reflect( cameraToVertex, normal );", "}", "vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );", "#ifdef GAMMA_INPUT", "cubeColor.xyz *= cubeColor.xyz;", "#endif", "gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * uReflectivity );", "}", THREE.ShaderChunk["shadowmap_fragment"], THREE.ShaderChunk["linear_to_gamma_fragment"], THREE.ShaderChunk["fog_fragment"], "}"].join("\n"), vertexShader: ["attribute vec4 tangent;", "uniform vec2 uOffset;", "uniform vec2 uRepeat;", "uniform bool enableDisplacement;", "#ifdef VERTEX_TEXTURES", "uniform sampler2D tDisplacement;", "uniform float uDisplacementScale;", "uniform float uDisplacementBias;", "#endif", "varying vec3 vTangent;", "varying vec3 vBinormal;", "varying vec3 vNormal;", "varying vec2 vUv;", "varying vec3 vWorldPosition;", "varying vec3 vViewPosition;", THREE.ShaderChunk["skinning_pars_vertex"], THREE.ShaderChunk["shadowmap_pars_vertex"], "void main() {", THREE.ShaderChunk["skinbase_vertex"], THREE.ShaderChunk["skinnormal_vertex"], "#ifdef USE_SKINNING", "vNormal = normalize( normalMatrix * skinnedNormal.xyz );", "vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );", "vTangent = normalize( normalMatrix * skinnedTangent.xyz );", "#else", "vNormal = normalize( normalMatrix * normal );", "vTangent = normalize( normalMatrix * tangent.xyz );", "#endif", "vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );", "vUv = uv * uRepeat + uOffset;", "vec3 displacedPosition;", "#ifdef VERTEX_TEXTURES", "if ( enableDisplacement ) {", "vec3 dv = texture2D( tDisplacement, uv ).xyz;", "float df = uDisplacementScale * dv.x + uDisplacementBias;", "displacedPosition = position + normalize( normal ) * df;", "} else {", "#ifdef USE_SKINNING", "vec4 skinVertex = vec4( position, 1.0 );", "vec4 skinned  = boneMatX * skinVertex * skinWeight.x;", "skinned 	  += boneMatY * skinVertex * skinWeight.y;", "displacedPosition  = skinned.xyz;", "#else", "displacedPosition = position;", "#endif", "}", "#else", "#ifdef USE_SKINNING", "vec4 skinVertex = vec4( position, 1.0 );", "vec4 skinned  = boneMatX * skinVertex * skinWeight.x;", "skinned 	  += boneMatY * skinVertex * skinWeight.y;", "displacedPosition  = skinned.xyz;", "#else", "displacedPosition = position;", "#endif", "#endif", "vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );", "vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );", "gl_Position = projectionMatrix * mvPosition;", "vWorldPosition = worldPosition.xyz;", "vViewPosition = -mvPosition.xyz;", "#ifdef USE_SHADOWMAP", "for( int i = 0; i < MAX_SHADOWS; i ++ ) {", "vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;", "}", "#endif", "}"].join("\n") }, depthRGBA: { uniforms: {}, vertexShader: [THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], "void main() {", THREE.ShaderChunk["skinbase_vertex"], THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["default_vertex"], "}"].join("\n"), fragmentShader: ["vec4 pack_depth( const in float depth ) {", "const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );", "const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );", "vec4 res = fract( depth * bit_shift );", "res -= res.xxyz * bit_mask;", "return res;", "}", "void main() {", "gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );", "}"].join("\n") } }; THREE.WebGLRenderer = function (e) { function wt(e) { e.__webglVertexBuffer = V.createBuffer(); e.__webglColorBuffer = V.createBuffer(); l.info.memory.geometries++ } function Et(e) { e.__webglVertexBuffer = V.createBuffer(); e.__webglColorBuffer = V.createBuffer(); e.__webglLineDistanceBuffer = V.createBuffer(); l.info.memory.geometries++ } function St(e) { e.__webglVertexBuffer = V.createBuffer(); e.__webglNormalBuffer = V.createBuffer(); e.__webglTangentBuffer = V.createBuffer(); e.__webglColorBuffer = V.createBuffer(); e.__webglUVBuffer = V.createBuffer(); e.__webglUV2Buffer = V.createBuffer(); e.__webglSkinIndicesBuffer = V.createBuffer(); e.__webglSkinWeightsBuffer = V.createBuffer(); e.__webglFaceBuffer = V.createBuffer(); e.__webglLineBuffer = V.createBuffer(); var t, n; if (e.numMorphTargets) { e.__webglMorphTargetsBuffers = []; for (t = 0, n = e.numMorphTargets; t < n; t++) { e.__webglMorphTargetsBuffers.push(V.createBuffer()) } } if (e.numMorphNormals) { e.__webglMorphNormalsBuffers = []; for (t = 0, n = e.numMorphNormals; t < n; t++) { e.__webglMorphNormalsBuffers.push(V.createBuffer()) } } l.info.memory.geometries++ } function _t(e, t) { var n = e.vertices.length; var r = t.material; if (r.attributes) { if (e.__webglCustomAttributesList === undefined) { e.__webglCustomAttributesList = [] } for (var i in r.attributes) { var s = r.attributes[i]; if (!s.__webglInitialized || s.createUniqueBuffers) { s.__webglInitialized = true; var o = 1; if (s.type === "v2") o = 2; else if (s.type === "v3") o = 3; else if (s.type === "v4") o = 4; else if (s.type === "c") o = 3; s.size = o; s.array = new Float32Array(n * o); s.buffer = V.createBuffer(); s.buffer.belongsToAttribute = i; s.needsUpdate = true } e.__webglCustomAttributesList.push(s) } } } function Dt(e, t) { var n = e.vertices.length; e.__vertexArray = new Float32Array(n * 3); e.__colorArray = new Float32Array(n * 3); e.__sortArray = []; e.__webglParticleCount = n; _t(e, t) } function Pt(e, t) { var n = e.vertices.length; e.__vertexArray = new Float32Array(n * 3); e.__colorArray = new Float32Array(n * 3); e.__lineDistanceArray = new Float32Array(n * 1); e.__webglLineCount = n; _t(e, t) } function Ht(e, t) { var n = t.geometry, r = e.faces3, i = r.length * 3, s = r.length * 1, o = r.length * 3, u = Bt(t, e), a = qt(u), f = Ft(u), l = It(u); e.__vertexArray = new Float32Array(i * 3); if (f) { e.__normalArray = new Float32Array(i * 3) } if (n.hasTangents) { e.__tangentArray = new Float32Array(i * 4) } if (l) { e.__colorArray = new Float32Array(i * 3) } if (a) { if (n.faceVertexUvs.length > 0) { e.__uvArray = new Float32Array(i * 2) } if (n.faceVertexUvs.length > 1) { e.__uv2Array = new Float32Array(i * 2) } } if (t.geometry.skinWeights.length && t.geometry.skinIndices.length) { e.__skinIndexArray = new Float32Array(i * 4); e.__skinWeightArray = new Float32Array(i * 4) } e.__faceArray = new Uint16Array(s * 3); e.__lineArray = new Uint16Array(o * 2); var c, h; if (e.numMorphTargets) { e.__morphTargetsArrays = []; for (c = 0, h = e.numMorphTargets; c < h; c++) { e.__morphTargetsArrays.push(new Float32Array(i * 3)) } } if (e.numMorphNormals) { e.__morphNormalsArrays = []; for (c = 0, h = e.numMorphNormals; c < h; c++) { e.__morphNormalsArrays.push(new Float32Array(i * 3)) } } e.__webglFaceCount = s * 3; e.__webglLineCount = o * 2; if (u.attributes) { if (e.__webglCustomAttributesList === undefined) { e.__webglCustomAttributesList = [] } for (var p in u.attributes) { var d = u.attributes[p]; var v = {}; for (var m in d) { v[m] = d[m] } if (!v.__webglInitialized || v.createUniqueBuffers) { v.__webglInitialized = true; var g = 1; if (v.type === "v2") g = 2; else if (v.type === "v3") g = 3; else if (v.type === "v4") g = 4; else if (v.type === "c") g = 3; v.size = g; v.array = new Float32Array(i * g); v.buffer = V.createBuffer(); v.buffer.belongsToAttribute = p; d.needsUpdate = true; v.__original = d } e.__webglCustomAttributesList.push(v) } } e.__inittedArrays = true } function Bt(e, t) { return e.material instanceof THREE.MeshFaceMaterial ? e.material.materials[t.materialIndex] : e.material } function jt(e) { return e && e.shading !== undefined && e.shading === THREE.SmoothShading } function Ft(e) { if (e instanceof THREE.MeshBasicMaterial && !e.envMap || e instanceof THREE.MeshDepthMaterial) { return false } if (jt(e)) { return THREE.SmoothShading } else { return THREE.FlatShading } } function It(e) { if (e.vertexColors) { return e.vertexColors } return false } function qt(e) { if (e.map || e.lightMap || e.bumpMap || e.normalMap || e.specularMap || e instanceof THREE.ShaderMaterial) { return true } return false } function Rt(e) { var t, n, r; for (t in e.attributes) { if (t === "index") { r = V.ELEMENT_ARRAY_BUFFER } else { r = V.ARRAY_BUFFER } n = e.attributes[t]; if (n.numItems === undefined) { n.numItems = n.array.length } n.buffer = V.createBuffer(); V.bindBuffer(r, n.buffer); V.bufferData(r, n.array, V.STATIC_DRAW) } } function Ut(e, t, n) { var r, i, s, o, u, a, f = e.vertices, l = f.length, c = e.colors, h = c.length, p = e.__vertexArray, d = e.__colorArray, v = e.__sortArray, m = e.verticesNeedUpdate, g = e.elementsNeedUpdate, y = e.colorsNeedUpdate, b = e.__webglCustomAttributesList, w, E, S, x, T, N, C; if (n.sortParticles) { R.copy(q); R.multiply(n.matrixWorld); for (r = 0; r < l; r++) { s = f[r]; U.copy(s); U.applyProjection(R); v[r] = [U.z, r] } v.sort(Qt); for (r = 0; r < l; r++) { s = f[v[r][1]]; o = r * 3; p[o] = s.x; p[o + 1] = s.y; p[o + 2] = s.z } for (i = 0; i < h; i++) { o = i * 3; a = c[v[i][1]]; d[o] = a.r; d[o + 1] = a.g; d[o + 2] = a.b } if (b) { for (w = 0, E = b.length; w < E; w++) { C = b[w]; if (!(C.boundTo === undefined || C.boundTo === "vertices")) continue; o = 0; T = C.value.length; if (C.size === 1) { for (x = 0; x < T; x++) { u = v[x][1]; C.array[x] = C.value[u] } } else if (C.size === 2) { for (x = 0; x < T; x++) { u = v[x][1]; N = C.value[u]; C.array[o] = N.x; C.array[o + 1] = N.y; o += 2 } } else if (C.size === 3) { if (C.type === "c") { for (x = 0; x < T; x++) { u = v[x][1]; N = C.value[u]; C.array[o] = N.r; C.array[o + 1] = N.g; C.array[o + 2] = N.b; o += 3 } } else { for (x = 0; x < T; x++) { u = v[x][1]; N = C.value[u]; C.array[o] = N.x; C.array[o + 1] = N.y; C.array[o + 2] = N.z; o += 3 } } } else if (C.size === 4) { for (x = 0; x < T; x++) { u = v[x][1]; N = C.value[u]; C.array[o] = N.x; C.array[o + 1] = N.y; C.array[o + 2] = N.z; C.array[o + 3] = N.w; o += 4 } } } } } else { if (m) { for (r = 0; r < l; r++) { s = f[r]; o = r * 3; p[o] = s.x; p[o + 1] = s.y; p[o + 2] = s.z } } if (y) { for (i = 0; i < h; i++) { a = c[i]; o = i * 3; d[o] = a.r; d[o + 1] = a.g; d[o + 2] = a.b } } if (b) { for (w = 0, E = b.length; w < E; w++) { C = b[w]; if (C.needsUpdate && (C.boundTo === undefined || C.boundTo === "vertices")) { T = C.value.length; o = 0; if (C.size === 1) { for (x = 0; x < T; x++) { C.array[x] = C.value[x] } } else if (C.size === 2) { for (x = 0; x < T; x++) { N = C.value[x]; C.array[o] = N.x; C.array[o + 1] = N.y; o += 2 } } else if (C.size === 3) { if (C.type === "c") { for (x = 0; x < T; x++) { N = C.value[x]; C.array[o] = N.r; C.array[o + 1] = N.g; C.array[o + 2] = N.b; o += 3 } } else { for (x = 0; x < T; x++) { N = C.value[x]; C.array[o] = N.x; C.array[o + 1] = N.y; C.array[o + 2] = N.z; o += 3 } } } else if (C.size === 4) { for (x = 0; x < T; x++) { N = C.value[x]; C.array[o] = N.x; C.array[o + 1] = N.y; C.array[o + 2] = N.z; C.array[o + 3] = N.w; o += 4 } } } } } } if (m || n.sortParticles) { V.bindBuffer(V.ARRAY_BUFFER, e.__webglVertexBuffer); V.bufferData(V.ARRAY_BUFFER, p, t) } if (y || n.sortParticles) { V.bindBuffer(V.ARRAY_BUFFER, e.__webglColorBuffer); V.bufferData(V.ARRAY_BUFFER, d, t) } if (b) { for (w = 0, E = b.length; w < E; w++) { C = b[w]; if (C.needsUpdate || n.sortParticles) { V.bindBuffer(V.ARRAY_BUFFER, C.buffer); V.bufferData(V.ARRAY_BUFFER, C.array, t) } } } } function zt(e, t) { var n, r, i, s, o, u, a = e.vertices, f = e.colors, l = e.lineDistances, c = a.length, h = f.length, p = l.length, d = e.__vertexArray, v = e.__colorArray, m = e.__lineDistanceArray, g = e.verticesNeedUpdate, y = e.colorsNeedUpdate, b = e.lineDistancesNeedUpdate, w = e.__webglCustomAttributesList, E, S, x, T, N, C, k; if (g) { for (n = 0; n < c; n++) { s = a[n]; o = n * 3; d[o] = s.x; d[o + 1] = s.y; d[o + 2] = s.z } V.bindBuffer(V.ARRAY_BUFFER, e.__webglVertexBuffer); V.bufferData(V.ARRAY_BUFFER, d, t) } if (y) { for (r = 0; r < h; r++) { u = f[r]; o = r * 3; v[o] = u.r; v[o + 1] = u.g; v[o + 2] = u.b } V.bindBuffer(V.ARRAY_BUFFER, e.__webglColorBuffer); V.bufferData(V.ARRAY_BUFFER, v, t) } if (b) { for (i = 0; i < p; i++) { m[i] = l[i] } V.bindBuffer(V.ARRAY_BUFFER, e.__webglLineDistanceBuffer); V.bufferData(V.ARRAY_BUFFER, m, t) } if (w) { for (E = 0, S = w.length; E < S; E++) { k = w[E]; if (k.needsUpdate && (k.boundTo === undefined || k.boundTo === "vertices")) { o = 0; N = k.value.length; if (k.size === 1) { for (T = 0; T < N; T++) { k.array[T] = k.value[T] } } else if (k.size === 2) { for (T = 0; T < N; T++) { C = k.value[T]; k.array[o] = C.x; k.array[o + 1] = C.y; o += 2 } } else if (k.size === 3) { if (k.type === "c") { for (T = 0; T < N; T++) { C = k.value[T]; k.array[o] = C.r; k.array[o + 1] = C.g; k.array[o + 2] = C.b; o += 3 } } else { for (T = 0; T < N; T++) { C = k.value[T]; k.array[o] = C.x; k.array[o + 1] = C.y; k.array[o + 2] = C.z; o += 3 } } } else if (k.size === 4) { for (T = 0; T < N; T++) { C = k.value[T]; k.array[o] = C.x; k.array[o + 1] = C.y; k.array[o + 2] = C.z; k.array[o + 3] = C.w; o += 4 } } V.bindBuffer(V.ARRAY_BUFFER, k.buffer); V.bufferData(V.ARRAY_BUFFER, k.array, t) } } } } function Wt(e, t, n, r, i) { if (!e.__inittedArrays) { return } var s = Ft(i), o = It(i), u = qt(i), a = s === THREE.SmoothShading; var f, l, c, h, p, d, v, m, g, y, b, w, E, S, x, T, N, C, k, L, A, O, M, _, D, P, H, B, j, F, I, q, R, U, z, W, X, $, J, K, Q, G, Y, Z, et, tt, nt, rt, it, st, ot, ut, at, ft, lt, ct, ht, pt, dt = 0, vt = 0, mt = 0, gt = 0, yt = 0, bt = 0, wt = 0, Et = 0, St = 0, xt = 0, Tt = 0, Nt = 0, Ct = 0, kt, Lt = e.__vertexArray, At = e.__uvArray, Ot = e.__uv2Array, Mt = e.__normalArray, _t = e.__tangentArray, Dt = e.__colorArray, Pt = e.__skinIndexArray, Ht = e.__skinWeightArray, Bt = e.__morphTargetsArrays, jt = e.__morphNormalsArrays, Rt = e.__webglCustomAttributesList, Ut, zt = e.__faceArray, Wt = e.__lineArray, Xt = t.geometry, Vt = Xt.verticesNeedUpdate, $t = Xt.elementsNeedUpdate, Jt = Xt.uvsNeedUpdate, Kt = Xt.normalsNeedUpdate, Qt = Xt.tangentsNeedUpdate, Gt = Xt.colorsNeedUpdate, Yt = Xt.morphTargetsNeedUpdate, Zt = Xt.vertices, en = e.faces3, tn = Xt.faces, nn = Xt.faceVertexUvs[0], rn = Xt.faceVertexUvs[1], sn = Xt.colors, on = Xt.skinIndices, un = Xt.skinWeights, an = Xt.morphTargets, fn = Xt.morphNormals; if (Vt) { for (f = 0, l = en.length; f < l; f++) { h = tn[en[f]]; E = Zt[h.a]; S = Zt[h.b]; x = Zt[h.c]; Lt[vt] = E.x; Lt[vt + 1] = E.y; Lt[vt + 2] = E.z; Lt[vt + 3] = S.x; Lt[vt + 4] = S.y; Lt[vt + 5] = S.z; Lt[vt + 6] = x.x; Lt[vt + 7] = x.y; Lt[vt + 8] = x.z; vt += 9 } V.bindBuffer(V.ARRAY_BUFFER, e.__webglVertexBuffer); V.bufferData(V.ARRAY_BUFFER, Lt, n) } if (Yt) { for (ut = 0, at = an.length; ut < at; ut++) { Tt = 0; for (f = 0, l = en.length; f < l; f++) { ct = en[f]; h = tn[ct]; E = an[ut].vertices[h.a]; S = an[ut].vertices[h.b]; x = an[ut].vertices[h.c]; ft = Bt[ut]; ft[Tt] = E.x; ft[Tt + 1] = E.y; ft[Tt + 2] = E.z; ft[Tt + 3] = S.x; ft[Tt + 4] = S.y; ft[Tt + 5] = S.z; ft[Tt + 6] = x.x; ft[Tt + 7] = x.y; ft[Tt + 8] = x.z; if (i.morphNormals) { if (a) { ht = fn[ut].vertexNormals[ct]; A = ht.a; O = ht.b; M = ht.c } else { A = fn[ut].faceNormals[ct]; O = A; M = A } lt = jt[ut]; lt[Tt] = A.x; lt[Tt + 1] = A.y; lt[Tt + 2] = A.z; lt[Tt + 3] = O.x; lt[Tt + 4] = O.y; lt[Tt + 5] = O.z; lt[Tt + 6] = M.x; lt[Tt + 7] = M.y; lt[Tt + 8] = M.z } Tt += 9 } V.bindBuffer(V.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[ut]); V.bufferData(V.ARRAY_BUFFER, Bt[ut], n); if (i.morphNormals) { V.bindBuffer(V.ARRAY_BUFFER, e.__webglMorphNormalsBuffers[ut]); V.bufferData(V.ARRAY_BUFFER, jt[ut], n) } } } if (un.length) { for (f = 0, l = en.length; f < l; f++) { h = tn[en[f]]; j = un[h.a]; F = un[h.b]; I = un[h.c]; Ht[xt] = j.x; Ht[xt + 1] = j.y; Ht[xt + 2] = j.z; Ht[xt + 3] = j.w; Ht[xt + 4] = F.x; Ht[xt + 5] = F.y; Ht[xt + 6] = F.z; Ht[xt + 7] = F.w; Ht[xt + 8] = I.x; Ht[xt + 9] = I.y; Ht[xt + 10] = I.z; Ht[xt + 11] = I.w; R = on[h.a]; U = on[h.b]; z = on[h.c]; Pt[xt] = R.x; Pt[xt + 1] = R.y; Pt[xt + 2] = R.z; Pt[xt + 3] = R.w; Pt[xt + 4] = U.x; Pt[xt + 5] = U.y; Pt[xt + 6] = U.z; Pt[xt + 7] = U.w; Pt[xt + 8] = z.x; Pt[xt + 9] = z.y; Pt[xt + 10] = z.z; Pt[xt + 11] = z.w; xt += 12 } if (xt > 0) { V.bindBuffer(V.ARRAY_BUFFER, e.__webglSkinIndicesBuffer); V.bufferData(V.ARRAY_BUFFER, Pt, n); V.bindBuffer(V.ARRAY_BUFFER, e.__webglSkinWeightsBuffer); V.bufferData(V.ARRAY_BUFFER, Ht, n) } } if (Gt && o) { for (f = 0, l = en.length; f < l; f++) { h = tn[en[f]]; m = h.vertexColors; g = h.color; if (m.length === 3 && o === THREE.VertexColors) { D = m[0]; P = m[1]; H = m[2] } else { D = g; P = g; H = g } Dt[St] = D.r; Dt[St + 1] = D.g; Dt[St + 2] = D.b; Dt[St + 3] = P.r; Dt[St + 4] = P.g; Dt[St + 5] = P.b; Dt[St + 6] = H.r; Dt[St + 7] = H.g; Dt[St + 8] = H.b; St += 9 } if (St > 0) { V.bindBuffer(V.ARRAY_BUFFER, e.__webglColorBuffer); V.bufferData(V.ARRAY_BUFFER, Dt, n) } } if (Qt && Xt.hasTangents) { for (f = 0, l = en.length; f < l; f++) { h = tn[en[f]]; y = h.vertexTangents; N = y[0]; C = y[1]; k = y[2]; _t[wt] = N.x; _t[wt + 1] = N.y; _t[wt + 2] = N.z; _t[wt + 3] = N.w; _t[wt + 4] = C.x; _t[wt + 5] = C.y; _t[wt + 6] = C.z; _t[wt + 7] = C.w; _t[wt + 8] = k.x; _t[wt + 9] = k.y; _t[wt + 10] = k.z; _t[wt + 11] = k.w; wt += 12 } V.bindBuffer(V.ARRAY_BUFFER, e.__webglTangentBuffer); V.bufferData(V.ARRAY_BUFFER, _t, n) } if (Kt && s) { for (f = 0, l = en.length; f < l; f++) { h = tn[en[f]]; p = h.vertexNormals; d = h.normal; if (p.length === 3 && a) { for (nt = 0; nt < 3; nt++) { it = p[nt]; Mt[bt] = it.x; Mt[bt + 1] = it.y; Mt[bt + 2] = it.z; bt += 3 } } else { for (nt = 0; nt < 3; nt++) { Mt[bt] = d.x; Mt[bt + 1] = d.y; Mt[bt + 2] = d.z; bt += 3 } } } V.bindBuffer(V.ARRAY_BUFFER, e.__webglNormalBuffer); V.bufferData(V.ARRAY_BUFFER, Mt, n) } if (Jt && nn && u) { for (f = 0, l = en.length; f < l; f++) { c = en[f]; b = nn[c]; if (b === undefined) continue; for (nt = 0; nt < 3; nt++) { st = b[nt]; At[mt] = st.x; At[mt + 1] = st.y; mt += 2 } } if (mt > 0) { V.bindBuffer(V.ARRAY_BUFFER, e.__webglUVBuffer); V.bufferData(V.ARRAY_BUFFER, At, n) } } if (Jt && rn && u) { for (f = 0, l = en.length; f < l; f++) { c = en[f]; w = rn[c]; if (w === undefined) continue; for (nt = 0; nt < 3; nt++) { ot = w[nt]; Ot[gt] = ot.x; Ot[gt + 1] = ot.y; gt += 2 } } if (gt > 0) { V.bindBuffer(V.ARRAY_BUFFER, e.__webglUV2Buffer); V.bufferData(V.ARRAY_BUFFER, Ot, n) } } if ($t) { for (f = 0, l = en.length; f < l; f++) { zt[yt] = dt; zt[yt + 1] = dt + 1; zt[yt + 2] = dt + 2; yt += 3; Wt[Et] = dt; Wt[Et + 1] = dt + 1; Wt[Et + 2] = dt; Wt[Et + 3] = dt + 2; Wt[Et + 4] = dt + 1; Wt[Et + 5] = dt + 2; Et += 6; dt += 3 } V.bindBuffer(V.ELEMENT_ARRAY_BUFFER, e.__webglFaceBuffer); V.bufferData(V.ELEMENT_ARRAY_BUFFER, zt, n); V.bindBuffer(V.ELEMENT_ARRAY_BUFFER, e.__webglLineBuffer); V.bufferData(V.ELEMENT_ARRAY_BUFFER, Wt, n) } if (Rt) { for (nt = 0, rt = Rt.length; nt < rt; nt++) { Ut = Rt[nt]; if (!Ut.__original.needsUpdate) continue; Nt = 0; Ct = 0; if (Ut.size === 1) { if (Ut.boundTo === undefined || Ut.boundTo === "vertices") { for (f = 0, l = en.length; f < l; f++) { h = tn[en[f]]; Ut.array[Nt] = Ut.value[h.a]; Ut.array[Nt + 1] = Ut.value[h.b]; Ut.array[Nt + 2] = Ut.value[h.c]; Nt += 3 } } else if (Ut.boundTo === "faces") { for (f = 0, l = en.length; f < l; f++) { kt = Ut.value[en[f]]; Ut.array[Nt] = kt; Ut.array[Nt + 1] = kt; Ut.array[Nt + 2] = kt; Nt += 3 } } } else if (Ut.size === 2) { if (Ut.boundTo === undefined || Ut.boundTo === "vertices") { for (f = 0, l = en.length; f < l; f++) { h = tn[en[f]]; E = Ut.value[h.a]; S = Ut.value[h.b]; x = Ut.value[h.c]; Ut.array[Nt] = E.x; Ut.array[Nt + 1] = E.y; Ut.array[Nt + 2] = S.x; Ut.array[Nt + 3] = S.y; Ut.array[Nt + 4] = x.x; Ut.array[Nt + 5] = x.y; Nt += 6 } } else if (Ut.boundTo === "faces") { for (f = 0, l = en.length; f < l; f++) { kt = Ut.value[en[f]]; E = kt; S = kt; x = kt; Ut.array[Nt] = E.x; Ut.array[Nt + 1] = E.y; Ut.array[Nt + 2] = S.x; Ut.array[Nt + 3] = S.y; Ut.array[Nt + 4] = x.x; Ut.array[Nt + 5] = x.y; Nt += 6 } } } else if (Ut.size === 3) { var ln; if (Ut.type === "c") { ln = ["r", "g", "b"] } else { ln = ["x", "y", "z"] } if (Ut.boundTo === undefined || Ut.boundTo === "vertices") { for (f = 0, l = en.length; f < l; f++) { h = tn[en[f]]; E = Ut.value[h.a]; S = Ut.value[h.b]; x = Ut.value[h.c]; Ut.array[Nt] = E[ln[0]]; Ut.array[Nt + 1] = E[ln[1]]; Ut.array[Nt + 2] = E[ln[2]]; Ut.array[Nt + 3] = S[ln[0]]; Ut.array[Nt + 4] = S[ln[1]]; Ut.array[Nt + 5] = S[ln[2]]; Ut.array[Nt + 6] = x[ln[0]]; Ut.array[Nt + 7] = x[ln[1]]; Ut.array[Nt + 8] = x[ln[2]]; Nt += 9 } } else if (Ut.boundTo === "faces") { for (f = 0, l = en.length; f < l; f++) { kt = Ut.value[en[f]]; E = kt; S = kt; x = kt; Ut.array[Nt] = E[ln[0]]; Ut.array[Nt + 1] = E[ln[1]]; Ut.array[Nt + 2] = E[ln[2]]; Ut.array[Nt + 3] = S[ln[0]]; Ut.array[Nt + 4] = S[ln[1]]; Ut.array[Nt + 5] = S[ln[2]]; Ut.array[Nt + 6] = x[ln[0]]; Ut.array[Nt + 7] = x[ln[1]]; Ut.array[Nt + 8] = x[ln[2]]; Nt += 9 } } else if (Ut.boundTo === "faceVertices") { for (f = 0, l = en.length; f < l; f++) { kt = Ut.value[en[f]]; E = kt[0]; S = kt[1]; x = kt[2]; Ut.array[Nt] = E[ln[0]]; Ut.array[Nt + 1] = E[ln[1]]; Ut.array[Nt + 2] = E[ln[2]]; Ut.array[Nt + 3] = S[ln[0]]; Ut.array[Nt + 4] = S[ln[1]]; Ut.array[Nt + 5] = S[ln[2]]; Ut.array[Nt + 6] = x[ln[0]]; Ut.array[Nt + 7] = x[ln[1]]; Ut.array[Nt + 8] = x[ln[2]]; Nt += 9 } } } else if (Ut.size === 4) { if (Ut.boundTo === undefined || Ut.boundTo === "vertices") { for (f = 0, l = en.length; f < l; f++) { h = tn[en[f]]; E = Ut.value[h.a]; S = Ut.value[h.b]; x = Ut.value[h.c]; Ut.array[Nt] = E.x; Ut.array[Nt + 1] = E.y; Ut.array[Nt + 2] = E.z; Ut.array[Nt + 3] = E.w; Ut.array[Nt + 4] = S.x; Ut.array[Nt + 5] = S.y; Ut.array[Nt + 6] = S.z; Ut.array[Nt + 7] = S.w; Ut.array[Nt + 8] = x.x; Ut.array[Nt + 9] = x.y; Ut.array[Nt + 10] = x.z; Ut.array[Nt + 11] = x.w; Nt += 12 } } else if (Ut.boundTo === "faces") { for (f = 0, l = en.length; f < l; f++) { kt = Ut.value[en[f]]; E = kt; S = kt; x = kt; Ut.array[Nt] = E.x; Ut.array[Nt + 1] = E.y; Ut.array[Nt + 2] = E.z; Ut.array[Nt + 3] = E.w; Ut.array[Nt + 4] = S.x; Ut.array[Nt + 5] = S.y; Ut.array[Nt + 6] = S.z; Ut.array[Nt + 7] = S.w; Ut.array[Nt + 8] = x.x; Ut.array[Nt + 9] = x.y; Ut.array[Nt + 10] = x.z; Ut.array[Nt + 11] = x.w; Nt += 12 } } else if (Ut.boundTo === "faceVertices") { for (f = 0, l = en.length; f < l; f++) { kt = Ut.value[en[f]]; E = kt[0]; S = kt[1]; x = kt[2]; Ut.array[Nt] = E.x; Ut.array[Nt + 1] = E.y; Ut.array[Nt + 2] = E.z; Ut.array[Nt + 3] = E.w; Ut.array[Nt + 4] = S.x; Ut.array[Nt + 5] = S.y; Ut.array[Nt + 6] = S.z; Ut.array[Nt + 7] = S.w; Ut.array[Nt + 8] = x.x; Ut.array[Nt + 9] = x.y; Ut.array[Nt + 10] = x.z; Ut.array[Nt + 11] = x.w; Nt += 12 } } } V.bindBuffer(V.ARRAY_BUFFER, Ut.buffer); V.bufferData(V.ARRAY_BUFFER, Ut.array, n) } } if (r) { delete e.__inittedArrays; delete e.__colorArray; delete e.__normalArray; delete e.__tangentArray; delete e.__uvArray; delete e.__uv2Array; delete e.__faceArray; delete e.__vertexArray; delete e.__lineArray; delete e.__skinIndexArray; delete e.__skinWeightArray } } function Xt(e, t, n) { var r = e.attributes; var i, s; for (i in r) { s = r[i]; if (s.needsUpdate) { if (i === "index") { V.bindBuffer(V.ELEMENT_ARRAY_BUFFER, s.buffer); V.bufferData(V.ELEMENT_ARRAY_BUFFER, s.array, t) } else { V.bindBuffer(V.ARRAY_BUFFER, s.buffer); V.bufferData(V.ARRAY_BUFFER, s.array, t) } s.needsUpdate = false } if (n && !s.dynamic) { s.array = null } } } function Vt(e) { if (!F[e]) { V.enableVertexAttribArray(e); F[e] = true } } function $t() { for (var e in F) { if (F[e]) { V.disableVertexAttribArray(e); F[e] = false } } } function Jt(e, t, n) { var r = e.program.attributes; if (n.morphTargetBase !== -1 && r.position >= 0) { V.bindBuffer(V.ARRAY_BUFFER, t.__webglMorphTargetsBuffers[n.morphTargetBase]); Vt(r.position); V.vertexAttribPointer(r.position, 3, V.FLOAT, false, 0, 0) } else if (r.position >= 0) { V.bindBuffer(V.ARRAY_BUFFER, t.__webglVertexBuffer); Vt(r.position); V.vertexAttribPointer(r.position, 3, V.FLOAT, false, 0, 0) } if (n.morphTargetForcedOrder.length) { var i = 0; var s = n.morphTargetForcedOrder; var o = n.morphTargetInfluences; while (i < e.numSupportedMorphTargets && i < s.length) { if (r["morphTarget" + i] >= 0) { V.bindBuffer(V.ARRAY_BUFFER, t.__webglMorphTargetsBuffers[s[i]]); Vt(r["morphTarget" + i]); V.vertexAttribPointer(r["morphTarget" + i], 3, V.FLOAT, false, 0, 0) } if (r["morphNormal" + i] >= 0 && e.morphNormals) { V.bindBuffer(V.ARRAY_BUFFER, t.__webglMorphNormalsBuffers[s[i]]); Vt(r["morphNormal" + i]); V.vertexAttribPointer(r["morphNormal" + i], 3, V.FLOAT, false, 0, 0) } n.__webglMorphTargetInfluences[i] = o[s[i]]; i++ } } else { var u, a = []; var o = n.morphTargetInfluences; var f, l = o.length; for (f = 0; f < l; f++) { u = o[f]; if (u > 0) { a.push([u, f]) } } if (a.length > e.numSupportedMorphTargets) { a.sort(Qt); a.length = e.numSupportedMorphTargets } else if (a.length > e.numSupportedMorphNormals) { a.sort(Qt) } else if (a.length === 0) { a.push([0, 0]) } var c, i = 0; while (i < e.numSupportedMorphTargets) { if (a[i]) { c = a[i][1]; if (r["morphTarget" + i] >= 0) { V.bindBuffer(V.ARRAY_BUFFER, t.__webglMorphTargetsBuffers[c]); Vt(r["morphTarget" + i]); V.vertexAttribPointer(r["morphTarget" + i], 3, V.FLOAT, false, 0, 0) } if (r["morphNormal" + i] >= 0 && e.morphNormals) { V.bindBuffer(V.ARRAY_BUFFER, t.__webglMorphNormalsBuffers[c]); Vt(r["morphNormal" + i]); V.vertexAttribPointer(r["morphNormal" + i], 3, V.FLOAT, false, 0, 0) } n.__webglMorphTargetInfluences[i] = o[c] } else { n.__webglMorphTargetInfluences[i] = 0 } i++ } } if (e.program.uniforms.morphTargetInfluences !== null) { V.uniform1fv(e.program.uniforms.morphTargetInfluences, n.__webglMorphTargetInfluences) } } function Kt(e, t) { if (e.z !== t.z) { return t.z - e.z } else { return e.id - t.id } } function Qt(e, t) { return t[0] - e[0] } function Gt(e, t, n) { if (!e.length) return; for (var r = 0, i = e.length; r < i; r++) { p = null; g = null; S = -1; C = -1; k = -1; w = -1; E = -1; m = -1; v = -1; W = true; e[r].render(t, n, B, j); p = null; g = null; S = -1; C = -1; k = -1; w = -1; E = -1; m = -1; v = -1; W = true } } function Yt(e, t, n, r, i, s, o, u) { var a, f, c, h, p, d, v; if (t) { p = e.length - 1; d = -1; v = -1 } else { p = 0; d = e.length; v = 1 } for (var m = p; m !== d; m += v) { a = e[m]; if (a.render) { f = a.object; c = a.buffer; if (u) { h = u } else { h = a[n]; if (!h) continue; if (o) l.setBlending(h.blending, h.blendEquation, h.blendSrc, h.blendDst); l.setDepthTest(h.depthTest); l.setDepthWrite(h.depthWrite); _n(h.polygonOffset, h.polygonOffsetFactor, h.polygonOffsetUnits) } l.setMaterialFaces(h); if (c instanceof THREE.BufferGeometry) { l.renderBufferDirect(r, i, s, h, c, f) } else { l.renderBuffer(r, i, s, h, c, f) } } } } function Zt(e, t, n, r, i, s, o) { var u, a, f, c; for (var h = 0, p = e.length; h < p; h++) { u = e[h]; a = u.object; if (a.visible) { if (o) { f = o } else { f = u[t]; if (!f) continue; if (s) l.setBlending(f.blending, f.blendEquation, f.blendSrc, f.blendDst); l.setDepthTest(f.depthTest); l.setDepthWrite(f.depthWrite); _n(f.polygonOffset, f.polygonOffsetFactor, f.polygonOffsetUnits) } l.renderImmediateObject(n, r, i, f, a) } } } function en(e) { var t = e.object, n = t.material; if (n.transparent) { e.transparent = n; e.opaque = null } else { e.opaque = n; e.transparent = null } } function tn(e) { var t = e.object, n = e.buffer, r, i, s; s = t.material; if (s instanceof THREE.MeshFaceMaterial) { i = n.materialIndex; r = s.materials[i]; if (r.transparent) { e.transparent = r; e.opaque = null } else { e.opaque = r; e.transparent = null } } else { r = s; if (r) { if (r.transparent) { e.transparent = r; e.opaque = null } else { e.opaque = r; e.transparent = null } } } } function nn(e, t) { var n, r, i, s, o, u, a = {}; var f = e.morphTargets.length; var l = e.morphNormals.length; var c = t instanceof THREE.MeshFaceMaterial; e.geometryGroups = {}; for (n = 0, r = e.faces.length; n < r; n++) { i = e.faces[n]; s = c ? i.materialIndex : 0; if (a[s] === undefined) { a[s] = { hash: s, counter: 0 } } u = a[s].hash + "_" + a[s].counter; if (e.geometryGroups[u] === undefined) { e.geometryGroups[u] = { faces3: [], materialIndex: s, vertices: 0, numMorphTargets: f, numMorphNormals: l } } o = 3; if (e.geometryGroups[u].vertices + o > 65535) { a[s].counter += 1; u = a[s].hash + "_" + a[s].counter; if (e.geometryGroups[u] === undefined) { e.geometryGroups[u] = { faces3: [], materialIndex: s, vertices: 0, numMorphTargets: f, numMorphNormals: l } } } e.geometryGroups[u].faces3.push(n); e.geometryGroups[u].vertices += o } e.geometryGroupsList = []; for (var h in e.geometryGroups) { e.geometryGroups[h].id = y++; e.geometryGroupsList.push(e.geometryGroups[h]) } } function rn(e, t) { var n, r, i, s; if (e.__webglInit === undefined) { e.__webglInit = true; e._modelViewMatrix = new THREE.Matrix4; e._normalMatrix = new THREE.Matrix3; if (e.geometry !== undefined && e.geometry.__webglInit === undefined) { e.geometry.__webglInit = true; e.geometry.addEventListener("dispose", xt) } r = e.geometry; if (r === undefined) { } else if (r instanceof THREE.BufferGeometry) { Rt(r) } else if (e instanceof THREE.Mesh) { i = e.material; if (r.geometryGroups === undefined) { nn(r, i) } for (n in r.geometryGroups) { s = r.geometryGroups[n]; if (!s.__webglVertexBuffer) { St(s); Ht(s, e); r.verticesNeedUpdate = true; r.morphTargetsNeedUpdate = true; r.elementsNeedUpdate = true; r.uvsNeedUpdate = true; r.normalsNeedUpdate = true; r.tangentsNeedUpdate = true; r.colorsNeedUpdate = true } } } else if (e instanceof THREE.Line) { if (!r.__webglVertexBuffer) { Et(r); Pt(r, e); r.verticesNeedUpdate = true; r.colorsNeedUpdate = true; r.lineDistancesNeedUpdate = true } } else if (e instanceof THREE.ParticleSystem) { if (!r.__webglVertexBuffer) { wt(r); Dt(r, e); r.verticesNeedUpdate = true; r.colorsNeedUpdate = true } } } if (e.__webglActive === undefined) { if (e instanceof THREE.Mesh) { r = e.geometry; if (r instanceof THREE.BufferGeometry) { sn(t.__webglObjects, r, e) } else if (r instanceof THREE.Geometry) { for (n in r.geometryGroups) { s = r.geometryGroups[n]; sn(t.__webglObjects, s, e) } } } else if (e instanceof THREE.Line || e instanceof THREE.ParticleSystem) { r = e.geometry; sn(t.__webglObjects, r, e) } else if (e instanceof THREE.ImmediateRenderObject || e.immediateRenderCallback) { on(t.__webglObjectsImmediate, e) } e.__webglActive = true } } function sn(e, t, n) { e.push({ id: null, buffer: t, object: n, opaque: null, transparent: null, z: 0 }) } function on(e, t) { e.push({ id: null, object: t, opaque: null, transparent: null, z: 0 }) } function un(e) { var t = e.geometry, n, r, i; if (t instanceof THREE.BufferGeometry) { Xt(t, V.DYNAMIC_DRAW, !t.dynamic) } else if (e instanceof THREE.Mesh) { for (var s = 0, o = t.geometryGroupsList.length; s < o; s++) { n = t.geometryGroupsList[s]; i = Bt(e, n); if (t.buffersNeedUpdate) { Ht(n, e) } r = i.attributes && an(i); if (t.verticesNeedUpdate || t.morphTargetsNeedUpdate || t.elementsNeedUpdate || t.uvsNeedUpdate || t.normalsNeedUpdate || t.colorsNeedUpdate || t.tangentsNeedUpdate || r) { Wt(n, e, V.DYNAMIC_DRAW, !t.dynamic, i) } } t.verticesNeedUpdate = false; t.morphTargetsNeedUpdate = false; t.elementsNeedUpdate = false; t.uvsNeedUpdate = false; t.normalsNeedUpdate = false; t.colorsNeedUpdate = false; t.tangentsNeedUpdate = false; t.buffersNeedUpdate = false; i.attributes && fn(i) } else if (e instanceof THREE.Line) { i = Bt(e, t); r = i.attributes && an(i); if (t.verticesNeedUpdate || t.colorsNeedUpdate || t.lineDistancesNeedUpdate || r) { zt(t, V.DYNAMIC_DRAW) } t.verticesNeedUpdate = false; t.colorsNeedUpdate = false; t.lineDistancesNeedUpdate = false; i.attributes && fn(i) } else if (e instanceof THREE.ParticleSystem) { i = Bt(e, t); r = i.attributes && an(i); if (t.verticesNeedUpdate || t.colorsNeedUpdate || e.sortParticles || r) { Ut(t, V.DYNAMIC_DRAW, e) } t.verticesNeedUpdate = false; t.colorsNeedUpdate = false; i.attributes && fn(i) } } function an(e) { for (var t in e.attributes) { if (e.attributes[t].needsUpdate) return true } return false } function fn(e) { for (var t in e.attributes) { e.attributes[t].needsUpdate = false } } function ln(e, t) { if (e instanceof THREE.Mesh || e instanceof THREE.ParticleSystem || e instanceof THREE.Line) { cn(t.__webglObjects, e) } else if (e instanceof THREE.Sprite) { hn(t.__webglSprites, e) } else if (e instanceof THREE.LensFlare) { hn(t.__webglFlares, e) } else if (e instanceof THREE.ImmediateRenderObject || e.immediateRenderCallback) { cn(t.__webglObjectsImmediate, e) } delete e.__webglActive } function cn(e, t) { for (var n = e.length - 1; n >= 0; n--) { if (e[n].object === t) { e.splice(n, 1) } } } function hn(e, t) { for (var n = e.length - 1; n >= 0; n--) { if (e[n] === t) { e.splice(n, 1) } } } function pn(e, t) { e.uniforms = THREE.UniformsUtils.clone(t.uniforms); e.vertexShader = t.vertexShader; e.fragmentShader = t.fragmentShader } function dn(e, t, n, r, i) { b = 0; if (r.needsUpdate) { if (r.program) Mt(r); l.initMaterial(r, t, n, i); r.needsUpdate = false } if (r.morphTargets) { if (!i.__webglMorphTargetInfluences) { i.__webglMorphTargetInfluences = new Float32Array(l.maxMorphTargets) } } var s = false; var o = r.program, u = o.uniforms, a = r.uniforms; if (o !== p) { V.useProgram(o); p = o; s = true } if (r.id !== v) { v = r.id; s = true } if (s || e !== g) { V.uniformMatrix4fv(u.projectionMatrix, false, e.projectionMatrix.elements); if (e !== g) g = e } if (r.skinning) { if (it && i.useVertexTexture) { if (u.boneTexture !== null) { var f = Nn(); V.uniform1i(u.boneTexture, f); l.setTexture(i.boneTexture, f) } if (u.boneTextureWidth !== null) { V.uniform1i(u.boneTextureWidth, i.boneTextureWidth) } if (u.boneTextureHeight !== null) { V.uniform1i(u.boneTextureHeight, i.boneTextureHeight) } } else { if (u.boneGlobalMatrices !== null) { V.uniformMatrix4fv(u.boneGlobalMatrices, false, i.boneMatrices) } } } if (s) { if (n && r.fog) { bn(a, n) } if (r instanceof THREE.MeshPhongMaterial || r.lights) { if (W) { On(o, t); W = false } Sn(a, X) } if (r instanceof THREE.MeshBasicMaterial || r instanceof THREE.MeshPhongMaterial) { vn(a, r) } if (r instanceof THREE.LineBasicMaterial) { mn(a, r) } else if (r instanceof THREE.LineDashedMaterial) { mn(a, r); gn(a, r) } else if (r instanceof THREE.MeshPhongMaterial) { wn(a, r) } else if (r instanceof THREE.MeshDepthMaterial) { a.mNear.value = e.near; a.mFar.value = e.far; a.opacity.value = r.opacity } else if (r instanceof THREE.MeshNormalMaterial) { a.opacity.value = r.opacity } if (i.receiveShadow && !r._shadowPass) { xn(a, t) } Cn(o, r.uniformsList); if (r instanceof THREE.ShaderMaterial || r instanceof THREE.MeshPhongMaterial || r.envMap) { if (u.cameraPosition !== null) { U.getPositionFromMatrix(e.matrixWorld); V.uniform3f(u.cameraPosition, U.x, U.y, U.z) } } if (r instanceof THREE.MeshPhongMaterial || r instanceof THREE.ShaderMaterial || r.skinning) { if (u.viewMatrix !== null) { V.uniformMatrix4fv(u.viewMatrix, false, e.matrixWorldInverse.elements) } } } Tn(u, i); if (u.modelMatrix !== null) { V.uniformMatrix4fv(u.modelMatrix, false, i.matrixWorld.elements) } return o } function vn(e, t) { e.opacity.value = t.opacity; if (l.gammaInput) { e.diffuse.value.copyGammaToLinear(t.color) } else { e.diffuse.value = t.color } e.map.value = t.map; e.lightMap.value = t.lightMap; e.specularMap.value = t.specularMap; if (t.bumpMap) { e.bumpMap.value = t.bumpMap; e.bumpScale.value = t.bumpScale } if (t.normalMap) { e.normalMap.value = t.normalMap; e.normalScale.value.copy(t.normalScale) } var n; if (t.map) { n = t.map } else if (t.specularMap) { n = t.specularMap } else if (t.normalMap) { n = t.normalMap } else if (t.bumpMap) { n = t.bumpMap } if (n !== undefined) { var r = n.offset; var i = n.repeat; e.offsetRepeat.value.set(r.x, r.y, i.x, i.y) } e.envMap.value = t.envMap; e.flipEnvMap.value = t.envMap instanceof THREE.WebGLRenderTargetCube ? 1 : -1; if (l.gammaInput) { e.reflectivity.value = t.reflectivity } else { e.reflectivity.value = t.reflectivity } e.refractionRatio.value = t.refractionRatio; e.combine.value = t.combine; e.useRefract.value = t.envMap && t.envMap.mapping instanceof THREE.CubeRefractionMapping } function mn(e, t) { e.diffuse.value = t.color; e.opacity.value = t.opacity } function gn(e, t) { e.dashSize.value = t.dashSize; e.totalSize.value = t.dashSize + t.gapSize; e.scale.value = t.scale } function yn(e, n) { e.psColor.value = n.color; e.opacity.value = n.opacity; e.size.value = n.size; e.scale.value = t.height / 2; e.map.value = n.map } function bn(e, t) { e.fogColor.value = t.color; if (t instanceof THREE.Fog) { e.fogNear.value = t.near; e.fogFar.value = t.far } else if (t instanceof THREE.FogExp2) { e.fogDensity.value = t.density } } function wn(e, t) { e.shininess.value = t.shininess; if (l.gammaInput) { e.ambient.value.copyGammaToLinear(t.ambient); e.emissive.value.copyGammaToLinear(t.emissive); e.specular.value.copyGammaToLinear(t.specular) } else { e.ambient.value = t.ambient; e.emissive.value = t.emissive; e.specular.value = t.specular } if (t.wrapAround) { e.wrapRGB.value.copy(t.wrapRGB) } } function En(e, t) { if (l.gammaInput) { e.ambient.value.copyGammaToLinear(t.ambient); e.emissive.value.copyGammaToLinear(t.emissive) } else { e.ambient.value = t.ambient; e.emissive.value = t.emissive } if (t.wrapAround) { e.wrapRGB.value.copy(t.wrapRGB) } } function Sn(e, t) { e.ambientLightColor.value = t.ambient; e.directionalLightColor.value = t.directional.colors; e.directionalLightDirection.value = t.directional.positions; e.pointLightColor.value = t.point.colors; e.pointLightPosition.value = t.point.positions; e.pointLightDistance.value = t.point.distances; e.spotLightColor.value = t.spot.colors; e.spotLightPosition.value = t.spot.positions; e.spotLightDistance.value = t.spot.distances; e.spotLightDirection.value = t.spot.directions; e.spotLightAngleCos.value = t.spot.anglesCos; e.spotLightExponent.value = t.spot.exponents; e.hemisphereLightSkyColor.value = t.hemi.skyColors; e.hemisphereLightGroundColor.value = t.hemi.groundColors; e.hemisphereLightDirection.value = t.hemi.positions } function xn(e, t) { if (e.shadowMatrix) { var n = 0; for (var r = 0, i = t.length; r < i; r++) { var s = t[r]; if (!s.castShadow) continue; if (s instanceof THREE.DirectionalLight && !s.shadowCascade) { e.shadowMap.value[n] = s.shadowMap; e.shadowMapSize.value[n] = s.shadowMapSize; e.shadowMatrix.value[n] = s.shadowMatrix; e.shadowDarkness.value[n] = s.shadowDarkness; e.shadowBias.value[n] = s.shadowBias; n++ } } } } function Tn(e, t) { V.uniformMatrix4fv(e.modelViewMatrix, false, t._modelViewMatrix.elements); if (e.normalMatrix) { V.uniformMatrix3fv(e.normalMatrix, false, t._normalMatrix.elements) } } function Nn() { var e = b; if (e >= Y) { console.warn("WebGLRenderer: trying to use " + e + " texture units while this GPU supports only " + Y) } b += 1; return e } function Cn(e, t) { var n, r, i, s, o, u, a, f, c, h, p; for (c = 0, h = t.length; c < h; c++) { s = e.uniforms[t[c][1]]; if (!s) continue; n = t[c][0]; i = n.type; r = n.value; if (i === "i") { V.uniform1i(s, r) } else if (i === "f") { V.uniform1f(s, r) } else if (i === "v2") { V.uniform2f(s, r.x, r.y) } else if (i === "v3") { V.uniform3f(s, r.x, r.y, r.z) } else if (i === "v4") { V.uniform4f(s, r.x, r.y, r.z, r.w) } else if (i === "c") { V.uniform3f(s, r.r, r.g, r.b) } else if (i === "iv1") { V.uniform1iv(s, r) } else if (i === "iv") { V.uniform3iv(s, r) } else if (i === "fv1") { V.uniform1fv(s, r) } else if (i === "fv") { V.uniform3fv(s, r) } else if (i === "v2v") { if (n._array === undefined) { n._array = new Float32Array(2 * r.length) } for (a = 0, f = r.length; a < f; a++) { p = a * 2; n._array[p] = r[a].x; n._array[p + 1] = r[a].y } V.uniform2fv(s, n._array) } else if (i === "v3v") { if (n._array === undefined) { n._array = new Float32Array(3 * r.length) } for (a = 0, f = r.length; a < f; a++) { p = a * 3; n._array[p] = r[a].x; n._array[p + 1] = r[a].y; n._array[p + 2] = r[a].z } V.uniform3fv(s, n._array) } else if (i === "v4v") { if (n._array === undefined) { n._array = new Float32Array(4 * r.length) } for (a = 0, f = r.length; a < f; a++) { p = a * 4; n._array[p] = r[a].x; n._array[p + 1] = r[a].y; n._array[p + 2] = r[a].z; n._array[p + 3] = r[a].w } V.uniform4fv(s, n._array) } else if (i === "m4") { if (n._array === undefined) { n._array = new Float32Array(16) } r.flattenToArray(n._array); V.uniformMatrix4fv(s, false, n._array) } else if (i === "m4v") { if (n._array === undefined) { n._array = new Float32Array(16 * r.length) } for (a = 0, f = r.length; a < f; a++) { r[a].flattenToArrayOffset(n._array, a * 16) } V.uniformMatrix4fv(s, false, n._array) } else if (i === "t") { o = r; u = Nn(); V.uniform1i(s, u); if (!o) continue; if (o.image instanceof Array && o.image.length === 6) { Un(o, u) } else if (o instanceof THREE.WebGLRenderTargetCube) { zn(o, u) } else { l.setTexture(o, u) } } else if (i === "tv") { if (n._array === undefined) { n._array = [] } for (a = 0, f = n.value.length; a < f; a++) { n._array[a] = Nn() } V.uniform1iv(s, n._array); for (a = 0, f = n.value.length; a < f; a++) { o = n.value[a]; u = n._array[a]; if (!o) continue; l.setTexture(o, u) } } else { console.warn("THREE.WebGLRenderer: Unknown uniform type: " + i) } } } function kn(e, t) { e._modelViewMatrix.multiplyMatrices(t.matrixWorldInverse, e.matrixWorld); e._normalMatrix.getNormalMatrix(e._modelViewMatrix) } function Ln(e, t, n, r) { e[t] = n.r * n.r * r; e[t + 1] = n.g * n.g * r; e[t + 2] = n.b * n.b * r } function An(e, t, n, r) { e[t] = n.r * r; e[t + 1] = n.g * r; e[t + 2] = n.b * r } function On(e, t) { var n, r, i, s, o = 0, u = 0, a = 0, f, c, h, p, d, v, m, g = X, y = g.directional.colors, b = g.directional.positions, w = g.point.colors, E = g.point.positions, S = g.point.distances, x = g.spot.colors, T = g.spot.positions, N = g.spot.distances, C = g.spot.directions, k = g.spot.anglesCos, L = g.spot.exponents, A = g.hemi.skyColors, O = g.hemi.groundColors, M = g.hemi.positions, _ = 0, D = 0, P = 0, H = 0, B = 0, j = 0, F = 0, I = 0, q = 0, R = 0, W = 0, V = 0; for (n = 0, r = t.length; n < r; n++) { i = t[n]; if (i.onlyShadow) continue; f = i.color; p = i.intensity; m = i.distance; if (i instanceof THREE.AmbientLight) { if (!i.visible) continue; if (l.gammaInput) { o += f.r * f.r; u += f.g * f.g; a += f.b * f.b } else { o += f.r; u += f.g; a += f.b } } else if (i instanceof THREE.DirectionalLight) { B += 1; if (!i.visible) continue; z.getPositionFromMatrix(i.matrixWorld); U.getPositionFromMatrix(i.target.matrixWorld); z.sub(U); z.normalize(); if (z.x === 0 && z.y === 0 && z.z === 0) continue; q = _ * 3; b[q] = z.x; b[q + 1] = z.y; b[q + 2] = z.z; if (l.gammaInput) { Ln(y, q, f, p * p) } else { An(y, q, f, p) } _ += 1 } else if (i instanceof THREE.PointLight) { j += 1; if (!i.visible) continue; R = D * 3; if (l.gammaInput) { Ln(w, R, f, p * p) } else { An(w, R, f, p) } U.getPositionFromMatrix(i.matrixWorld); E[R] = U.x; E[R + 1] = U.y; E[R + 2] = U.z; S[D] = m; D += 1 } else if (i instanceof THREE.SpotLight) { F += 1; if (!i.visible) continue; W = P * 3; if (l.gammaInput) { Ln(x, W, f, p * p) } else { An(x, W, f, p) } U.getPositionFromMatrix(i.matrixWorld); T[W] = U.x; T[W + 1] = U.y; T[W + 2] = U.z; N[P] = m; z.copy(U); U.getPositionFromMatrix(i.target.matrixWorld); z.sub(U); z.normalize(); C[W] = z.x; C[W + 1] = z.y; C[W + 2] = z.z; k[P] = Math.cos(i.angle); L[P] = i.exponent; P += 1 } else if (i instanceof THREE.HemisphereLight) { I += 1; if (!i.visible) continue; z.getPositionFromMatrix(i.matrixWorld); z.normalize(); if (z.x === 0 && z.y === 0 && z.z === 0) continue; V = H * 3; M[V] = z.x; M[V + 1] = z.y; M[V + 2] = z.z; c = i.color; h = i.groundColor; if (l.gammaInput) { d = p * p; Ln(A, V, c, d); Ln(O, V, h, d) } else { An(A, V, c, p); An(O, V, h, p) } H += 1 } } for (n = _ * 3, r = Math.max(y.length, B * 3) ; n < r; n++) y[n] = 0; for (n = D * 3, r = Math.max(w.length, j * 3) ; n < r; n++) w[n] = 0; for (n = P * 3, r = Math.max(x.length, F * 3) ; n < r; n++) x[n] = 0; for (n = H * 3, r = Math.max(A.length, I * 3) ; n < r; n++) A[n] = 0; for (n = H * 3, r = Math.max(O.length, I * 3) ; n < r; n++) O[n] = 0; g.directional.length = _; g.point.length = D; g.spot.length = P; g.hemi.length = H; g.ambient[0] = o; g.ambient[1] = u; g.ambient[2] = a } function Mn(e) { if (e !== M) { V.lineWidth(e); M = e } } function _n(e, t, n) { if (L !== e) { if (e) { V.enable(V.POLYGON_OFFSET_FILL) } else { V.disable(V.POLYGON_OFFSET_FILL) } L = e } if (e && (A !== t || O !== n)) { V.polygonOffset(t, n); A = t; O = n } } function Dn(e) { var t, n, r = []; for (var i in e) { t = e[i]; if (t === false) continue; n = "#define " + i + " " + t; r.push(n) } return r.join("\n") } function Pn(e, t, r, i, s, o, u, a) { var f, p, d, v, m; var g = []; if (e) { g.push(e) } else { g.push(t); g.push(r) } for (d in o) { g.push(d); g.push(o[d]) } for (f in u) { g.push(f); g.push(u[f]) } m = g.join(); for (f = 0, p = c.length; f < p; f++) { var y = c[f]; if (y.code === m) { y.usedTimes++; return y.program } } var b = "SHADOWMAP_TYPE_BASIC"; if (u.shadowMapType === THREE.PCFShadowMap) { b = "SHADOWMAP_TYPE_PCF" } else if (u.shadowMapType === THREE.PCFSoftShadowMap) { b = "SHADOWMAP_TYPE_PCF_SOFT" } var w = Dn(o); v = V.createProgram(); var E = ["precision " + n + " float;", "precision " + n + " int;", w, rt ? "#define VERTEX_TEXTURES" : "", l.gammaInput ? "#define GAMMA_INPUT" : "", l.gammaOutput ? "#define GAMMA_OUTPUT" : "", l.physicallyBasedShading ? "#define PHYSICALLY_BASED_SHADING" : "", "#define MAX_DIR_LIGHTS " + u.maxDirLights, "#define MAX_POINT_LIGHTS " + u.maxPointLights, "#define MAX_SPOT_LIGHTS " + u.maxSpotLights, "#define MAX_HEMI_LIGHTS " + u.maxHemiLights, "#define MAX_SHADOWS " + u.maxShadows, "#define MAX_BONES " + u.maxBones, u.map ? "#define USE_MAP" : "", u.envMap ? "#define USE_ENVMAP" : "", u.lightMap ? "#define USE_LIGHTMAP" : "", u.bumpMap ? "#define USE_BUMPMAP" : "", u.normalMap ? "#define USE_NORMALMAP" : "", u.specularMap ? "#define USE_SPECULARMAP" : "", u.vertexColors ? "#define USE_COLOR" : "", u.skinning ? "#define USE_SKINNING" : "", u.useVertexTexture ? "#define BONE_TEXTURE" : "", u.morphTargets ? "#define USE_MORPHTARGETS" : "", u.morphNormals ? "#define USE_MORPHNORMALS" : "", u.perPixel ? "#define PHONG_PER_PIXEL" : "", u.wrapAround ? "#define WRAP_AROUND" : "", u.doubleSided ? "#define DOUBLE_SIDED" : "", u.flipSided ? "#define FLIP_SIDED" : "", u.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", u.shadowMapEnabled ? "#define " + b : "", u.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", u.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", u.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "attribute vec2 uv2;", "#ifdef USE_COLOR", "attribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "attribute vec3 morphTarget0;", "attribute vec3 morphTarget1;", "attribute vec3 morphTarget2;", "attribute vec3 morphTarget3;", "#ifdef USE_MORPHNORMALS", "attribute vec3 morphNormal0;", "attribute vec3 morphNormal1;", "attribute vec3 morphNormal2;", "attribute vec3 morphNormal3;", "#else", "attribute vec3 morphTarget4;", "attribute vec3 morphTarget5;", "attribute vec3 morphTarget6;", "attribute vec3 morphTarget7;", "#endif", "#endif", "#ifdef USE_SKINNING", "attribute vec4 skinIndex;", "attribute vec4 skinWeight;", "#endif", ""].join("\n"); var S = ["precision " + n + " float;", "precision " + n + " int;", u.bumpMap || u.normalMap ? "#extension GL_OES_standard_derivatives : enable" : "", w, "#define MAX_DIR_LIGHTS " + u.maxDirLights, "#define MAX_POINT_LIGHTS " + u.maxPointLights, "#define MAX_SPOT_LIGHTS " + u.maxSpotLights, "#define MAX_HEMI_LIGHTS " + u.maxHemiLights, "#define MAX_SHADOWS " + u.maxShadows, u.alphaTest ? "#define ALPHATEST " + u.alphaTest : "", l.gammaInput ? "#define GAMMA_INPUT" : "", l.gammaOutput ? "#define GAMMA_OUTPUT" : "", l.physicallyBasedShading ? "#define PHYSICALLY_BASED_SHADING" : "", u.useFog && u.fog ? "#define USE_FOG" : "", u.useFog && u.fogExp ? "#define FOG_EXP2" : "", u.map ? "#define USE_MAP" : "", u.envMap ? "#define USE_ENVMAP" : "", u.lightMap ? "#define USE_LIGHTMAP" : "", u.bumpMap ? "#define USE_BUMPMAP" : "", u.normalMap ? "#define USE_NORMALMAP" : "", u.specularMap ? "#define USE_SPECULARMAP" : "", u.vertexColors ? "#define USE_COLOR" : "", u.metal ? "#define METAL" : "", u.perPixel ? "#define PHONG_PER_PIXEL" : "", u.wrapAround ? "#define WRAP_AROUND" : "", u.doubleSided ? "#define DOUBLE_SIDED" : "", u.flipSided ? "#define FLIP_SIDED" : "", u.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", u.shadowMapEnabled ? "#define " + b : "", u.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", u.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", ""].join("\n"); var x = Fn("vertex", E + r); var T = Fn("fragment", S + t); V.attachShader(v, x); V.attachShader(v, T); if (a) { V.bindAttribLocation(v, 0, a) } V.linkProgram(v); if (!V.getProgramParameter(v, V.LINK_STATUS)) { console.error("Could not initialise shader\n" + "VALIDATE_STATUS: " + V.getProgramParameter(v, V.VALIDATE_STATUS) + ", gl error [" + V.getError() + "]"); console.error("Program Info Log: " + V.getProgramInfoLog(v)) } V.deleteShader(T); V.deleteShader(x); v.uniforms = {}; v.attributes = {}; var N, C, k, L; N = ["viewMatrix", "modelViewMatrix", "projectionMatrix", "normalMatrix", "modelMatrix", "cameraPosition", "morphTargetInfluences"]; if (u.useVertexTexture) { N.push("boneTexture"); N.push("boneTextureWidth"); N.push("boneTextureHeight") } else { N.push("boneGlobalMatrices") } for (C in i) { N.push(C) } Hn(v, N); N = ["position", "normal", "uv", "uv2", "tangent", "color", "skinIndex", "skinWeight", "lineDistance"]; for (L = 0; L < u.maxMorphTargets; L++) { N.push("morphTarget" + L) } for (L = 0; L < u.maxMorphNormals; L++) { N.push("morphNormal" + L) } for (k in s) { N.push(k) } Bn(v, N); v.id = h++; c.push({ program: v, code: m, usedTimes: 1 }); l.info.memory.programs = c.length; return v } function Hn(e, t) { var n, r, i; for (n = 0, r = t.length; n < r; n++) { i = t[n]; e.uniforms[i] = V.getUniformLocation(e, i) } } function Bn(e, t) { var n, r, i; for (n = 0, r = t.length; n < r; n++) { i = t[n]; e.attributes[i] = V.getAttribLocation(e, i) } } function jn(e) { var t = e.split("\n"); for (var n = 0, r = t.length; n < r; n++) { t[n] = n + 1 + ": " + t[n] } return t.join("\n") } function Fn(e, t) { var n; if (e === "fragment") { n = V.createShader(V.FRAGMENT_SHADER) } else if (e === "vertex") { n = V.createShader(V.VERTEX_SHADER) } V.shaderSource(n, t); V.compileShader(n); if (!V.getShaderParameter(n, V.COMPILE_STATUS)) { console.error(V.getShaderInfoLog(n)); console.error(jn(t)); return null } return n } function In(e) { return (e & e - 1) === 0 } function qn(e, t, n) { if (n) { V.texParameteri(e, V.TEXTURE_WRAP_S, Jn(t.wrapS)); V.texParameteri(e, V.TEXTURE_WRAP_T, Jn(t.wrapT)); V.texParameteri(e, V.TEXTURE_MAG_FILTER, Jn(t.magFilter)); V.texParameteri(e, V.TEXTURE_MIN_FILTER, Jn(t.minFilter)) } else { V.texParameteri(e, V.TEXTURE_WRAP_S, V.CLAMP_TO_EDGE); V.texParameteri(e, V.TEXTURE_WRAP_T, V.CLAMP_TO_EDGE); V.texParameteri(e, V.TEXTURE_MAG_FILTER, $n(t.magFilter)); V.texParameteri(e, V.TEXTURE_MIN_FILTER, $n(t.minFilter)) } if (Q && t.type !== THREE.FloatType) { if (t.anisotropy > 1 || t.__oldAnisotropy) { V.texParameterf(e, Q.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(t.anisotropy, nt)); t.__oldAnisotropy = t.anisotropy } } } function Rn(e, t) { if (e.width <= t && e.height <= t) { return e } var n = Math.max(e.width, e.height); var r = Math.floor(e.width * t / n); var i = Math.floor(e.height * t / n); var s = document.createElement("canvas"); s.width = r; s.height = i; var o = s.getContext("2d"); o.drawImage(e, 0, 0, e.width, e.height, 0, 0, r, i); return s } function Un(e, t) { if (e.image.length === 6) { if (e.needsUpdate) { if (!e.image.__webglTextureCube) { e.addEventListener("dispose", Tt); e.image.__webglTextureCube = V.createTexture(); l.info.memory.textures++ } V.activeTexture(V.TEXTURE0 + t); V.bindTexture(V.TEXTURE_CUBE_MAP, e.image.__webglTextureCube); V.pixelStorei(V.UNPACK_FLIP_Y_WEBGL, e.flipY); var n = e instanceof THREE.CompressedTexture; var r = []; for (var i = 0; i < 6; i++) { if (l.autoScaleCubemaps && !n) { r[i] = Rn(e.image[i], tt) } else { r[i] = e.image[i] } } var s = r[0], o = In(s.width) && In(s.height), u = Jn(e.format), a = Jn(e.type); qn(V.TEXTURE_CUBE_MAP, e, o); for (var i = 0; i < 6; i++) { if (!n) { V.texImage2D(V.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, u, u, a, r[i]) } else { var f, c = r[i].mipmaps; for (var h = 0, p = c.length; h < p; h++) { f = c[h]; if (e.format !== THREE.RGBAFormat) { V.compressedTexImage2D(V.TEXTURE_CUBE_MAP_POSITIVE_X + i, h, u, f.width, f.height, 0, f.data) } else { V.texImage2D(V.TEXTURE_CUBE_MAP_POSITIVE_X + i, h, u, f.width, f.height, 0, u, a, f.data) } } } } if (e.generateMipmaps && o) { V.generateMipmap(V.TEXTURE_CUBE_MAP) } e.needsUpdate = false; if (e.onUpdate) e.onUpdate() } else { V.activeTexture(V.TEXTURE0 + t); V.bindTexture(V.TEXTURE_CUBE_MAP, e.image.__webglTextureCube) } } } function zn(e, t) { V.activeTexture(V.TEXTURE0 + t); V.bindTexture(V.TEXTURE_CUBE_MAP, e.__webglTexture) } function Wn(e, t, n) { V.bindFramebuffer(V.FRAMEBUFFER, e); V.framebufferTexture2D(V.FRAMEBUFFER, V.COLOR_ATTACHMENT0, n, t.__webglTexture, 0) } function Xn(e, t) { V.bindRenderbuffer(V.RENDERBUFFER, e); if (t.depthBuffer && !t.stencilBuffer) { V.renderbufferStorage(V.RENDERBUFFER, V.DEPTH_COMPONENT16, t.width, t.height); V.framebufferRenderbuffer(V.FRAMEBUFFER, V.DEPTH_ATTACHMENT, V.RENDERBUFFER, e) } else if (t.depthBuffer && t.stencilBuffer) { V.renderbufferStorage(V.RENDERBUFFER, V.DEPTH_STENCIL, t.width, t.height); V.framebufferRenderbuffer(V.FRAMEBUFFER, V.DEPTH_STENCIL_ATTACHMENT, V.RENDERBUFFER, e) } else { V.renderbufferStorage(V.RENDERBUFFER, V.RGBA4, t.width, t.height) } } function Vn(e) { if (e instanceof THREE.WebGLRenderTargetCube) { V.bindTexture(V.TEXTURE_CUBE_MAP, e.__webglTexture); V.generateMipmap(V.TEXTURE_CUBE_MAP); V.bindTexture(V.TEXTURE_CUBE_MAP, null) } else { V.bindTexture(V.TEXTURE_2D, e.__webglTexture); V.generateMipmap(V.TEXTURE_2D); V.bindTexture(V.TEXTURE_2D, null) } } function $n(e) { if (e === THREE.NearestFilter || e === THREE.NearestMipMapNearestFilter || e === THREE.NearestMipMapLinearFilter) { return V.NEAREST } return V.LINEAR } function Jn(e) { if (e === THREE.RepeatWrapping) return V.REPEAT; if (e === THREE.ClampToEdgeWrapping) return V.CLAMP_TO_EDGE; if (e === THREE.MirroredRepeatWrapping) return V.MIRRORED_REPEAT; if (e === THREE.NearestFilter) return V.NEAREST; if (e === THREE.NearestMipMapNearestFilter) return V.NEAREST_MIPMAP_NEAREST; if (e === THREE.NearestMipMapLinearFilter) return V.NEAREST_MIPMAP_LINEAR; if (e === THREE.LinearFilter) return V.LINEAR; if (e === THREE.LinearMipMapNearestFilter) return V.LINEAR_MIPMAP_NEAREST; if (e === THREE.LinearMipMapLinearFilter) return V.LINEAR_MIPMAP_LINEAR; if (e === THREE.UnsignedByteType) return V.UNSIGNED_BYTE; if (e === THREE.UnsignedShort4444Type) return V.UNSIGNED_SHORT_4_4_4_4; if (e === THREE.UnsignedShort5551Type) return V.UNSIGNED_SHORT_5_5_5_1; if (e === THREE.UnsignedShort565Type) return V.UNSIGNED_SHORT_5_6_5; if (e === THREE.ByteType) return V.BYTE; if (e === THREE.ShortType) return V.SHORT; if (e === THREE.UnsignedShortType) return V.UNSIGNED_SHORT; if (e === THREE.IntType) return V.INT; if (e === THREE.UnsignedIntType) return V.UNSIGNED_INT; if (e === THREE.FloatType) return V.FLOAT; if (e === THREE.AlphaFormat) return V.ALPHA; if (e === THREE.RGBFormat) return V.RGB; if (e === THREE.RGBAFormat) return V.RGBA; if (e === THREE.LuminanceFormat) return V.LUMINANCE; if (e === THREE.LuminanceAlphaFormat) return V.LUMINANCE_ALPHA; if (e === THREE.AddEquation) return V.FUNC_ADD; if (e === THREE.SubtractEquation) return V.FUNC_SUBTRACT; if (e === THREE.ReverseSubtractEquation) return V.FUNC_REVERSE_SUBTRACT; if (e === THREE.ZeroFactor) return V.ZERO; if (e === THREE.OneFactor) return V.ONE; if (e === THREE.SrcColorFactor) return V.SRC_COLOR; if (e === THREE.OneMinusSrcColorFactor) return V.ONE_MINUS_SRC_COLOR; if (e === THREE.SrcAlphaFactor) return V.SRC_ALPHA; if (e === THREE.OneMinusSrcAlphaFactor) return V.ONE_MINUS_SRC_ALPHA; if (e === THREE.DstAlphaFactor) return V.DST_ALPHA; if (e === THREE.OneMinusDstAlphaFactor) return V.ONE_MINUS_DST_ALPHA; if (e === THREE.DstColorFactor) return V.DST_COLOR; if (e === THREE.OneMinusDstColorFactor) return V.ONE_MINUS_DST_COLOR; if (e === THREE.SrcAlphaSaturateFactor) return V.SRC_ALPHA_SATURATE; if (G !== undefined) { if (e === THREE.RGB_S3TC_DXT1_Format) return G.COMPRESSED_RGB_S3TC_DXT1_EXT; if (e === THREE.RGBA_S3TC_DXT1_Format) return G.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (e === THREE.RGBA_S3TC_DXT3_Format) return G.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (e === THREE.RGBA_S3TC_DXT5_Format) return G.COMPRESSED_RGBA_S3TC_DXT5_EXT } return 0 } function Kn(e) { if (it && e && e.useVertexTexture) { return 1024 } else { var t = V.getParameter(V.MAX_VERTEX_UNIFORM_VECTORS); var n = Math.floor((t - 20) / 4); var r = n; return r } } function Qn(e) { var t = 0; var n = 0; var r = 0; var i = 0; for (var s = 0, o = e.length; s < o; s++) { var u = e[s]; if (u.onlyShadow) continue; if (u instanceof THREE.DirectionalLight) t++; if (u instanceof THREE.PointLight) n++ } return { directional: t, point: n, spot: r, hemi: i } } function Gn(e) { var t = 0; for (var n = 0, r = e.length; n < r; n++) { var i = e[n]; if (!i.castShadow) continue; if (i instanceof THREE.DirectionalLight && !i.shadowCascade) t++ } return t } function Yn() { try { var e = { alpha: r, premultipliedAlpha: i, antialias: s, stencil: o, preserveDrawingBuffer: u }; V = t.getContext("webgl", e) || t.getContext("experimental-webgl", e); if (V === null) { throw "Error creating WebGL context." } } catch (n) { console.error(n) } $ = V.getExtension("OES_texture_float"); J = V.getExtension("OES_texture_float_linear"); K = V.getExtension("OES_standard_derivatives"); Q = V.getExtension("EXT_texture_filter_anisotropic") || V.getExtension("MOZ_EXT_texture_filter_anisotropic") || V.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); G = V.getExtension("WEBGL_compressed_texture_s3tc") || V.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || V.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); if (!$) { console.log("THREE.WebGLRenderer: Float textures not supported.") } if (!K) { console.log("THREE.WebGLRenderer: Standard derivatives not supported.") } if (!Q) { console.log("THREE.WebGLRenderer: Anisotropic texture filtering not supported.") } if (!G) { console.log("THREE.WebGLRenderer: S3TC compressed textures not supported.") } if (V.getShaderPrecisionFormat === undefined) { V.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } } } } function Zn() { V.clearColor(0, 0, 0, 1); V.clearDepth(1); V.clearStencil(0); V.enable(V.DEPTH_TEST); V.depthFunc(V.LEQUAL); V.frontFace(V.CCW); V.cullFace(V.BACK); V.enable(V.CULL_FACE); V.enable(V.BLEND); V.blendEquation(V.FUNC_ADD); V.blendFunc(V.SRC_ALPHA, V.ONE_MINUS_SRC_ALPHA); V.clearColor(a.r, a.g, a.b, f) } console.log("THREE.WebGLRenderer", THREE.REVISION); e = e || {}; var t = e.canvas !== undefined ? e.canvas : document.createElement("canvas"), n = e.precision !== undefined ? e.precision : "highp", r = e.alpha !== undefined ? e.alpha : true, i = e.premultipliedAlpha !== undefined ? e.premultipliedAlpha : true, s = e.antialias !== undefined ? e.antialias : false, o = e.stencil !== undefined ? e.stencil : true, u = e.preserveDrawingBuffer !== undefined ? e.preserveDrawingBuffer : false, a = new THREE.Color(0), f = 0; this.domElement = t; this.context = null; this.devicePixelRatio = e.devicePixelRatio !== undefined ? e.devicePixelRatio : self.devicePixelRatio !== undefined ? self.devicePixelRatio : 1; this.autoClear = true; this.autoClearColor = true; this.autoClearDepth = true; this.autoClearStencil = true; this.sortObjects = true; this.autoUpdateObjects = true; this.gammaInput = false; this.gammaOutput = false; this.physicallyBasedShading = false; this.shadowMapEnabled = false; this.shadowMapAutoUpdate = true; this.shadowMapType = THREE.PCFShadowMap; this.shadowMapCullFace = THREE.CullFaceFront; this.shadowMapDebug = false; this.shadowMapCascade = false; this.maxMorphTargets = 8; this.maxMorphNormals = 4; this.autoScaleCubemaps = true; this.renderPluginsPre = []; this.renderPluginsPost = []; this.info = { memory: { programs: 0, geometries: 0, textures: 0 }, render: { calls: 0, vertices: 0, faces: 0, points: 0 } }; var l = this, c = [], h = 0, p = null, d = null, v = -1, m = null, g = null, y = 0, b = 0, w = -1, E = -1, S = -1, x = -1, T = -1, N = -1, C = -1, k = -1, L = null, A = null, O = null, M = null, _ = 0, D = 0, P = 0, H = 0, B = 0, j = 0, F = {}, I = new THREE.Frustum, q = new THREE.Matrix4, R = new THREE.Matrix4, U = new THREE.Vector3, z = new THREE.Vector3, W = true, X = { ambient: [0, 0, 0], directional: { length: 0, colors: new Array, positions: new Array }, point: { length: 0, colors: new Array, positions: new Array, distances: new Array }, spot: { length: 0, colors: new Array, positions: new Array, distances: new Array, directions: new Array, anglesCos: new Array, exponents: new Array }, hemi: { length: 0, skyColors: new Array, groundColors: new Array, positions: new Array } }; var V; var $; var J; var K; var Q; var G; Yn(); Zn(); this.context = V; var Y = V.getParameter(V.MAX_TEXTURE_IMAGE_UNITS); var Z = V.getParameter(V.MAX_VERTEX_TEXTURE_IMAGE_UNITS); var et = V.getParameter(V.MAX_TEXTURE_SIZE); var tt = V.getParameter(V.MAX_CUBE_MAP_TEXTURE_SIZE); var nt = Q ? V.getParameter(Q.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0; var rt = Z > 0; var it = rt && $; var st = G ? V.getParameter(V.COMPRESSED_TEXTURE_FORMATS) : []; var ot = V.getShaderPrecisionFormat(V.VERTEX_SHADER, V.HIGH_FLOAT); var ut = V.getShaderPrecisionFormat(V.VERTEX_SHADER, V.MEDIUM_FLOAT); var at = V.getShaderPrecisionFormat(V.VERTEX_SHADER, V.LOW_FLOAT); var ft = V.getShaderPrecisionFormat(V.FRAGMENT_SHADER, V.HIGH_FLOAT); var lt = V.getShaderPrecisionFormat(V.FRAGMENT_SHADER, V.MEDIUM_FLOAT); var ct = V.getShaderPrecisionFormat(V.FRAGMENT_SHADER, V.LOW_FLOAT); var ht = V.getShaderPrecisionFormat(V.VERTEX_SHADER, V.HIGH_INT); var pt = V.getShaderPrecisionFormat(V.VERTEX_SHADER, V.MEDIUM_INT); var dt = V.getShaderPrecisionFormat(V.VERTEX_SHADER, V.LOW_INT); var vt = V.getShaderPrecisionFormat(V.FRAGMENT_SHADER, V.HIGH_INT); var mt = V.getShaderPrecisionFormat(V.FRAGMENT_SHADER, V.MEDIUM_INT); var gt = V.getShaderPrecisionFormat(V.FRAGMENT_SHADER, V.LOW_INT); var yt = ot.precision > 0 && ft.precision > 0; var bt = ut.precision > 0 && lt.precision > 0; if (n === "highp" && !yt) { if (bt) { n = "mediump"; console.warn("WebGLRenderer: highp not supported, using mediump") } else { n = "lowp"; console.warn("WebGLRenderer: highp and mediump not supported, using lowp") } } if (n === "mediump" && !bt) { n = "lowp"; console.warn("WebGLRenderer: mediump not supported, using lowp") } this.getContext = function () { return V }; this.supportsVertexTextures = function () { return rt }; this.supportsFloatTextures = function () { return $ }; this.supportsStandardDerivatives = function () { return K }; this.supportsCompressedTextureS3TC = function () { return G }; this.getMaxAnisotropy = function () { return nt }; this.getPrecision = function () { return n }; this.setSize = function (e, n, r) { t.width = e * this.devicePixelRatio; t.height = n * this.devicePixelRatio; if (this.devicePixelRatio !== 1 && r !== false) { t.style.width = e + "px"; t.style.height = n + "px" } this.setViewport(0, 0, t.width, t.height) }; this.setViewport = function (e, n, r, i) { _ = e !== undefined ? e : 0; D = n !== undefined ? n : 0; P = r !== undefined ? r : t.width; H = i !== undefined ? i : t.height; V.viewport(_, D, P, H) }; this.setScissor = function (e, t, n, r) { V.scissor(e, t, n, r) }; this.enableScissorTest = function (e) { e ? V.enable(V.SCISSOR_TEST) : V.disable(V.SCISSOR_TEST) }; this.setClearColor = function (e, t) { a.set(e); f = t !== undefined ? t : 1; V.clearColor(a.r, a.g, a.b, f) }; this.setClearColorHex = function (e, t) { console.warn("DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead."); this.setClearColor(e, t) }; this.getClearColor = function () { return a }; this.getClearAlpha = function () { return f }; this.clear = function (e, t, n) { var r = 0; if (e === undefined || e) r |= V.COLOR_BUFFER_BIT; if (t === undefined || t) r |= V.DEPTH_BUFFER_BIT; if (n === undefined || n) r |= V.STENCIL_BUFFER_BIT; V.clear(r) }; this.clearTarget = function (e, t, n, r) { this.setRenderTarget(e); this.clear(t, n, r) }; this.addPostPlugin = function (e) { e.init(this); this.renderPluginsPost.push(e) }; this.addPrePlugin = function (e) { e.init(this); this.renderPluginsPre.push(e) }; this.updateShadowMap = function (e, t) { p = null; S = -1; C = -1; k = -1; m = -1; v = -1; W = true; w = -1; E = -1; this.shadowMapPlugin.update(e, t) }; var xt = function (e) { var t = e.target; t.removeEventListener("dispose", xt); Lt(t) }; var Tt = function (e) { var t = e.target; t.removeEventListener("dispose", Tt); At(t); l.info.memory.textures-- }; var Nt = function (e) { var t = e.target; t.removeEventListener("dispose", Nt); Ot(t); l.info.memory.textures-- }; var Ct = function (e) { var t = e.target; t.removeEventListener("dispose", Ct); Mt(t) }; var kt = function (e) { if (e.__webglVertexBuffer !== undefined) V.deleteBuffer(e.__webglVertexBuffer); if (e.__webglNormalBuffer !== undefined) V.deleteBuffer(e.__webglNormalBuffer); if (e.__webglTangentBuffer !== undefined) V.deleteBuffer(e.__webglTangentBuffer); if (e.__webglColorBuffer !== undefined) V.deleteBuffer(e.__webglColorBuffer); if (e.__webglUVBuffer !== undefined) V.deleteBuffer(e.__webglUVBuffer); if (e.__webglUV2Buffer !== undefined) V.deleteBuffer(e.__webglUV2Buffer); if (e.__webglSkinIndicesBuffer !== undefined) V.deleteBuffer(e.__webglSkinIndicesBuffer); if (e.__webglSkinWeightsBuffer !== undefined) V.deleteBuffer(e.__webglSkinWeightsBuffer); if (e.__webglFaceBuffer !== undefined) V.deleteBuffer(e.__webglFaceBuffer); if (e.__webglLineBuffer !== undefined) V.deleteBuffer(e.__webglLineBuffer); if (e.__webglLineDistanceBuffer !== undefined) V.deleteBuffer(e.__webglLineDistanceBuffer); if (e.__webglCustomAttributesList !== undefined) { for (var t in e.__webglCustomAttributesList) { V.deleteBuffer(e.__webglCustomAttributesList[t].buffer) } } l.info.memory.geometries-- }; var Lt = function (e) { e.__webglInit = undefined; if (e instanceof THREE.BufferGeometry) { var t = e.attributes; for (var n in t) { if (t[n].buffer !== undefined) { V.deleteBuffer(t[n].buffer) } } l.info.memory.geometries-- } else { if (e.geometryGroups !== undefined) { for (var r in e.geometryGroups) { var i = e.geometryGroups[r]; if (i.numMorphTargets !== undefined) { for (var s = 0, o = i.numMorphTargets; s < o; s++) { V.deleteBuffer(i.__webglMorphTargetsBuffers[s]) } } if (i.numMorphNormals !== undefined) { for (var s = 0, o = i.numMorphNormals; s < o; s++) { V.deleteBuffer(i.__webglMorphNormalsBuffers[s]) } } kt(i) } } else { kt(e) } } }; var At = function (e) { if (e.image && e.image.__webglTextureCube) { V.deleteTexture(e.image.__webglTextureCube) } else { if (!e.__webglInit) return; e.__webglInit = false; V.deleteTexture(e.__webglTexture) } }; var Ot = function (e) { if (!e || !e.__webglTexture) return; V.deleteTexture(e.__webglTexture); if (e instanceof THREE.WebGLRenderTargetCube) { for (var t = 0; t < 6; t++) { V.deleteFramebuffer(e.__webglFramebuffer[t]); V.deleteRenderbuffer(e.__webglRenderbuffer[t]) } } else { V.deleteFramebuffer(e.__webglFramebuffer); V.deleteRenderbuffer(e.__webglRenderbuffer) } }; var Mt = function (e) { var t = e.program; if (t === undefined) return; e.program = undefined; var n, r, i; var s = false; for (n = 0, r = c.length; n < r; n++) { i = c[n]; if (i.program === t) { i.usedTimes--; if (i.usedTimes === 0) { s = true } break } } if (s === true) { var o = []; for (n = 0, r = c.length; n < r; n++) { i = c[n]; if (i.program !== t) { o.push(i) } } c = o; V.deleteProgram(t); l.info.memory.programs-- } }; this.renderBufferImmediate = function (e, t, n) { if (e.hasPositions && !e.__webglVertexBuffer) e.__webglVertexBuffer = V.createBuffer(); if (e.hasNormals && !e.__webglNormalBuffer) e.__webglNormalBuffer = V.createBuffer(); if (e.hasUvs && !e.__webglUvBuffer) e.__webglUvBuffer = V.createBuffer(); if (e.hasColors && !e.__webglColorBuffer) e.__webglColorBuffer = V.createBuffer(); if (e.hasPositions) { V.bindBuffer(V.ARRAY_BUFFER, e.__webglVertexBuffer); V.bufferData(V.ARRAY_BUFFER, e.positionArray, V.DYNAMIC_DRAW); V.enableVertexAttribArray(t.attributes.position); V.vertexAttribPointer(t.attributes.position, 3, V.FLOAT, false, 0, 0) } if (e.hasNormals) { V.bindBuffer(V.ARRAY_BUFFER, e.__webglNormalBuffer); if (n.shading === THREE.FlatShading) { var r, i, s, o, u, a, f, l, c, h, p, d, v, m, g = e.count * 3; for (m = 0; m < g; m += 9) { v = e.normalArray; o = v[m]; f = v[m + 1]; h = v[m + 2]; u = v[m + 3]; l = v[m + 4]; p = v[m + 5]; a = v[m + 6]; c = v[m + 7]; d = v[m + 8]; r = (o + u + a) / 3; i = (f + l + c) / 3; s = (h + p + d) / 3; v[m] = r; v[m + 1] = i; v[m + 2] = s; v[m + 3] = r; v[m + 4] = i; v[m + 5] = s; v[m + 6] = r; v[m + 7] = i; v[m + 8] = s } } V.bufferData(V.ARRAY_BUFFER, e.normalArray, V.DYNAMIC_DRAW); V.enableVertexAttribArray(t.attributes.normal); V.vertexAttribPointer(t.attributes.normal, 3, V.FLOAT, false, 0, 0) } if (e.hasUvs && n.map) { V.bindBuffer(V.ARRAY_BUFFER, e.__webglUvBuffer); V.bufferData(V.ARRAY_BUFFER, e.uvArray, V.DYNAMIC_DRAW); V.enableVertexAttribArray(t.attributes.uv); V.vertexAttribPointer(t.attributes.uv, 2, V.FLOAT, false, 0, 0) } if (e.hasColors && n.vertexColors !== THREE.NoColors) { V.bindBuffer(V.ARRAY_BUFFER, e.__webglColorBuffer); V.bufferData(V.ARRAY_BUFFER, e.colorArray, V.DYNAMIC_DRAW); V.enableVertexAttribArray(t.attributes.color); V.vertexAttribPointer(t.attributes.color, 3, V.FLOAT, false, 0, 0) } V.drawArrays(V.TRIANGLES, 0, e.count); e.count = 0 }; this.renderBufferDirect = function (e, t, n, r, i, s) { if (r.visible === false) return; var o, u, a; var f, c, h, p; var d = dn(e, t, n, r, s); var v = d.attributes; var g = i.attributes; var y = false, b = r.wireframe ? 1 : 0, w = i.id * 16777215 + d.id * 2 + b; if (w !== m) { m = w; y = true } if (y) { $t() } if (s instanceof THREE.Mesh) { var E = g["index"]; if (E) { var S = i.offsets; if (S.length > 1) y = true; for (var x = 0, T = S.length; x < T; x++) { var N = S[x].index; if (y) { for (c in v) { h = v[c]; f = g[c]; if (h >= 0) { if (f) { p = f.itemSize; V.bindBuffer(V.ARRAY_BUFFER, f.buffer); Vt(h); V.vertexAttribPointer(h, p, V.FLOAT, false, 0, N * p * 4) } else if (r.defaultAttributeValues) { if (r.defaultAttributeValues[c].length === 2) { V.vertexAttrib2fv(h, r.defaultAttributeValues[c]) } else if (r.defaultAttributeValues[c].length === 3) { V.vertexAttrib3fv(h, r.defaultAttributeValues[c]) } } } } V.bindBuffer(V.ELEMENT_ARRAY_BUFFER, E.buffer) } V.drawElements(V.TRIANGLES, S[x].count, V.UNSIGNED_SHORT, S[x].start * 2); l.info.render.calls++; l.info.render.vertices += S[x].count; l.info.render.faces += S[x].count / 3 } } else { if (y) { for (c in v) { if (c === "index") continue; h = v[c]; f = g[c]; if (h >= 0) { if (f) { p = f.itemSize; V.bindBuffer(V.ARRAY_BUFFER, f.buffer); Vt(h); V.vertexAttribPointer(h, p, V.FLOAT, false, 0, 0) } else if (r.defaultAttributeValues && r.defaultAttributeValues[c]) { if (r.defaultAttributeValues[c].length === 2) { V.vertexAttrib2fv(h, r.defaultAttributeValues[c]) } else if (r.defaultAttributeValues[c].length === 3) { V.vertexAttrib3fv(h, r.defaultAttributeValues[c]) } } } } } var C = i.attributes["position"]; V.drawArrays(V.TRIANGLES, 0, C.numItems / 3); l.info.render.calls++; l.info.render.vertices += C.numItems / 3; l.info.render.faces += C.numItems / 3 / 3 } } else if (s instanceof THREE.ParticleSystem) { if (y) { for (c in v) { h = v[c]; f = g[c]; if (h >= 0) { if (f) { p = f.itemSize; V.bindBuffer(V.ARRAY_BUFFER, f.buffer); Vt(h); V.vertexAttribPointer(h, p, V.FLOAT, false, 0, 0) } else if (r.defaultAttributeValues && r.defaultAttributeValues[c]) { if (r.defaultAttributeValues[c].length === 2) { V.vertexAttrib2fv(h, r.defaultAttributeValues[c]) } else if (r.defaultAttributeValues[c].length === 3) { V.vertexAttrib3fv(h, r.defaultAttributeValues[c]) } } } } var C = g["position"]; V.drawArrays(V.POINTS, 0, C.numItems / 3); l.info.render.calls++; l.info.render.points += C.numItems / 3 } } else if (s instanceof THREE.Line) { if (y) { for (c in v) { h = v[c]; f = g[c]; if (h >= 0) { if (f) { p = f.itemSize; V.bindBuffer(V.ARRAY_BUFFER, f.buffer); Vt(h); V.vertexAttribPointer(h, p, V.FLOAT, false, 0, 0) } else if (r.defaultAttributeValues && r.defaultAttributeValues[c]) { if (r.defaultAttributeValues[c].length === 2) { V.vertexAttrib2fv(h, r.defaultAttributeValues[c]) } else if (r.defaultAttributeValues[c].length === 3) { V.vertexAttrib3fv(h, r.defaultAttributeValues[c]) } } } } var k = s.type === THREE.LineStrip ? V.LINE_STRIP : V.LINES; Mn(r.linewidth); var C = g["position"]; V.drawArrays(k, 0, C.numItems / 3); l.info.render.calls++; l.info.render.points += C.numItems } } }; this.renderBuffer = function (e, t, n, r, i, s) { if (r.visible === false) return; var o, u, a, f, c; var h = dn(e, t, n, r, s); var p = h.attributes; var d = false, v = r.wireframe ? 1 : 0, g = i.id * 16777215 + h.id * 2 + v; if (g !== m) { m = g; d = true } if (d) { $t() } if (!r.morphTargets && p.position >= 0) { if (d) { V.bindBuffer(V.ARRAY_BUFFER, i.__webglVertexBuffer); Vt(p.position); V.vertexAttribPointer(p.position, 3, V.FLOAT, false, 0, 0) } } else { if (s.morphTargetBase) { Jt(r, i, s) } } if (d) { if (i.__webglCustomAttributesList) { for (f = 0, c = i.__webglCustomAttributesList.length; f < c; f++) { a = i.__webglCustomAttributesList[f]; if (p[a.buffer.belongsToAttribute] >= 0) { V.bindBuffer(V.ARRAY_BUFFER, a.buffer); Vt(p[a.buffer.belongsToAttribute]); V.vertexAttribPointer(p[a.buffer.belongsToAttribute], a.size, V.FLOAT, false, 0, 0) } } } if (p.color >= 0) { if (s.geometry.colors.length > 0 || s.geometry.faces.length > 0) { V.bindBuffer(V.ARRAY_BUFFER, i.__webglColorBuffer); Vt(p.color); V.vertexAttribPointer(p.color, 3, V.FLOAT, false, 0, 0) } else if (r.defaultAttributeValues) { V.vertexAttrib3fv(p.color, r.defaultAttributeValues.color) } } if (p.normal >= 0) { V.bindBuffer(V.ARRAY_BUFFER, i.__webglNormalBuffer); Vt(p.normal); V.vertexAttribPointer(p.normal, 3, V.FLOAT, false, 0, 0) } if (p.tangent >= 0) { V.bindBuffer(V.ARRAY_BUFFER, i.__webglTangentBuffer); Vt(p.tangent); V.vertexAttribPointer(p.tangent, 4, V.FLOAT, false, 0, 0) } if (p.uv >= 0) { if (s.geometry.faceVertexUvs[0]) { V.bindBuffer(V.ARRAY_BUFFER, i.__webglUVBuffer); Vt(p.uv); V.vertexAttribPointer(p.uv, 2, V.FLOAT, false, 0, 0) } else if (r.defaultAttributeValues) { V.vertexAttrib2fv(p.uv, r.defaultAttributeValues.uv) } } if (p.uv2 >= 0) { if (s.geometry.faceVertexUvs[1]) { V.bindBuffer(V.ARRAY_BUFFER, i.__webglUV2Buffer); Vt(p.uv2); V.vertexAttribPointer(p.uv2, 2, V.FLOAT, false, 0, 0) } else if (r.defaultAttributeValues) { V.vertexAttrib2fv(p.uv2, r.defaultAttributeValues.uv2) } } if (r.skinning && p.skinIndex >= 0 && p.skinWeight >= 0) { V.bindBuffer(V.ARRAY_BUFFER, i.__webglSkinIndicesBuffer); Vt(p.skinIndex); V.vertexAttribPointer(p.skinIndex, 4, V.FLOAT, false, 0, 0); V.bindBuffer(V.ARRAY_BUFFER, i.__webglSkinWeightsBuffer); Vt(p.skinWeight); V.vertexAttribPointer(p.skinWeight, 4, V.FLOAT, false, 0, 0) } if (p.lineDistance >= 0) { V.bindBuffer(V.ARRAY_BUFFER, i.__webglLineDistanceBuffer); Vt(p.lineDistance); V.vertexAttribPointer(p.lineDistance, 1, V.FLOAT, false, 0, 0) } } if (s instanceof THREE.Mesh) { if (r.wireframe) { Mn(r.wireframeLinewidth); if (d) V.bindBuffer(V.ELEMENT_ARRAY_BUFFER, i.__webglLineBuffer); V.drawElements(V.LINES, i.__webglLineCount, V.UNSIGNED_SHORT, 0) } else { if (d) V.bindBuffer(V.ELEMENT_ARRAY_BUFFER, i.__webglFaceBuffer); V.drawElements(V.TRIANGLES, i.__webglFaceCount, V.UNSIGNED_SHORT, 0) } l.info.render.calls++; l.info.render.vertices += i.__webglFaceCount; l.info.render.faces += i.__webglFaceCount / 3 } else if (s instanceof THREE.Line) { var y = s.type === THREE.LineStrip ? V.LINE_STRIP : V.LINES; Mn(r.linewidth); V.drawArrays(y, 0, i.__webglLineCount); l.info.render.calls++ } else if (s instanceof THREE.ParticleSystem) { V.drawArrays(V.POINTS, 0, i.__webglParticleCount); l.info.render.calls++; l.info.render.points += i.__webglParticleCount } }; this.render = function (e, t, n, r) { if (t instanceof THREE.Camera === false) { console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); return } var i, s, o, u, a, f = e.__lights, c = e.fog; v = -1; W = true; if (e.autoUpdate === true) e.updateMatrixWorld(); if (t.parent === undefined) t.updateMatrixWorld(); t.matrixWorldInverse.getInverse(t.matrixWorld); q.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse); I.setFromMatrix(q); if (this.autoUpdateObjects) this.initWebGLObjects(e); Gt(this.renderPluginsPre, e, t); l.info.render.calls = 0; l.info.render.vertices = 0; l.info.render.faces = 0; l.info.render.points = 0; this.setRenderTarget(n); if (this.autoClear || r) { this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil) } a = e.__webglObjects; for (i = 0, s = a.length; i < s; i++) { o = a[i]; u = o.object; o.id = i; o.render = false; if (u.visible) { if (!(u instanceof THREE.Mesh || u instanceof THREE.ParticleSystem) || !u.frustumCulled || I.intersectsObject(u)) { kn(u, t); tn(o); o.render = true; if (this.sortObjects === true) { if (u.renderDepth !== null) { o.z = u.renderDepth } else { U.getPositionFromMatrix(u.matrixWorld); U.applyProjection(q); o.z = U.z } } } } } if (this.sortObjects) { a.sort(Kt) } a = e.__webglObjectsImmediate; for (i = 0, s = a.length; i < s; i++) { o = a[i]; u = o.object; if (u.visible) { kn(u, t); en(o) } } if (e.overrideMaterial) { var h = e.overrideMaterial; this.setBlending(h.blending, h.blendEquation, h.blendSrc, h.blendDst); this.setDepthTest(h.depthTest); this.setDepthWrite(h.depthWrite); _n(h.polygonOffset, h.polygonOffsetFactor, h.polygonOffsetUnits); Yt(e.__webglObjects, false, "", t, f, c, true, h); Zt(e.__webglObjectsImmediate, "", t, f, c, false, h) } else { var h = null; this.setBlending(THREE.NoBlending); Yt(e.__webglObjects, true, "opaque", t, f, c, false, h); Zt(e.__webglObjectsImmediate, "opaque", t, f, c, false, h); Yt(e.__webglObjects, false, "transparent", t, f, c, true, h); Zt(e.__webglObjectsImmediate, "transparent", t, f, c, true, h) } Gt(this.renderPluginsPost, e, t); if (n && n.generateMipmaps && n.minFilter !== THREE.NearestFilter && n.minFilter !== THREE.LinearFilter) { Vn(n) } this.setDepthTest(true); this.setDepthWrite(true) }; this.renderImmediateObject = function (e, t, n, r, i) { var s = dn(e, t, n, r, i); m = -1; l.setMaterialFaces(r); if (i.immediateRenderCallback) { i.immediateRenderCallback(s, V, I) } else { i.render(function (e) { l.renderBufferImmediate(e, s, r) }) } }; this.initWebGLObjects = function (e) { if (!e.__webglObjects) { e.__webglObjects = []; e.__webglObjectsImmediate = []; e.__webglSprites = []; e.__webglFlares = [] } while (e.__objectsAdded.length) { rn(e.__objectsAdded[0], e); e.__objectsAdded.splice(0, 1) } while (e.__objectsRemoved.length) { ln(e.__objectsRemoved[0], e); e.__objectsRemoved.splice(0, 1) } for (var t = 0, n = e.__webglObjects.length; t < n; t++) { var r = e.__webglObjects[t].object; if (r.__webglInit === undefined) { if (r.__webglActive !== undefined) { ln(r, e) } rn(r, e) } un(r) } }; this.initMaterial = function (e, t, n, r) { e.addEventListener("dispose", Ct); var i, s, o, u, a, f, l, c, h; if (e instanceof THREE.MeshDepthMaterial) { h = "depth" } else if (e instanceof THREE.MeshNormalMaterial) { h = "normal" } else if (e instanceof THREE.MeshBasicMaterial) { h = "basic" } else if (e instanceof THREE.MeshPhongMaterial) { h = "phong" } else if (e instanceof THREE.LineBasicMaterial) { h = "basic" } else if (e instanceof THREE.LineDashedMaterial) { h = "dashed" } if (h) { pn(e, THREE.ShaderLib[h]) } f = Qn(t); c = Gn(t); l = Kn(r); a = { map: !!e.map, envMap: !!e.envMap, lightMap: !!e.lightMap, bumpMap: !!e.bumpMap, normalMap: !!e.normalMap, specularMap: !!e.specularMap, vertexColors: e.vertexColors, sizeAttenuation: e.sizeAttenuation, skinning: e.skinning, maxBones: l, useVertexTexture: it && r && r.useVertexTexture, morphTargets: e.morphTargets, morphNormals: e.morphNormals, maxMorphTargets: this.maxMorphTargets, maxMorphNormals: this.maxMorphNormals, maxDirLights: f.directional, maxPointLights: f.point, maxSpotLights: f.spot, maxHemiLights: f.hemi, maxShadows: c, shadowMapEnabled: this.shadowMapEnabled && r.receiveShadow, shadowMapType: this.shadowMapType, shadowMapDebug: this.shadowMapDebug, shadowMapCascade: this.shadowMapCascade, alphaTest: e.alphaTest, metal: e.metal, perPixel: e.perPixel, wrapAround: e.wrapAround, doubleSided: e.side === THREE.DoubleSide, flipSided: e.side === THREE.BackSide }; e.program = Pn(h, e.fragmentShader, e.vertexShader, e.uniforms, e.attributes, e.defines, a, e.index0AttributeName); var p = e.program.attributes; if (e.morphTargets) { e.numSupportedMorphTargets = 0; var d, v = "morphTarget"; for (u = 0; u < this.maxMorphTargets; u++) { d = v + u; if (p[d] >= 0) { e.numSupportedMorphTargets++ } } } if (e.morphNormals) { e.numSupportedMorphNormals = 0; var d, v = "morphNormal"; for (u = 0; u < this.maxMorphNormals; u++) { d = v + u; if (p[d] >= 0) { e.numSupportedMorphNormals++ } } } e.uniformsList = []; for (i in e.uniforms) { e.uniformsList.push([e.uniforms[i], i]) } }; this.setFaceCulling = function (e, t) { if (e === THREE.CullFaceNone) { V.disable(V.CULL_FACE) } else { if (t === THREE.FrontFaceDirectionCW) { V.frontFace(V.CW) } else { V.frontFace(V.CCW) } if (e === THREE.CullFaceBack) { V.cullFace(V.BACK) } else if (e === THREE.CullFaceFront) { V.cullFace(V.FRONT) } else { V.cullFace(V.FRONT_AND_BACK) } V.enable(V.CULL_FACE) } }; this.setMaterialFaces = function (e) { var t = e.side === THREE.DoubleSide; var n = e.side === THREE.BackSide; if (w !== t) { if (t) { V.disable(V.CULL_FACE) } else { V.enable(V.CULL_FACE) } w = t } if (E !== n) { if (n) { V.frontFace(V.CW) } else { V.frontFace(V.CCW) } E = n } }; this.setDepthTest = function (e) { if (C !== e) { if (e) { V.enable(V.DEPTH_TEST) } else { V.disable(V.DEPTH_TEST) } C = e } }; this.setDepthWrite = function (e) { if (k !== e) { V.depthMask(e); k = e } }; this.setBlending = function (e, t, n, r) { if (e !== S) { if (e === THREE.NoBlending) { V.disable(V.BLEND) } else if (e === THREE.AdditiveBlending) { V.enable(V.BLEND); V.blendEquation(V.FUNC_ADD); V.blendFunc(V.SRC_ALPHA, V.ONE) } else if (e === THREE.SubtractiveBlending) { V.enable(V.BLEND); V.blendEquation(V.FUNC_ADD); V.blendFunc(V.ZERO, V.ONE_MINUS_SRC_COLOR) } else if (e === THREE.MultiplyBlending) { V.enable(V.BLEND); V.blendEquation(V.FUNC_ADD); V.blendFunc(V.ZERO, V.SRC_COLOR) } else if (e === THREE.CustomBlending) { V.enable(V.BLEND) } else { V.enable(V.BLEND); V.blendEquationSeparate(V.FUNC_ADD, V.FUNC_ADD); V.blendFuncSeparate(V.SRC_ALPHA, V.ONE_MINUS_SRC_ALPHA, V.ONE, V.ONE_MINUS_SRC_ALPHA) } S = e } if (e === THREE.CustomBlending) { if (t !== x) { V.blendEquation(Jn(t)); x = t } if (n !== T || r !== N) { V.blendFunc(Jn(n), Jn(r)); T = n; N = r } } else { x = null; T = null; N = null } }; this.setTexture = function (e, t) { if (e.needsUpdate) { if (!e.__webglInit) { e.__webglInit = true; e.addEventListener("dispose", Tt); e.__webglTexture = V.createTexture(); l.info.memory.textures++ } V.activeTexture(V.TEXTURE0 + t); V.bindTexture(V.TEXTURE_2D, e.__webglTexture); V.pixelStorei(V.UNPACK_FLIP_Y_WEBGL, e.flipY); V.pixelStorei(V.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.premultiplyAlpha); V.pixelStorei(V.UNPACK_ALIGNMENT, e.unpackAlignment); var n = e.image, r = In(n.width) && In(n.height), i = Jn(e.format), s = Jn(e.type); qn(V.TEXTURE_2D, e, r); var o, u = e.mipmaps; if (e instanceof THREE.DataTexture) { if (u.length > 0 && r) { for (var a = 0, f = u.length; a < f; a++) { o = u[a]; V.texImage2D(V.TEXTURE_2D, a, i, o.width, o.height, 0, i, s, o.data) } e.generateMipmaps = false } else { V.texImage2D(V.TEXTURE_2D, 0, i, n.width, n.height, 0, i, s, n.data) } } else if (e instanceof THREE.CompressedTexture) { for (var a = 0, f = u.length; a < f; a++) { o = u[a]; if (e.format !== THREE.RGBAFormat) { V.compressedTexImage2D(V.TEXTURE_2D, a, i, o.width, o.height, 0, o.data) } else { V.texImage2D(V.TEXTURE_2D, a, i, o.width, o.height, 0, i, s, o.data) } } } else { if (u.length > 0 && r) { for (var a = 0, f = u.length; a < f; a++) { o = u[a]; V.texImage2D(V.TEXTURE_2D, a, i, i, s, o) } e.generateMipmaps = false } else { V.texImage2D(V.TEXTURE_2D, 0, i, i, s, e.image) } } if (e.generateMipmaps && r) V.generateMipmap(V.TEXTURE_2D); e.needsUpdate = false; if (e.onUpdate) e.onUpdate() } else { V.activeTexture(V.TEXTURE0 + t); V.bindTexture(V.TEXTURE_2D, e.__webglTexture) } }; this.setRenderTarget = function (e) { var t = e instanceof THREE.WebGLRenderTargetCube; if (e && !e.__webglFramebuffer) { if (e.depthBuffer === undefined) e.depthBuffer = true; if (e.stencilBuffer === undefined) e.stencilBuffer = true; e.addEventListener("dispose", Nt); e.__webglTexture = V.createTexture(); l.info.memory.textures++; var n = In(e.width) && In(e.height), r = Jn(e.format), i = Jn(e.type); if (t) { e.__webglFramebuffer = []; e.__webglRenderbuffer = []; V.bindTexture(V.TEXTURE_CUBE_MAP, e.__webglTexture); qn(V.TEXTURE_CUBE_MAP, e, n); for (var s = 0; s < 6; s++) { e.__webglFramebuffer[s] = V.createFramebuffer(); e.__webglRenderbuffer[s] = V.createRenderbuffer(); V.texImage2D(V.TEXTURE_CUBE_MAP_POSITIVE_X + s, 0, r, e.width, e.height, 0, r, i, null); Wn(e.__webglFramebuffer[s], e, V.TEXTURE_CUBE_MAP_POSITIVE_X + s); Xn(e.__webglRenderbuffer[s], e) } if (n) V.generateMipmap(V.TEXTURE_CUBE_MAP) } else { e.__webglFramebuffer = V.createFramebuffer(); if (e.shareDepthFrom) { e.__webglRenderbuffer = e.shareDepthFrom.__webglRenderbuffer } else { e.__webglRenderbuffer = V.createRenderbuffer() } V.bindTexture(V.TEXTURE_2D, e.__webglTexture); qn(V.TEXTURE_2D, e, n); V.texImage2D(V.TEXTURE_2D, 0, r, e.width, e.height, 0, r, i, null); Wn(e.__webglFramebuffer, e, V.TEXTURE_2D); if (e.shareDepthFrom) { if (e.depthBuffer && !e.stencilBuffer) { V.framebufferRenderbuffer(V.FRAMEBUFFER, V.DEPTH_ATTACHMENT, V.RENDERBUFFER, e.__webglRenderbuffer) } else if (e.depthBuffer && e.stencilBuffer) { V.framebufferRenderbuffer(V.FRAMEBUFFER, V.DEPTH_STENCIL_ATTACHMENT, V.RENDERBUFFER, e.__webglRenderbuffer) } } else { Xn(e.__webglRenderbuffer, e) } if (n) V.generateMipmap(V.TEXTURE_2D) } if (t) { V.bindTexture(V.TEXTURE_CUBE_MAP, null) } else { V.bindTexture(V.TEXTURE_2D, null) } V.bindRenderbuffer(V.RENDERBUFFER, null); V.bindFramebuffer(V.FRAMEBUFFER, null) } var o, u, a, f, c; if (e) { if (t) { o = e.__webglFramebuffer[e.activeCubeFace] } else { o = e.__webglFramebuffer } u = e.width; a = e.height; f = 0; c = 0 } else { o = null; u = P; a = H; f = _; c = D } if (o !== d) { V.bindFramebuffer(V.FRAMEBUFFER, o); V.viewport(f, c, u, a); d = o } B = u; j = a }; this.shadowMapPlugin = new THREE.ShadowMapPlugin; this.addPrePlugin(this.shadowMapPlugin) }; THREE.WebGLRenderTarget = function (e, t, n) { this.width = e; this.height = t; n = n || {}; this.wrapS = n.wrapS !== undefined ? n.wrapS : THREE.ClampToEdgeWrapping; this.wrapT = n.wrapT !== undefined ? n.wrapT : THREE.ClampToEdgeWrapping; this.magFilter = n.magFilter !== undefined ? n.magFilter : THREE.LinearFilter; this.minFilter = n.minFilter !== undefined ? n.minFilter : THREE.LinearMipMapLinearFilter; this.anisotropy = n.anisotropy !== undefined ? n.anisotropy : 1; this.offset = new THREE.Vector2(0, 0); this.repeat = new THREE.Vector2(1, 1); this.format = n.format !== undefined ? n.format : THREE.RGBAFormat; this.type = n.type !== undefined ? n.type : THREE.UnsignedByteType; this.depthBuffer = n.depthBuffer !== undefined ? n.depthBuffer : true; this.stencilBuffer = n.stencilBuffer !== undefined ? n.stencilBuffer : true; this.generateMipmaps = true; this.shareDepthFrom = null }; THREE.WebGLRenderTarget.prototype = { constructor: THREE.WebGLRenderTarget, clone: function () { var e = new THREE.WebGLRenderTarget(this.width, this.height); e.wrapS = this.wrapS; e.wrapT = this.wrapT; e.magFilter = this.magFilter; e.minFilter = this.minFilter; e.anisotropy = this.anisotropy; e.offset.copy(this.offset); e.repeat.copy(this.repeat); e.format = this.format; e.type = this.type; e.depthBuffer = this.depthBuffer; e.stencilBuffer = this.stencilBuffer; e.generateMipmaps = this.generateMipmaps; e.shareDepthFrom = this.shareDepthFrom; return e }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }; THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype); THREE.WebGLRenderTargetCube = function (e, t, n) { THREE.WebGLRenderTarget.call(this, e, t, n); this.activeCubeFace = 0 }; THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype); THREE.RenderableVertex = function () { this.positionWorld = new THREE.Vector3; this.positionScreen = new THREE.Vector4; this.visible = true }; THREE.RenderableVertex.prototype.copy = function (e) { this.positionWorld.copy(e.positionWorld); this.positionScreen.copy(e.positionScreen) }; THREE.RenderableFace3 = function () { this.id = 0; this.v1 = new THREE.RenderableVertex; this.v2 = new THREE.RenderableVertex; this.v3 = new THREE.RenderableVertex; this.centroidModel = new THREE.Vector3; this.normalModel = new THREE.Vector3; this.normalModelView = new THREE.Vector3; this.vertexNormalsLength = 0; this.vertexNormalsModel = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3]; this.vertexNormalsModelView = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3]; this.color = null; this.material = null; this.uvs = [[]]; this.z = 0 }; THREE.RenderableObject = function () { this.id = 0; this.object = null; this.z = 0 }; THREE.RenderableParticle = function () { this.id = 0; this.object = null; this.x = 0; this.y = 0; this.z = 0; this.rotation = null; this.scale = new THREE.Vector2; this.material = null }; THREE.RenderableLine = function () { this.id = 0; this.v1 = new THREE.RenderableVertex; this.v2 = new THREE.RenderableVertex; this.vertexColors = [new THREE.Color, new THREE.Color]; this.material = null; this.z = 0 }; THREE.ImageUtils = { crossOrigin: "anonymous", loadTexture: function (e, t, n, r) { var i = new THREE.ImageLoader; i.crossOrigin = this.crossOrigin; var s = new THREE.Texture(undefined, t); var o = i.load(e, function () { s.needsUpdate = true; if (n) n(s) }); s.image = o; s.sourceFile = e; return s }, loadCompressedTexture: function (e, t, n, r) { var i = new THREE.CompressedTexture; i.mapping = t; var s = new XMLHttpRequest; s.onload = function () { var e = s.response; var t = THREE.ImageUtils.parseDDS(e, true); i.format = t.format; i.mipmaps = t.mipmaps; i.image.width = t.width; i.image.height = t.height; i.generateMipmaps = false; i.needsUpdate = true; if (n) n(i) }; s.onerror = r; s.open("GET", e, true); s.responseType = "arraybuffer"; s.send(null); return i }, loadTextureCube: function (e, t, n, r) { var i = []; i.loadCount = 0; var s = new THREE.Texture; s.image = i; if (t !== undefined) s.mapping = t; s.flipY = false; for (var o = 0, u = e.length; o < u; ++o) { var a = new Image; i[o] = a; a.onload = function () { i.loadCount += 1; if (i.loadCount === 6) { s.needsUpdate = true; if (n) n(s) } }; a.onerror = r; a.crossOrigin = this.crossOrigin; a.src = e[o] } return s }, loadCompressedTextureCube: function (e, t, n, r) { var i = []; i.loadCount = 0; var s = new THREE.CompressedTexture; s.image = i; if (t !== undefined) s.mapping = t; s.flipY = false; s.generateMipmaps = false; var o = function (e, t) { return function () { var r = e.response; var o = THREE.ImageUtils.parseDDS(r, true); t.format = o.format; t.mipmaps = o.mipmaps; t.width = o.width; t.height = o.height; i.loadCount += 1; if (i.loadCount === 6) { s.format = o.format; s.needsUpdate = true; if (n) n(s) } } }; if (e instanceof Array) { for (var u = 0, a = e.length; u < a; ++u) { var f = {}; i[u] = f; var l = new XMLHttpRequest; l.onload = o(l, f); l.onerror = r; var c = e[u]; l.open("GET", c, true); l.responseType = "arraybuffer"; l.send(null) } } else { var c = e; var l = new XMLHttpRequest; l.onload = function () { var e = l.response; var t = THREE.ImageUtils.parseDDS(e, true); if (t.isCubemap) { var r = t.mipmaps.length / t.mipmapCount; for (var o = 0; o < r; o++) { i[o] = { mipmaps: [] }; for (var u = 0; u < t.mipmapCount; u++) { i[o].mipmaps.push(t.mipmaps[o * t.mipmapCount + u]); i[o].format = t.format; i[o].width = t.width; i[o].height = t.height } } s.format = t.format; s.needsUpdate = true; if (n) n(s) } }; l.onerror = r; l.open("GET", c, true); l.responseType = "arraybuffer"; l.send(null) } return s }, loadDDSTexture: function (e, t, n, r) { var i = []; i.loadCount = 0; var s = new THREE.CompressedTexture; s.image = i; if (t !== undefined) s.mapping = t; s.flipY = false; s.generateMipmaps = false; { var o = new XMLHttpRequest; o.onload = function () { var e = o.response; var t = THREE.ImageUtils.parseDDS(e, true); if (t.isCubemap) { var r = t.mipmaps.length / t.mipmapCount; for (var u = 0; u < r; u++) { i[u] = { mipmaps: [] }; for (var a = 0; a < t.mipmapCount; a++) { i[u].mipmaps.push(t.mipmaps[u * t.mipmapCount + a]); i[u].format = t.format; i[u].width = t.width; i[u].height = t.height } } } else { s.image.width = t.width; s.image.height = t.height; s.mipmaps = t.mipmaps } s.format = t.format; s.needsUpdate = true; if (n) n(s) }; o.onerror = r; o.open("GET", e, true); o.responseType = "arraybuffer"; o.send(null) } return s }, parseDDS: function (e, t) { function A(e) { return e.charCodeAt(0) + (e.charCodeAt(1) << 8) + (e.charCodeAt(2) << 16) + (e.charCodeAt(3) << 24) } function O(e) { return String.fromCharCode(e & 255, e >> 8 & 255, e >> 16 & 255, e >> 24 & 255) } function M(e, t, n, r) { var i = n * r * 4; var s = new Uint8Array(e, t, i); var o = new Uint8Array(i); var u = 0; var a = 0; for (var f = 0; f < r; f++) { for (var l = 0; l < n; l++) { var c = s[a]; a++; var h = s[a]; a++; var p = s[a]; a++; var d = s[a]; a++; o[u] = p; u++; o[u] = h; u++; o[u] = c; u++; o[u] = d; u++ } } return o } var n = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 }; var r = 542327876; var i = 1, s = 2, o = 4, u = 8, a = 4096, f = 131072, l = 524288, c = 8388608; var h = 8, p = 4194304, d = 4096; var v = 512, m = 1024, g = 2048, y = 4096, b = 8192, w = 16384, E = 32768, S = 2097152; var x = 1, T = 2, N = 4, C = 64, k = 512, L = 131072; var _ = A("DXT1"); var D = A("DXT3"); var P = A("DXT5"); var H = 31; var B = 0; var j = 1; var F = 2; var I = 3; var q = 4; var R = 7; var U = 20; var z = 21; var W = 22; var X = 23; var V = 24; var $ = 25; var J = 26; var K = 27; var Q = 28; var G = 29; var Y = 30; var Z = new Int32Array(e, 0, H); if (Z[B] !== r) { console.error("ImageUtils.parseDDS(): Invalid magic number in DDS header"); return n } if (!Z[U] & N) { console.error("ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code"); return n } var et; var tt = Z[z]; var nt = false; switch (tt) { case _: et = 8; n.format = THREE.RGB_S3TC_DXT1_Format; break; case D: et = 16; n.format = THREE.RGBA_S3TC_DXT3_Format; break; case P: et = 16; n.format = THREE.RGBA_S3TC_DXT5_Format; break; default: if (Z[W] == 32 && Z[X] & 16711680 && Z[V] & 65280 && Z[$] & 255 && Z[J] & 4278190080) { nt = true; et = 64; n.format = THREE.RGBAFormat } else { console.error("ImageUtils.parseDDS(): Unsupported FourCC code: ", O(tt)); return n } } n.mipmapCount = 1; if (Z[F] & f && t !== false) { n.mipmapCount = Math.max(1, Z[R]) } n.isCubemap = Z[Q] & v ? true : false; n.width = Z[q]; n.height = Z[I]; var rt = Z[j] + 4; var it = n.width; var st = n.height; var ot = n.isCubemap ? 6 : 1; for (var ut = 0; ut < ot; ut++) { for (var at = 0; at < n.mipmapCount; at++) { if (nt) { var ft = M(e, rt, it, st); var lt = ft.length } else { var lt = Math.max(4, it) / 4 * Math.max(4, st) / 4 * et; var ft = new Uint8Array(e, rt, lt) } var ct = { data: ft, width: it, height: st }; n.mipmaps.push(ct); rt += lt; it = Math.max(it * .5, 1); st = Math.max(st * .5, 1) } it = n.width; st = n.height } return n }, getNormalMap: function (e, t) { var n = function (e, t) { return [e[1] * t[2] - e[2] * t[1], e[2] * t[0] - e[0] * t[2], e[0] * t[1] - e[1] * t[0]] }; var r = function (e, t) { return [e[0] - t[0], e[1] - t[1], e[2] - t[2]] }; var i = function (e) { var t = Math.sqrt(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]); return [e[0] / t, e[1] / t, e[2] / t] }; t = t | 1; var s = e.width; var o = e.height; var u = document.createElement("canvas"); u.width = s; u.height = o; var a = u.getContext("2d"); a.drawImage(e, 0, 0); var f = a.getImageData(0, 0, s, o).data; var l = a.createImageData(s, o); var c = l.data; for (var h = 0; h < s; h++) { for (var p = 0; p < o; p++) { var d = p - 1 < 0 ? 0 : p - 1; var v = p + 1 > o - 1 ? o - 1 : p + 1; var m = h - 1 < 0 ? 0 : h - 1; var g = h + 1 > s - 1 ? s - 1 : h + 1; var y = []; var b = [0, 0, f[(p * s + h) * 4] / 255 * t]; y.push([-1, 0, f[(p * s + m) * 4] / 255 * t]); y.push([-1, -1, f[(d * s + m) * 4] / 255 * t]); y.push([0, -1, f[(d * s + h) * 4] / 255 * t]); y.push([1, -1, f[(d * s + g) * 4] / 255 * t]); y.push([1, 0, f[(p * s + g) * 4] / 255 * t]); y.push([1, 1, f[(v * s + g) * 4] / 255 * t]); y.push([0, 1, f[(v * s + h) * 4] / 255 * t]); y.push([-1, 1, f[(v * s + m) * 4] / 255 * t]); var w = []; var E = y.length; for (var S = 0; S < E; S++) { var x = y[S]; var T = y[(S + 1) % E]; x = r(x, b); T = r(T, b); w.push(i(n(x, T))) } var N = [0, 0, 0]; for (var S = 0; S < w.length; S++) { N[0] += w[S][0]; N[1] += w[S][1]; N[2] += w[S][2] } N[0] /= w.length; N[1] /= w.length; N[2] /= w.length; var C = (p * s + h) * 4; c[C] = (N[0] + 1) / 2 * 255 | 0; c[C + 1] = (N[1] + 1) / 2 * 255 | 0; c[C + 2] = N[2] * 255 | 0; c[C + 3] = 255 } } a.putImageData(l, 0, 0); return u }, generateDataTexture: function (e, t, n) { var r = e * t; var i = new Uint8Array(3 * r); var s = Math.floor(n.r * 255); var o = Math.floor(n.g * 255); var u = Math.floor(n.b * 255); for (var a = 0; a < r; a++) { i[a * 3] = s; i[a * 3 + 1] = o; i[a * 3 + 2] = u } var f = new THREE.DataTexture(i, e, t, THREE.RGBFormat); f.needsUpdate = true; return f } }; THREE.SceneUtils = { createMultiMaterialObject: function (e, t) { var n = new THREE.Object3D; for (var r = 0, i = t.length; r < i; r++) { n.add(new THREE.Mesh(e, t[r])) } return n }, detach: function (e, t, n) { e.applyMatrix(t.matrixWorld); t.remove(e); n.add(e) }, attach: function (e, t, n) { var r = new THREE.Matrix4; r.getInverse(n.matrixWorld); e.applyMatrix(r); t.remove(e); n.add(e) } }; THREE.Animation = function (e, t, n) { this.root = e; this.data = THREE.AnimationHandler.get(t); this.hierarchy = THREE.AnimationHandler.parse(e); this.currentTime = 0; this.timeScale = 1; this.isPlaying = false; this.isPaused = true; this.loop = true; this.interpolationType = n !== undefined ? n : THREE.AnimationHandler.LINEAR; this.points = []; this.target = new THREE.Vector3 }; THREE.Animation.prototype.play = function (e, t) { if (this.isPlaying === false) { this.isPlaying = true; this.loop = e !== undefined ? e : true; this.currentTime = t !== undefined ? t : 0; var n, r = this.hierarchy.length, i; for (n = 0; n < r; n++) { i = this.hierarchy[n]; i.matrixAutoUpdate = true; if (i.animationCache === undefined) { i.animationCache = {}; i.animationCache.prevKey = { pos: 0, rot: 0, scl: 0 }; i.animationCache.nextKey = { pos: 0, rot: 0, scl: 0 }; i.animationCache.originalMatrix = i instanceof THREE.Bone ? i.skinMatrix : i.matrix } var s = i.animationCache.prevKey; var o = i.animationCache.nextKey; s.pos = this.data.hierarchy[n].keys[0]; s.rot = this.data.hierarchy[n].keys[0]; s.scl = this.data.hierarchy[n].keys[0]; o.pos = this.getNextKeyWith("pos", n, 1); o.rot = this.getNextKeyWith("rot", n, 1); o.scl = this.getNextKeyWith("scl", n, 1) } this.update(0) } this.isPaused = false; THREE.AnimationHandler.addToUpdate(this) }; THREE.Animation.prototype.pause = function () { if (this.isPaused === true) { THREE.AnimationHandler.addToUpdate(this) } else { THREE.AnimationHandler.removeFromUpdate(this) } this.isPaused = !this.isPaused }; THREE.Animation.prototype.stop = function () { this.isPlaying = false; this.isPaused = false; THREE.AnimationHandler.removeFromUpdate(this) }; THREE.Animation.prototype.update = function (e) { if (this.isPlaying === false) return; var t = ["pos", "rot", "scl"]; var n; var r; var i; var s, o; var u, a; var f; var l; var c; var h = this.data.JIT.hierarchy; var p, d; var v, m, g; this.currentTime += e * this.timeScale; d = this.currentTime; p = this.currentTime = this.currentTime % this.data.length; c = parseInt(Math.min(p * this.data.fps, this.data.length * this.data.fps), 10); for (var y = 0, b = this.hierarchy.length; y < b; y++) { f = this.hierarchy[y]; l = f.animationCache; for (var w = 0; w < 3; w++) { n = t[w]; u = l.prevKey[n]; a = l.nextKey[n]; if (a.time <= d) { if (p < d) { if (this.loop) { u = this.data.hierarchy[y].keys[0]; a = this.getNextKeyWith(n, y, 1); while (a.time < p) { u = a; a = this.getNextKeyWith(n, y, a.index + 1) } } else { this.stop(); return } } else { do { u = a; a = this.getNextKeyWith(n, y, a.index + 1) } while (a.time < p) } l.prevKey[n] = u; l.nextKey[n] = a } f.matrixAutoUpdate = true; f.matrixWorldNeedsUpdate = true; r = (p - u.time) / (a.time - u.time); s = u[n]; o = a[n]; if (r < 0 || r > 1) { console.log("THREE.Animation.update: Warning! Scale out of bounds:" + r + " on bone " + y); r = r < 0 ? 0 : 1 } if (n === "pos") { i = f.position; if (this.interpolationType === THREE.AnimationHandler.LINEAR) { i.x = s[0] + (o[0] - s[0]) * r; i.y = s[1] + (o[1] - s[1]) * r; i.z = s[2] + (o[2] - s[2]) * r } else if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) { this.points[0] = this.getPrevKeyWith("pos", y, u.index - 1)["pos"]; this.points[1] = s; this.points[2] = o; this.points[3] = this.getNextKeyWith("pos", y, a.index + 1)["pos"]; r = r * .33 + .33; v = this.interpolateCatmullRom(this.points, r); i.x = v[0]; i.y = v[1]; i.z = v[2]; if (this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) { m = this.interpolateCatmullRom(this.points, r * 1.01); this.target.set(m[0], m[1], m[2]); this.target.sub(i); this.target.y = 0; this.target.normalize(); g = Math.atan2(this.target.x, this.target.z); f.rotation.set(0, g, 0) } } } else if (n === "rot") { THREE.Quaternion.slerp(s, o, f.quaternion, r) } else if (n === "scl") { i = f.scale; i.x = s[0] + (o[0] - s[0]) * r; i.y = s[1] + (o[1] - s[1]) * r; i.z = s[2] + (o[2] - s[2]) * r } } } }; THREE.Animation.prototype.interpolate = function (e, t, n, r, i, s, o) { var u = (n - e) * .5, a = (r - t) * .5; return (2 * (t - n) + u + a) * o + (-3 * (t - n) - 2 * u - a) * s + u * i + t }; THREE.Animation.prototype.getNextKeyWith = function (e, t, n) { var r = this.data.hierarchy[t].keys; if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) { n = n < r.length - 1 ? n : r.length - 1 } else { n = n % r.length } for (; n < r.length; n++) { if (r[n][e] !== undefined) { return r[n] } } return this.data.hierarchy[t].keys[0] }; THREE.Animation.prototype.getPrevKeyWith = function (e, t, n) { var r = this.data.hierarchy[t].keys; if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) { n = n > 0 ? n : 0 } else { n = n >= 0 ? n : n + r.length } for (; n >= 0; n--) { if (r[n][e] !== undefined) { return r[n] } } return this.data.hierarchy[t].keys[r.length - 1] }; THREE.KeyFrameAnimation = function (e, t, n) { this.root = e; this.data = THREE.AnimationHandler.get(t); this.hierarchy = THREE.AnimationHandler.parse(e); this.currentTime = 0; this.timeScale = .001; this.isPlaying = false; this.isPaused = true; this.loop = true; this.JITCompile = n !== undefined ? n : true; for (var r = 0, i = this.hierarchy.length; r < i; r++) { var s = this.data.hierarchy[r].keys, o = this.data.hierarchy[r].sids, u = this.hierarchy[r]; if (s.length && o) { for (var a = 0; a < o.length; a++) { var f = o[a], l = this.getNextKeyWith(f, r, 0); if (l) { l.apply(f) } } u.matrixAutoUpdate = false; this.data.hierarchy[r].node.updateMatrix(); u.matrixWorldNeedsUpdate = true } } }; THREE.KeyFrameAnimation.prototype.play = function (e, t) { if (!this.isPlaying) { this.isPlaying = true; this.loop = e !== undefined ? e : true; this.currentTime = t !== undefined ? t : 0; this.startTimeMs = t; this.startTime = 1e7; this.endTime = -this.startTime; var n, r = this.hierarchy.length, i, s; for (n = 0; n < r; n++) { i = this.hierarchy[n]; s = this.data.hierarchy[n]; if (s.animationCache === undefined) { s.animationCache = {}; s.animationCache.prevKey = null; s.animationCache.nextKey = null; s.animationCache.originalMatrix = i instanceof THREE.Bone ? i.skinMatrix : i.matrix } var o = this.data.hierarchy[n].keys; if (o.length) { s.animationCache.prevKey = o[0]; s.animationCache.nextKey = o[1]; this.startTime = Math.min(o[0].time, this.startTime); this.endTime = Math.max(o[o.length - 1].time, this.endTime) } } this.update(0) } this.isPaused = false; THREE.AnimationHandler.addToUpdate(this) }; THREE.KeyFrameAnimation.prototype.pause = function () { if (this.isPaused) { THREE.AnimationHandler.addToUpdate(this) } else { THREE.AnimationHandler.removeFromUpdate(this) } this.isPaused = !this.isPaused }; THREE.KeyFrameAnimation.prototype.stop = function () { this.isPlaying = false; this.isPaused = false; THREE.AnimationHandler.removeFromUpdate(this); for (var e = 0; e < this.data.hierarchy.length; e++) { var t = this.hierarchy[e]; var n = this.data.hierarchy[e]; if (n.animationCache !== undefined) { var r = n.animationCache.originalMatrix; if (t instanceof THREE.Bone) { r.copy(t.skinMatrix); t.skinMatrix = r } else { r.copy(t.matrix); t.matrix = r } delete n.animationCache } } }; THREE.KeyFrameAnimation.prototype.update = function (e) { if (!this.isPlaying) return; var t, n; var r; var i; var s; var o = this.data.JIT.hierarchy; var u, a; var f; this.currentTime += e * this.timeScale; a = this.currentTime; u = this.currentTime = this.currentTime % this.data.length; if (u < this.startTimeMs) { u = this.currentTime = this.startTimeMs + u } s = parseInt(Math.min(u * this.data.fps, this.data.length * this.data.fps), 10); f = u < a; if (f && !this.loop) { for (var l = 0, c = this.hierarchy.length; l < c; l++) { var h = this.data.hierarchy[l].keys, p = this.data.hierarchy[l].sids, d = h.length - 1, v = this.hierarchy[l]; if (h.length) { for (var m = 0; m < p.length; m++) { var g = p[m], y = this.getPrevKeyWith(g, l, d); if (y) { y.apply(g) } } this.data.hierarchy[l].node.updateMatrix(); v.matrixWorldNeedsUpdate = true } } this.stop(); return } if (u < this.startTime) { return } for (var l = 0, c = this.hierarchy.length; l < c; l++) { r = this.hierarchy[l]; i = this.data.hierarchy[l]; var h = i.keys, b = i.animationCache; if (this.JITCompile && o[l][s] !== undefined) { if (r instanceof THREE.Bone) { r.skinMatrix = o[l][s]; r.matrixWorldNeedsUpdate = false } else { r.matrix = o[l][s]; r.matrixWorldNeedsUpdate = true } } else if (h.length) { if (this.JITCompile && b) { if (r instanceof THREE.Bone) { r.skinMatrix = b.originalMatrix } else { r.matrix = b.originalMatrix } } t = b.prevKey; n = b.nextKey; if (t && n) { if (n.time <= a) { if (f && this.loop) { t = h[0]; n = h[1]; while (n.time < u) { t = n; n = h[t.index + 1] } } else if (!f) { var w = h.length - 1; while (n.time < u && n.index !== w) { t = n; n = h[t.index + 1] } } b.prevKey = t; b.nextKey = n } if (n.time >= u) t.interpolate(n, u); else t.interpolate(n, n.time) } this.data.hierarchy[l].node.updateMatrix(); r.matrixWorldNeedsUpdate = true } } if (this.JITCompile) { if (o[0][s] === undefined) { this.hierarchy[0].updateMatrixWorld(true); for (var l = 0; l < this.hierarchy.length; l++) { if (this.hierarchy[l] instanceof THREE.Bone) { o[l][s] = this.hierarchy[l].skinMatrix.clone() } else { o[l][s] = this.hierarchy[l].matrix.clone() } } } } }; THREE.KeyFrameAnimation.prototype.getNextKeyWith = function (e, t, n) { var r = this.data.hierarchy[t].keys; n = n % r.length; for (; n < r.length; n++) { if (r[n].hasTarget(e)) { return r[n] } } return r[0] }; THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function (e, t, n) { var r = this.data.hierarchy[t].keys; n = n >= 0 ? n : n + r.length; for (; n >= 0; n--) { if (r[n].hasTarget(e)) { return r[n] } } return r[r.length - 1] }; THREE.CubeCamera = function (e, t, n) { THREE.Object3D.call(this); var r = 90, i = 1; var s = new THREE.PerspectiveCamera(r, i, e, t); s.up.set(0, -1, 0); s.lookAt(new THREE.Vector3(1, 0, 0)); this.add(s); var o = new THREE.PerspectiveCamera(r, i, e, t); o.up.set(0, -1, 0); o.lookAt(new THREE.Vector3(-1, 0, 0)); this.add(o); var u = new THREE.PerspectiveCamera(r, i, e, t); u.up.set(0, 0, 1); u.lookAt(new THREE.Vector3(0, 1, 0)); this.add(u); var a = new THREE.PerspectiveCamera(r, i, e, t); a.up.set(0, 0, -1); a.lookAt(new THREE.Vector3(0, -1, 0)); this.add(a); var f = new THREE.PerspectiveCamera(r, i, e, t); f.up.set(0, -1, 0); f.lookAt(new THREE.Vector3(0, 0, 1)); this.add(f); var l = new THREE.PerspectiveCamera(r, i, e, t); l.up.set(0, -1, 0); l.lookAt(new THREE.Vector3(0, 0, -1)); this.add(l); this.renderTarget = new THREE.WebGLRenderTargetCube(n, n, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter }); this.updateCubeMap = function (e, t) { var n = this.renderTarget; var r = n.generateMipmaps; n.generateMipmaps = false; n.activeCubeFace = 0; e.render(t, s, n); n.activeCubeFace = 1; e.render(t, o, n); n.activeCubeFace = 2; e.render(t, u, n); n.activeCubeFace = 3; e.render(t, a, n); n.activeCubeFace = 4; e.render(t, f, n); n.generateMipmaps = r; n.activeCubeFace = 5; e.render(t, l, n) } }; THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype); THREE.CombinedCamera = function (e, t, n, r, i, s, o) { THREE.Camera.call(this); this.fov = n; this.left = -e / 2; this.right = e / 2; this.top = t / 2; this.bottom = -t / 2; this.cameraO = new THREE.OrthographicCamera(e / -2, e / 2, t / 2, t / -2, s, o); this.cameraP = new THREE.PerspectiveCamera(n, e / t, r, i); this.zoom = 1; this.toPerspective(); var u = e / t }; THREE.CombinedCamera.prototype = Object.create(THREE.Camera.prototype); THREE.CombinedCamera.prototype.toPerspective = function () { this.near = this.cameraP.near; this.far = this.cameraP.far; this.cameraP.fov = this.fov / this.zoom; this.cameraP.updateProjectionMatrix(); this.projectionMatrix = this.cameraP.projectionMatrix; this.inPerspectiveMode = true; this.inOrthographicMode = false }; THREE.CombinedCamera.prototype.toOrthographic = function () { var e = this.fov; var t = this.cameraP.aspect; var n = this.cameraP.near; var r = this.cameraP.far; var i = (n + r) / 2; var s = Math.tan(e / 2) * i; var o = 2 * s; var u = o * t; var a = u / 2; s /= this.zoom; a /= this.zoom; this.cameraO.left = -a; this.cameraO.right = a; this.cameraO.top = s; this.cameraO.bottom = -s; this.cameraO.updateProjectionMatrix(); this.near = this.cameraO.near; this.far = this.cameraO.far; this.projectionMatrix = this.cameraO.projectionMatrix; this.inPerspectiveMode = false; this.inOrthographicMode = true }; THREE.CombinedCamera.prototype.setSize = function (e, t) { this.cameraP.aspect = e / t; this.left = -e / 2; this.right = e / 2; this.top = t / 2; this.bottom = -t / 2 }; THREE.CombinedCamera.prototype.setFov = function (e) { this.fov = e; if (this.inPerspectiveMode) { this.toPerspective() } else { this.toOrthographic() } }; THREE.CombinedCamera.prototype.updateProjectionMatrix = function () { if (this.inPerspectiveMode) { this.toPerspective() } else { this.toPerspective(); this.toOrthographic() } }; THREE.CombinedCamera.prototype.setLens = function (e, t) { if (t === undefined) t = 24; var n = 2 * THREE.Math.radToDeg(Math.atan(t / (e * 2))); this.setFov(n); return n }; THREE.CombinedCamera.prototype.setZoom = function (e) { this.zoom = e; if (this.inPerspectiveMode) { this.toPerspective() } else { this.toOrthographic() } }; THREE.CombinedCamera.prototype.toFrontView = function () { this.rotation.x = 0; this.rotation.y = 0; this.rotation.z = 0; this.rotationAutoUpdate = false }; THREE.CombinedCamera.prototype.toBackView = function () { this.rotation.x = 0; this.rotation.y = Math.PI; this.rotation.z = 0; this.rotationAutoUpdate = false }; THREE.CombinedCamera.prototype.toLeftView = function () { this.rotation.x = 0; this.rotation.y = -Math.PI / 2; this.rotation.z = 0; this.rotationAutoUpdate = false }; THREE.CombinedCamera.prototype.toRightView = function () { this.rotation.x = 0; this.rotation.y = Math.PI / 2; this.rotation.z = 0; this.rotationAutoUpdate = false }; THREE.CombinedCamera.prototype.toTopView = function () { this.rotation.x = -Math.PI / 2; this.rotation.y = 0; this.rotation.z = 0; this.rotationAutoUpdate = false }; THREE.CombinedCamera.prototype.toBottomView = function () { this.rotation.x = Math.PI / 2; this.rotation.y = 0; this.rotation.z = 0; this.rotationAutoUpdate = false }; THREE.PlaneGeometry = function (e, t, n, r) { THREE.Geometry.call(this); this.width = e; this.height = t; this.widthSegments = n || 1; this.heightSegments = r || 1; var i, s; var o = e / 2; var u = t / 2; var a = this.widthSegments; var f = this.heightSegments; var l = a + 1; var c = f + 1; var h = this.width / a; var p = this.height / f; var d = new THREE.Vector3(0, 0, 1); for (s = 0; s < c; s++) { for (i = 0; i < l; i++) { var v = i * h - o; var m = s * p - u; this.vertices.push(new THREE.Vector3(v, -m, 0)) } } for (s = 0; s < f; s++) { for (i = 0; i < a; i++) { var g = i + l * s; var y = i + l * (s + 1); var b = i + 1 + l * (s + 1); var w = i + 1 + l * s; var E = new THREE.Vector2(i / a, 1 - s / f); var S = new THREE.Vector2(i / a, 1 - (s + 1) / f); var x = new THREE.Vector2((i + 1) / a, 1 - (s + 1) / f); var T = new THREE.Vector2((i + 1) / a, 1 - s / f); var N = new THREE.Face3(g, y, w); N.normal.copy(d); N.vertexNormals.push(d.clone(), d.clone(), d.clone()); this.faces.push(N); this.faceVertexUvs[0].push([E, S, T]); N = new THREE.Face3(y, b, w); N.normal.copy(d); N.vertexNormals.push(d.clone(), d.clone(), d.clone()); this.faces.push(N); this.faceVertexUvs[0].push([S.clone(), x, T.clone()]) } } this.computeCentroids() }; THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype); THREE.ParametricGeometry = function (e, t, n) { THREE.Geometry.call(this); var r = this.vertices; var i = this.faces; var s = this.faceVertexUvs[0]; var o, u, a, f; var l, c; var h = n + 1; var p = t + 1; for (o = 0; o <= n; o++) { c = o / n; for (a = 0; a <= t; a++) { l = a / t; f = e(l, c); r.push(f) } } var d, v, m, g; var y, b, w, E; for (o = 0; o < n; o++) { for (a = 0; a < t; a++) { d = o * p + a; v = o * p + a + 1; m = (o + 1) * p + a + 1; g = (o + 1) * p + a; y = new THREE.Vector2(a / t, o / n); b = new THREE.Vector2((a + 1) / t, o / n); w = new THREE.Vector2((a + 1) / t, (o + 1) / n); E = new THREE.Vector2(a / t, (o + 1) / n); i.push(new THREE.Face3(d, v, g)); s.push([y, b, E]); i.push(new THREE.Face3(v, m, g)); s.push([b.clone(), w, E.clone()]) } } this.computeCentroids(); this.computeFaceNormals(); this.computeVertexNormals() }; THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype); THREE.AxisHelper = function (e) { e = e || 1; var t = new THREE.Geometry; t.vertices.push(new THREE.Vector3, new THREE.Vector3(e, 0, 0), new THREE.Vector3, new THREE.Vector3(0, e, 0), new THREE.Vector3, new THREE.Vector3(0, 0, e)); t.colors.push(new THREE.Color(16711680), new THREE.Color(16755200), new THREE.Color(65280), new THREE.Color(11206400), new THREE.Color(255), new THREE.Color(43775)); var n = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors }); THREE.Line.call(this, t, n, THREE.LinePieces) }; THREE.AxisHelper.prototype = Object.create(THREE.Line.prototype); THREE.CameraHelper = function (e) { function f(e, t, n) { l(e, n); l(t, n) } function l(e, n) { t.vertices.push(new THREE.Vector3); t.colors.push(new THREE.Color(n)); if (r[e] === undefined) { r[e] = [] } r[e].push(t.vertices.length - 1) } var t = new THREE.Geometry; var n = new THREE.LineBasicMaterial({ color: 16777215, vertexColors: THREE.FaceColors }); var r = {}; var i = 16755200; var s = 16711680; var o = 43775; var u = 16777215; var a = 3355443; f("n1", "n2", i); f("n2", "n4", i); f("n4", "n3", i); f("n3", "n1", i); f("f1", "f2", i); f("f2", "f4", i); f("f4", "f3", i); f("f3", "f1", i); f("n1", "f1", i); f("n2", "f2", i); f("n3", "f3", i); f("n4", "f4", i); f("p", "n1", s); f("p", "n2", s); f("p", "n3", s); f("p", "n4", s); f("u1", "u2", o); f("u2", "u3", o); f("u3", "u1", o); f("c", "t", u); f("p", "c", a); f("cn1", "cn2", a); f("cn3", "cn4", a); f("cf1", "cf2", a); f("cf3", "cf4", a); THREE.Line.call(this, t, n, THREE.LinePieces); this.camera = e; this.matrixWorld = e.matrixWorld; this.matrixAutoUpdate = false; this.pointMap = r; this.update() }; THREE.CameraHelper.prototype = Object.create(THREE.Line.prototype); THREE.CameraHelper.prototype.update = function () { var e = new THREE.Vector3; var t = new THREE.Camera; var n = new THREE.Projector; return function () { function o(i, s, o, u) { e.set(s, o, u); n.unprojectVector(e, t); var a = r.pointMap[i]; if (a !== undefined) { for (var f = 0, l = a.length; f < l; f++) { r.geometry.vertices[a[f]].copy(e) } } } var r = this; var i = 1, s = 1; t.projectionMatrix.copy(this.camera.projectionMatrix); o("c", 0, 0, -1); o("t", 0, 0, 1); o("n1", -i, -s, -1); o("n2", i, -s, -1); o("n3", -i, s, -1); o("n4", i, s, -1); o("f1", -i, -s, 1); o("f2", i, -s, 1); o("f3", -i, s, 1); o("f4", i, s, 1); o("u1", i * .7, s * 1.1, -1); o("u2", -i * .7, s * 1.1, -1); o("u3", 0, s * 2, -1); o("cf1", -i, 0, 1); o("cf2", i, 0, 1); o("cf3", 0, -s, 1); o("cf4", 0, s, 1); o("cn1", -i, 0, -1); o("cn2", i, 0, -1); o("cn3", 0, -s, -1); o("cn4", 0, s, -1); this.geometry.verticesNeedUpdate = true } }(); THREE.FaceNormalsHelper = function (e, t, n, r) { this.object = e; this.size = t || 1; var i = n || 16776960; var s = r || 1; var o = new THREE.Geometry; var u = this.object.geometry.faces; for (var a = 0, f = u.length; a < f; a++) { o.vertices.push(new THREE.Vector3); o.vertices.push(new THREE.Vector3) } THREE.Line.call(this, o, new THREE.LineBasicMaterial({ color: i, linewidth: s }), THREE.LinePieces); this.matrixAutoUpdate = false; this.normalMatrix = new THREE.Matrix3; this.update() }; THREE.FaceNormalsHelper.prototype = Object.create(THREE.Line.prototype); THREE.FaceNormalsHelper.prototype.update = function (e) { var t = new THREE.Vector3; return function (e) { this.object.updateMatrixWorld(true); this.normalMatrix.getNormalMatrix(this.object.matrixWorld); var n = this.geometry.vertices; var r = this.object.geometry.faces; var i = this.object.matrixWorld; for (var s = 0, o = r.length; s < o; s++) { var u = r[s]; t.copy(u.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size); var a = 2 * s; n[a].copy(u.centroid).applyMatrix4(i); n[a + 1].addVectors(n[a], t) } this.geometry.verticesNeedUpdate = true; return this } }(); THREE.GridHelper = function (e, t) { var n = new THREE.Geometry; var r = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors }); this.color1 = new THREE.Color(4473924); this.color2 = new THREE.Color(8947848); for (var i = -e; i <= e; i += t) { n.vertices.push(new THREE.Vector3(-e, 0, i), new THREE.Vector3(e, 0, i), new THREE.Vector3(i, 0, -e), new THREE.Vector3(i, 0, e)); var s = i === 0 ? this.color1 : this.color2; n.colors.push(s, s, s, s) } THREE.Line.call(this, n, r, THREE.LinePieces) }; THREE.GridHelper.prototype = Object.create(THREE.Line.prototype); THREE.GridHelper.prototype.setColors = function (e, t) { this.color1.set(e); this.color2.set(t); this.geometry.colorsNeedUpdate = true }; THREE.PointLightHelper = function (e, t) { this.light = e; this.light.updateMatrixWorld(); var n = new THREE.SphereGeometry(t, 4, 2); var r = new THREE.MeshBasicMaterial({ wireframe: true, fog: false }); r.color.copy(this.light.color).multiplyScalar(this.light.intensity); THREE.Mesh.call(this, n, r); this.matrixWorld = this.light.matrixWorld; this.matrixAutoUpdate = false }; THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype); THREE.PointLightHelper.prototype.dispose = function () { this.geometry.dispose(); this.material.dispose() }; THREE.PointLightHelper.prototype.update = function () { this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity) }; THREE.VertexNormalsHelper = function (e, t, n, r) { this.object = e; this.size = t || 1; var i = n || 16711680; var s = r || 1; var o = new THREE.Geometry; var u = e.geometry.vertices; var a = e.geometry.faces; for (var f = 0, l = a.length; f < l; f++) { var c = a[f]; for (var h = 0, p = c.vertexNormals.length; h < p; h++) { o.vertices.push(new THREE.Vector3); o.vertices.push(new THREE.Vector3) } } THREE.Line.call(this, o, new THREE.LineBasicMaterial({ color: i, linewidth: s }), THREE.LinePieces); this.matrixAutoUpdate = false; this.normalMatrix = new THREE.Matrix3; this.update() }; THREE.VertexNormalsHelper.prototype = Object.create(THREE.Line.prototype); THREE.VertexNormalsHelper.prototype.update = function (e) { var t = new THREE.Vector3; return function (e) { var n = ["a", "b", "c", "d"]; this.object.updateMatrixWorld(true); this.normalMatrix.getNormalMatrix(this.object.matrixWorld); var r = this.geometry.vertices; var i = this.object.geometry.vertices; var s = this.object.geometry.faces; var o = this.object.matrixWorld; var u = 0; for (var a = 0, f = s.length; a < f; a++) { var l = s[a]; for (var c = 0, h = l.vertexNormals.length; c < h; c++) { var p = l[n[c]]; var d = i[p]; var v = l.vertexNormals[c]; r[u].copy(d).applyMatrix4(o); t.copy(v).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size); t.add(r[u]); u = u + 1; r[u].copy(t); u = u + 1 } } this.geometry.verticesNeedUpdate = true; return this } }(); THREE.VertexTangentsHelper = function (e, t, n, r) { this.object = e; this.size = t || 1; var i = n || 255; var s = r || 1; var o = new THREE.Geometry; var u = e.geometry.vertices; var a = e.geometry.faces; for (var f = 0, l = a.length; f < l; f++) { var c = a[f]; for (var h = 0, p = c.vertexTangents.length; h < p; h++) { o.vertices.push(new THREE.Vector3); o.vertices.push(new THREE.Vector3) } } THREE.Line.call(this, o, new THREE.LineBasicMaterial({ color: i, linewidth: s }), THREE.LinePieces); this.matrixAutoUpdate = false; this.update() }; THREE.VertexTangentsHelper.prototype = Object.create(THREE.Line.prototype); THREE.VertexTangentsHelper.prototype.update = function (e) { var t = new THREE.Vector3; return function (e) { var n = ["a", "b", "c", "d"]; this.object.updateMatrixWorld(true); var r = this.geometry.vertices; var i = this.object.geometry.vertices; var s = this.object.geometry.faces; var o = this.object.matrixWorld; var u = 0; for (var a = 0, f = s.length; a < f; a++) { var l = s[a]; for (var c = 0, h = l.vertexTangents.length; c < h; c++) { var p = l[n[c]]; var d = i[p]; var v = l.vertexTangents[c]; r[u].copy(d).applyMatrix4(o); t.copy(v).transformDirection(o).multiplyScalar(this.size); t.add(r[u]); u = u + 1; r[u].copy(t); u = u + 1 } } this.geometry.verticesNeedUpdate = true; return this } }(); THREE.WireframeHelper = function (e) { var t = [0, 0], n = {}; var r = function (e, t) { return e - t }; var i = ["a", "b", "c", "d"]; var s = new THREE.Geometry; var o = e.geometry.vertices; var u = e.geometry.faces; for (var a = 0, f = u.length; a < f; a++) { var l = u[a]; for (var c = 0; c < 3; c++) { t[0] = l[i[c]]; t[1] = l[i[(c + 1) % 3]]; t.sort(r); var h = t.toString(); if (n[h] === undefined) { s.vertices.push(o[t[0]]); s.vertices.push(o[t[1]]); n[h] = true } } } THREE.Line.call(this, s, new THREE.LineBasicMaterial({ color: 16777215 }), THREE.LinePieces); this.matrixAutoUpdate = false; this.matrixWorld = e.matrixWorld }; THREE.WireframeHelper.prototype = Object.create(THREE.Line.prototype); THREE.ImmediateRenderObject = function () { THREE.Object3D.call(this); this.render = function (e) { } }; THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype); THREE.MorphBlendMesh = function (e, t) { THREE.Mesh.call(this, e, t); this.animationsMap = {}; this.animationsList = []; var n = this.geometry.morphTargets.length; var r = "__default"; var i = 0; var s = n - 1; var o = n / 1; this.createAnimation(r, i, s, o); this.setAnimationWeight(r, 1) }; THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype); THREE.MorphBlendMesh.prototype.createAnimation = function (e, t, n, r) { var i = { startFrame: t, endFrame: n, length: n - t + 1, fps: r, duration: (n - t) / r, lastFrame: 0, currentFrame: 0, active: false, time: 0, direction: 1, weight: 1, directionBackwards: false, mirroredLoop: false }; this.animationsMap[e] = i; this.animationsList.push(i) }; THREE.MorphBlendMesh.prototype.autoCreateAnimations = function (e) { var t = /([a-z]+)(\d+)/; var n, r = {}; var i = this.geometry; for (var s = 0, o = i.morphTargets.length; s < o; s++) { var u = i.morphTargets[s]; var a = u.name.match(t); if (a && a.length > 1) { var f = a[1]; var l = a[2]; if (!r[f]) r[f] = { start: Infinity, end: -Infinity }; var c = r[f]; if (s < c.start) c.start = s; if (s > c.end) c.end = s; if (!n) n = f } } for (var f in r) { var c = r[f]; this.createAnimation(f, c.start, c.end, e) } this.firstAnimation = n }; THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function (e) { var t = this.animationsMap[e]; if (t) { t.direction = 1; t.directionBackwards = false } }; THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function (e) { var t = this.animationsMap[e]; if (t) { t.direction = -1; t.directionBackwards = true } }; THREE.MorphBlendMesh.prototype.setAnimationFPS = function (e, t) { var n = this.animationsMap[e]; if (n) { n.fps = t; n.duration = (n.end - n.start) / n.fps } }; THREE.MorphBlendMesh.prototype.setAnimationDuration = function (e, t) { var n = this.animationsMap[e]; if (n) { n.duration = t; n.fps = (n.end - n.start) / n.duration } }; THREE.MorphBlendMesh.prototype.setAnimationWeight = function (e, t) { var n = this.animationsMap[e]; if (n) { n.weight = t } }; THREE.MorphBlendMesh.prototype.setAnimationTime = function (e, t) { var n = this.animationsMap[e]; if (n) { n.time = t } }; THREE.MorphBlendMesh.prototype.getAnimationTime = function (e) { var t = 0; var n = this.animationsMap[e]; if (n) { t = n.time } return t }; THREE.MorphBlendMesh.prototype.getAnimationDuration = function (e) { var t = -1; var n = this.animationsMap[e]; if (n) { t = n.duration } return t }; THREE.MorphBlendMesh.prototype.playAnimation = function (e) { var t = this.animationsMap[e]; if (t) { t.time = 0; t.active = true } else { console.warn("animation[" + e + "] undefined") } }; THREE.MorphBlendMesh.prototype.stopAnimation = function (e) { var t = this.animationsMap[e]; if (t) { t.active = false } }; THREE.MorphBlendMesh.prototype.update = function (e) { for (var t = 0, n = this.animationsList.length; t < n; t++) { var r = this.animationsList[t]; if (!r.active) continue; var i = r.duration / r.length; r.time += r.direction * e; if (r.mirroredLoop) { if (r.time > r.duration || r.time < 0) { r.direction *= -1; if (r.time > r.duration) { r.time = r.duration; r.directionBackwards = true } if (r.time < 0) { r.time = 0; r.directionBackwards = false } } } else { r.time = r.time % r.duration; if (r.time < 0) r.time += r.duration } var s = r.startFrame + THREE.Math.clamp(Math.floor(r.time / i), 0, r.length - 1); var o = r.weight; if (s !== r.currentFrame) { this.morphTargetInfluences[r.lastFrame] = 0; this.morphTargetInfluences[r.currentFrame] = 1 * o; this.morphTargetInfluences[s] = 0; r.lastFrame = r.currentFrame; r.currentFrame = s } var u = r.time % i / i; if (r.directionBackwards) u = 1 - u; this.morphTargetInfluences[r.currentFrame] = u * o; this.morphTargetInfluences[r.lastFrame] = (1 - u) * o } }; THREE.ShadowMapPlugin = function () { function c(e, t) { var n = new THREE.DirectionalLight; n.isVirtual = true; n.onlyShadow = true; n.castShadow = true; n.shadowCameraNear = e.shadowCameraNear; n.shadowCameraFar = e.shadowCameraFar; n.shadowCameraLeft = e.shadowCameraLeft; n.shadowCameraRight = e.shadowCameraRight; n.shadowCameraBottom = e.shadowCameraBottom; n.shadowCameraTop = e.shadowCameraTop; n.shadowCameraVisible = e.shadowCameraVisible; n.shadowDarkness = e.shadowDarkness; n.shadowBias = e.shadowCascadeBias[t]; n.shadowMapWidth = e.shadowCascadeWidth[t]; n.shadowMapHeight = e.shadowCascadeHeight[t]; n.pointsWorld = []; n.pointsFrustum = []; var r = n.pointsWorld, i = n.pointsFrustum; for (var s = 0; s < 8; s++) { r[s] = new THREE.Vector3; i[s] = new THREE.Vector3 } var o = e.shadowCascadeNearZ[t]; var u = e.shadowCascadeFarZ[t]; i[0].set(-1, -1, o); i[1].set(1, -1, o); i[2].set(-1, 1, o); i[3].set(1, 1, o); i[4].set(-1, -1, u); i[5].set(1, -1, u); i[6].set(-1, 1, u); i[7].set(1, 1, u); return n } function h(e, t) { var n = e.shadowCascadeArray[t]; n.position.copy(e.position); n.target.position.copy(e.target.position); n.lookAt(n.target); n.shadowCameraVisible = e.shadowCameraVisible; n.shadowDarkness = e.shadowDarkness; n.shadowBias = e.shadowCascadeBias[t]; var r = e.shadowCascadeNearZ[t]; var i = e.shadowCascadeFarZ[t]; var s = n.pointsFrustum; s[0].z = r; s[1].z = r; s[2].z = r; s[3].z = r; s[4].z = i; s[5].z = i; s[6].z = i; s[7].z = i } function p(e, t) { var n = t.shadowCamera, r = t.pointsFrustum, i = t.pointsWorld; a.set(Infinity, Infinity, Infinity); f.set(-Infinity, -Infinity, -Infinity); for (var s = 0; s < 8; s++) { var o = i[s]; o.copy(r[s]); THREE.ShadowMapPlugin.__projector.unprojectVector(o, e); o.applyMatrix4(n.matrixWorldInverse); if (o.x < a.x) a.x = o.x; if (o.x > f.x) f.x = o.x; if (o.y < a.y) a.y = o.y; if (o.y > f.y) f.y = o.y; if (o.z < a.z) a.z = o.z; if (o.z > f.z) f.z = o.z } n.left = a.x; n.right = f.x; n.top = f.y; n.bottom = a.y; n.updateProjectionMatrix() } function d(e) { return e.material instanceof THREE.MeshFaceMaterial ? e.material.materials[0] : e.material } var e, t, n, r, i, s, o = new THREE.Frustum, u = new THREE.Matrix4, a = new THREE.Vector3, f = new THREE.Vector3, l = new THREE.Vector3; this.init = function (o) { e = o.context; t = o; var u = THREE.ShaderLib["depthRGBA"]; var a = THREE.UniformsUtils.clone(u.uniforms); n = new THREE.ShaderMaterial({ fragmentShader: u.fragmentShader, vertexShader: u.vertexShader, uniforms: a }); r = new THREE.ShaderMaterial({ fragmentShader: u.fragmentShader, vertexShader: u.vertexShader, uniforms: a, morphTargets: true }); i = new THREE.ShaderMaterial({ fragmentShader: u.fragmentShader, vertexShader: u.vertexShader, uniforms: a, skinning: true }); s = new THREE.ShaderMaterial({ fragmentShader: u.fragmentShader, vertexShader: u.vertexShader, uniforms: a, morphTargets: true, skinning: true }); n._shadowPass = true; r._shadowPass = true; i._shadowPass = true; s._shadowPass = true }; this.render = function (e, n) { if (!(t.shadowMapEnabled && t.shadowMapAutoUpdate)) return; this.update(e, n) }; this.update = function (i, s) { var a, f, v, m, g, y, b, w, E, S, x, T, N, C, k, L = [], A = 0, O = null; e.clearColor(1, 1, 1, 1); e.disable(e.BLEND); e.enable(e.CULL_FACE); e.frontFace(e.CCW); if (t.shadowMapCullFace === THREE.CullFaceFront) { e.cullFace(e.FRONT) } else { e.cullFace(e.BACK) } t.setDepthTest(true); for (a = 0, f = i.__lights.length; a < f; a++) { C = i.__lights[a]; if (!C.castShadow) continue; if (C instanceof THREE.DirectionalLight && C.shadowCascade) { for (g = 0; g < C.shadowCascadeCount; g++) { var M; if (!C.shadowCascadeArray[g]) { M = c(C, g); M.originalCamera = s; var _ = new THREE.Gyroscope; _.position = C.shadowCascadeOffset; _.add(M); _.add(M.target); s.add(_); C.shadowCascadeArray[g] = M; console.log("Created virtualLight", M) } else { M = C.shadowCascadeArray[g] } h(C, g); L[A] = M; A++ } } else { L[A] = C; A++ } } for (a = 0, f = L.length; a < f; a++) { C = L[a]; if (!C.shadowMap) { var D = THREE.LinearFilter; if (t.shadowMapType === THREE.PCFSoftShadowMap) { D = THREE.NearestFilter } var P = { minFilter: D, magFilter: D, format: THREE.RGBAFormat }; C.shadowMap = new THREE.WebGLRenderTarget(C.shadowMapWidth, C.shadowMapHeight, P); C.shadowMapSize = new THREE.Vector2(C.shadowMapWidth, C.shadowMapHeight); C.shadowMatrix = new THREE.Matrix4 } if (!C.shadowCamera) { if (C instanceof THREE.DirectionalLight) { C.shadowCamera = new THREE.OrthographicCamera(C.shadowCameraLeft, C.shadowCameraRight, C.shadowCameraTop, C.shadowCameraBottom, C.shadowCameraNear, C.shadowCameraFar) } else { console.error("Unsupported light type for shadow"); continue } i.add(C.shadowCamera); if (i.autoUpdate === true) i.updateMatrixWorld() } if (C.shadowCameraVisible && !C.cameraHelper) { C.cameraHelper = new THREE.CameraHelper(C.shadowCamera); C.shadowCamera.add(C.cameraHelper) } if (C.isVirtual && M.originalCamera == s) { p(s, C) } y = C.shadowMap; b = C.shadowMatrix; w = C.shadowCamera; w.position.getPositionFromMatrix(C.matrixWorld); l.getPositionFromMatrix(C.target.matrixWorld); w.lookAt(l); w.updateMatrixWorld(); w.matrixWorldInverse.getInverse(w.matrixWorld); if (C.cameraHelper) C.cameraHelper.visible = C.shadowCameraVisible; if (C.shadowCameraVisible) C.cameraHelper.update(); b.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1); b.multiply(w.projectionMatrix); b.multiply(w.matrixWorldInverse); u.multiplyMatrices(w.projectionMatrix, w.matrixWorldInverse); o.setFromMatrix(u); t.setRenderTarget(y); t.clear(); k = i.__webglObjects; for (v = 0, m = k.length; v < m; v++) { T = k[v]; N = T.object; T.render = false; if (N.visible && N.castShadow) { if (!(N instanceof THREE.Mesh || N instanceof THREE.ParticleSystem) || !N.frustumCulled || o.intersectsObject(N)) { N._modelViewMatrix.multiplyMatrices(w.matrixWorldInverse, N.matrixWorld); T.render = true } } } var H, B, j; for (v = 0, m = k.length; v < m; v++) { T = k[v]; if (T.render) { N = T.object; S = T.buffer; H = d(N); B = N.geometry.morphTargets.length > 0 && H.morphTargets; if (N.customDepthMaterial) { x = N.customDepthMaterial } else if (B) { x = r } else { x = n } if (S instanceof THREE.BufferGeometry) { t.renderBufferDirect(w, i.__lights, O, x, S, N) } else { t.renderBuffer(w, i.__lights, O, x, S, N) } } } k = i.__webglObjectsImmediate; for (v = 0, m = k.length; v < m; v++) { T = k[v]; N = T.object; if (N.visible && N.castShadow) { N._modelViewMatrix.multiplyMatrices(w.matrixWorldInverse, N.matrixWorld); t.renderImmediateObject(w, i.__lights, O, n, N) } } } var F = t.getClearColor(), I = t.getClearAlpha(); e.clearColor(F.r, F.g, F.b, I); e.enable(e.BLEND); if (t.shadowMapCullFace === THREE.CullFaceFront) { e.cullFace(e.BACK) } }; }; THREE.ShadowMapPlugin.__projector = new THREE.Projector